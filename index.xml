<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>承离的觉前</title>
    <link>https://tinklespring.com/</link>
    <description>Recent content on 承离的觉前</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 28 Aug 2023 13:42:33 +0800</lastBuildDate>
    
        <atom:link href="https://tinklespring.com/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>const&#43;iota枚举最佳方式</title>
      <link>https://tinklespring.com/posts/const&#43;iota%E6%9E%9A%E4%B8%BE%E6%9C%80%E4%BD%B3%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 28 Aug 2023 13:42:33 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/const&#43;iota%E6%9E%9A%E4%B8%BE%E6%9C%80%E4%BD%B3%E6%96%B9%E5%BC%8F/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Go中没有直接的枚举类型，但可以通过conts和iota来模拟枚举。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;传统的枚举实现&#34;&gt;传统的枚举实现&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const (
	Sunday = 0
	Monday = 1
	Tuesday = 2
	Wednesday = 3
	Thursday = 4
	Friday = 5
	Saturday = 6
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种方式不直观，可读性差。&lt;/p&gt;
&lt;h1 id=&#34;使用iota实现枚举&#34;&gt;使用iota实现枚举&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;iota会自动累加生成序列常量，这种方式很直观。&lt;/p&gt;
&lt;h1 id=&#34;值iota自动填充&#34;&gt;值iota自动填充&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const (
	_ = iota
	Sunday  //1
	_
	Tuesday  //3
)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;自定义iota起始值&#34;&gt;自定义iota起始值&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const (
	StartAt = iota + 1  //1
	Sunday  //2
	Monday  //3
)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;多个iota定义&#34;&gt;多个iota定义&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const (
	A = iota  //0
	B         //1
	C = iota  //2
	D         //3
)
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const (
	A = iota // 0
	B        // 1
)

const (
	C = iota // 0 (因为新的const块，iota重新开始计数)
	D        // 1
)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;位运算模拟位掩码&#34;&gt;位运算模拟位掩码&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const (
  Read = 1 &amp;lt;&amp;lt; iota // 1
  Write            // 2
  Execute          // 4 
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;iota 初始值是 0，然后它被位移操作符 &amp;laquo; 逐渐左移一位，即 1 &amp;laquo; 0、1 &amp;laquo; 1、1 &amp;laquo; 2 等。这会使得 Read 的值为 1、Write 的值为 2，而 Execute 的值会是 4。&lt;/p&gt;
&lt;p&gt;具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read 对应的二进制是 001，左移 0 位，值为 1。&lt;/li&gt;
&lt;li&gt;Write 对应的二进制是 010，左移 1 位，值为 2。&lt;/li&gt;
&lt;li&gt;Execute 对应的二进制是 100，左移 2 位，值为 4。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;字符串类型枚举&#34;&gt;字符串类型枚举&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const (
  Unknown = &amp;#34;UNKNOWN&amp;#34;
  Male = &amp;#34;MALE&amp;#34;
  Female = &amp;#34;FEMALE&amp;#34;
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go中，iota 用于自动递增生成常量序列的枚举器，只能用于整数类型，如果想对字符串枚举，不能使用 iota。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>15.泛型</title>
      <link>https://tinklespring.com/posts/15.%E6%B3%9B%E5%9E%8B/</link>
      <pubDate>Thu, 24 Aug 2023 08:17:30 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/15.%E6%B3%9B%E5%9E%8B/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;2022年3月15日，泛型终于在Go1.18发布～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;函数的行参和实参&#34;&gt;函数的行参和实参&lt;/h1&gt;
&lt;p&gt;假设有个计算两数之和的函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func Add(a int, b int) int {
	return a + b
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个函数比较简单，但是无法计算int类型之外的和，如果想计算浮点数或字符串的和怎么办？解决方式之一就是为不同的类型定义不同的函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func AddFloat32(a float32, b float32) float32 {
	return a + b
}
func AddString(a string, b string) string {
	return a + b
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数的&lt;code&gt;行参（parameter）&lt;/code&gt;和&lt;code&gt;实参（argument）&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func Add(a int, b int) int {
	// 变量a，b是函数的行参；&amp;#34;a int, b int&amp;#34; 这一串被称为行参列表
	return a + b
}
Add(100, 200) //调用函数时，传入的100和200是实参
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数的行参只是类似占位符实际并没有具体值，只有调用函数传入实参之后才有具体的值。&lt;/p&gt;
&lt;p&gt;如果将行参、实参推广一下，给变量的类型也引入和类似行参的概念的话，问题就迎刃而解，给其命名为 &lt;code&gt;类型行参type parameter&lt;/code&gt;和&lt;code&gt;类型实参type argument&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//假设T是类型行参，在定义函数时其类型不确定，类似占位符
func Add(a T, b T) T {
	return a + b
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述伪代码中，T被称为类型行参，不是具体的类型，因为T类型不确定，所以需要像函数行参那样，在调用函数时传入具体类型，这样一个函数就能同时支持多个不同的类型，这里被传入的具体类型称为类型实参。&lt;br&gt;
再写一段伪代码：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//[T=int]中的int是类型实参，代表Add()函数中定义的类型行参T全都被int替换
Add[T=int](100, 200)
//传入类型实参int后，Add()函数的定义可近似堪称如下这样：
func Add(a int, b int) int {
	return a + b
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一个例子，当想要计算两个字符串之和时，就传入string类型实参：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Add[T=string](&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;)
//了行实参string传入后，Add()定义近似如下：
func Add(a string, b string) string {
	return a + b
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过引入类型行参和类型实参两个概念，让函数获得了处理多种不同类型数据的能力，这种编程方式称为&lt;code&gt;泛型编程&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;虽然Go的 接口+反射 也能实现这样的动态数据处理，但是反射的问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用起来比较麻烦&lt;/li&gt;
&lt;li&gt;失去了编译时的类型检查，容易写错&lt;/li&gt;
&lt;li&gt;性能差&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;泛型的适用场景：&lt;br&gt;
&lt;code&gt;如果经常要分别为不同的类型编写完全相同逻辑的代码，那么泛型是最佳选择。&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;go的泛型&#34;&gt;Go的泛型&lt;/h1&gt;
&lt;p&gt;Go引入了全新的概念实现泛型编程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型行参（type parameter）&lt;/li&gt;
&lt;li&gt;类型实参（type argument）&lt;/li&gt;
&lt;li&gt;类型行参列表（type parameter list）&lt;/li&gt;
&lt;li&gt;类型约束（type constraint）&lt;/li&gt;
&lt;li&gt;实例化（instantiations）&lt;/li&gt;
&lt;li&gt;泛型类型（generic type）&lt;/li&gt;
&lt;li&gt;泛型接收器（generic receiver）&lt;/li&gt;
&lt;li&gt;泛型函数（generic function）&lt;/li&gt;
&lt;li&gt;&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;类型行参类型实参类型约束和泛型类型&#34;&gt;类型行参、类型实参、类型约束和泛型类型&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Slice[T int|float32|float64] []T
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;T&lt;/code&gt;就是 类型行参 ，在定义Slice类型的时候T代表的具体类型并不确定，类似一个占位符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int|float32|float64&lt;/code&gt;这部分被称为 类型约束 ，中间的 &lt;code&gt;|&lt;/code&gt; 意思是告诉编译器，类型行参 T 只可以接收 int 或 float32 或 float64 这三种类型实参&lt;/li&gt;
&lt;li&gt;中括号里的 &lt;code&gt;T int|float32|float64&lt;/code&gt; 这一整串定义所有类型的行参，所以称其为 类型行参列表&lt;/li&gt;
&lt;li&gt;新定义的类型名称为 &lt;code&gt;Slice[T]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种类型定义的方式中带了类型行参，与普通的类型定义不一样，称这种类型定义中带 类型行参 的类型，叫 &lt;code&gt;泛型类型 generic type&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;泛型类型不能直接使用，必须传入 类型实参 将其确定为具体的类型后才能使用。传入类型实参确定具体类型的操作被称为 &lt;code&gt;实例化&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//传入类型实参int，泛型类型Slice[T]被实例化为具体的类型 Slice[int]
var a Slice[int] = []int{1, 2, 3}
fmt.Printf(&amp;#34;Type Name: %T&amp;#34;, a)   //输出：Type Name: Slice[int]

//传入类型实参float32，将泛型类型Slice[T]实例化为具体的类型 Slice[float32]
var b Slice[float32] = []float32{1.0, 2.0, 3.0}
fmt.Printf(&amp;#34;Type Name: %T&amp;#34;, b)  //输出：Type Name: Slice[float32]

//下面错误，a类型为Slice[int]，b类型为Slice[float32]，不同类型之间的变量赋值不允许
a = b

//下面错误，Slice[T]是泛型类型，不可直接使用必须实例化为具体类型
var x Slice[T] = []int{1, 2, 3}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map类型示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// MyMap类型定义了两个类型形参 KEY 和 VALUE。分别为两个形参指定了不同的类型约束
// 这个泛型类型的名字叫： MyMap[KEY, VALUE]
type MyMap[KEY int | string, VALUE float32 | float64] map[KEY]VALUE  

// 用类型实参 string 和 flaot64 替换了类型形参 KEY 、 VALUE，泛型类型被实例化为具体的类型：MyMap[string, float64]
var a MyMap[string, float64] = map[string]float64 {
    &amp;#34;jack_score&amp;#34;: 9.6,
    &amp;#34;bob_score&amp;#34;:  8.4,
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;KEY和VALUE是类型行参&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int | string&lt;/code&gt;是KEY的类型约束，&lt;code&gt;float32 | float64&lt;/code&gt;是VALUE的类型约束&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KEY int | string, VALUE float32&lt;/code&gt;是类型约束列表&lt;/li&gt;
&lt;li&gt;MyMap[KEY, VALUE] 是泛型类型，类型的名字就叫MyMap[KEY, VALUE]&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var a MyMap[string, float64] = map[string]float64&lt;/code&gt;中的string和float64是类型实参，分别用于替换 KEY 和 VALUE，实例化出了具体的类型 MyMap[string, float32]&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;其他泛型类型&#34;&gt;其他泛型类型&lt;/h4&gt;
&lt;p&gt;所有类型定义都可使用类型行参，下面这种结构体及接口定义也可以使用类型行参：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//一个泛型类型的结构体，可用 int 或 string 类型实例化
type MyStruct[T int | string] struct {
	Name string
	Data T
}
//一个泛型接口
type IPrintData[T int | float32 | string] interface {
	Print(data T)
}
//一个泛型channel，可用类型实参 int 或 string 实例化
type MyChan[T int | string] chan T
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;类型行参相互套用&#34;&gt;类型行参相互套用&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type WowStruct[T int | float32, S []T] struct {
    Data     S
    MaxValue T
    MinValue T
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码有点复杂且难懂，只要记住：&lt;code&gt;任何泛型类型都必须传入类型实参实例化才可以使用&lt;/code&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//泛型类型 WowStruct[T, S] 被实例化后的类型名字叫 WowStruct[int, []int]
var ws WowStruct[int, []int]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面为T传入了实参int，然后因为S的定义是 []T，所以S的实参是 []int，经过实例化后， WowStruct[T, S] 的定义类型如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//一个存储int类型切片，以及切片中最大、最小值的结构体
type WowStruct[int, []int] struct {
	Data     []int
	MaxValue int
	MinValue int
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为S定义是 []T，所以T一旦确定，S实参就不能随意传，如下代码是错误的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//错误，S定义是[]T，这里T传入了实参int，所以S实参应当为 []int 而不是[]float32
ws := WowStruct[int, []float32]{
        Data:     []float32{1.0, 2.0, 3.0},
        MaxValue: 3,
        MinValue: 1,
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;语法使用&#34;&gt;语法使用&lt;/h4&gt;
&lt;p&gt;1.定义泛型的时候，&lt;strong&gt;基础类型不能只有类型行参&lt;/strong&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//错误，类型行参不能单独使用
type CommonType[T int|string|float32] T
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.类型约束正确写法是，给类型约束包上&lt;code&gt;interface{}&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type NewType[T interface{*int}] []T
type NewType2[T interface{*int|*float64}] []T 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;特殊的泛型类型&#34;&gt;特殊的泛型类型&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Wow[T int | string] int

var a Wow[int] = 123     // 编译正确
var b Wow[string] = 123  // 编译正确
var c Wow[string] = &amp;#34;hello&amp;#34; // 编译错误，因为&amp;#34;hello&amp;#34;不能赋值给底层类型int
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然使用了类型行参，但因为类型定义是 &lt;code&gt;type Wow[T int | string] int&lt;/code&gt;，所以无论传入什么类型实参，实例化后的新类型的底层类型都是int。&lt;/p&gt;
&lt;h4 id=&#34;泛型类型的嵌套&#34;&gt;泛型类型的嵌套&lt;/h4&gt;
&lt;p&gt;泛型和普通的类型一样，可以互相嵌套定义出更加复杂的新类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 先定义个泛型类型 Slice[T]
type Slice[T int|string|float32|float64] []T

// ✗ 错误。泛型类型Slice[T]的类型约束中不包含uint, uint8
type UintSlice[T uint|uint8] Slice[T]  

// ✓ 正确。基于泛型类型Slice[T]定义了新的泛型类型 FloatSlice[T] 。FloatSlice[T]只接受float32和float64两种类型
type FloatSlice[T float32|float64] Slice[T] 

// ✓ 正确。基于泛型类型Slice[T]定义的新泛型类型 IntAndStringSlice[T]
type IntAndStringSlice[T int|string] Slice[T]  
// ✓ 正确 基于IntAndStringSlice[T]套娃定义出的新泛型类型
type IntSlice[T int] IntAndStringSlice[T] 

// 在map中套一个泛型类型Slice[T]
type WowMap[T int|string] map[string]Slice[T]
// 在map中套Slice[T]的另一种写法
type WowMap2[T Slice[int] | Slice[string]] map[string]T
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;类型约束的两种选择&#34;&gt;类型约束的两种选择&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type WowStruct[T int|string] struct {
    Name string
    Data []T
}

type WowStruct2[T []int|[]string] struct {
    Name string
    Data T
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两种写法与实现的功能差不多，实例化之后结构体相同，但像下面这种情况，这样写会更好：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type WowStruct3[T int | string] struct {
    Data     []T
    MaxValue T
    MinValue T
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;匿名结构体不支持泛型&#34;&gt;匿名结构体不支持泛型&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;testCase := struct {
        caseName string
        got      int
        want     int
    }{
        caseName: &amp;#34;test OK&amp;#34;,
        got:      100,
        want:     100,
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在定义好匿名结构体后，直接初始化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;匿名结构体不能使用泛型&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;泛型receiver&#34;&gt;泛型receiver&lt;/h1&gt;
&lt;p&gt;定义了新的普通类型后可以给类型添加方法，可以给泛型类型添加方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MySlice[T int | float32] []T

func (s MySlice[T]) Sum() T {
    var sum T
    for _, value := range s {
        sum += value
    }
    return sum
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;首先&lt;code&gt;s MySlice[T]&lt;/code&gt;，所以直接把类型名称 &lt;code&gt;MySlice[T]&lt;/code&gt; 写入了receiver中&lt;/li&gt;
&lt;li&gt;方法的返回参数使用了类型行参T（若有需要，方法的接收参数也可以使用类型行参）&lt;/li&gt;
&lt;li&gt;在方法定义中，也可以使用类型行参T（通过 &lt;code&gt;var sum T&lt;/code&gt;定义一个新的变量 sum）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;MySlice[T]&lt;/code&gt;这个泛型类型如何用呢？泛型类型无论如何都需要首先进行类型实参实例化：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var s MySlice[int] = []int{1, 2, 3, 4}
fmt.Println(s.Sum()) // 输出：10

var s2 MySlice[float32] = []float32{1.0, 2.0, 3.0, 4.0}
fmt.Println(s2.Sum()) // 输出：10.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先用类型实参int实例化了泛型类型&lt;code&gt;MySlice[T]&lt;/code&gt;，所以泛型类型定义中的所有 T 都被替换成 int，最终可以把代码看作这样：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MySlice[int] []int // 实例化后的类型名叫 MyIntSlice[int]

// 方法中所有类型形参 T 都被替换为类型实参 int
func (s MySlice[int]) Sum() int {
    var sum int 
    for _, value := range s {
        sum += value
    }
    return sum
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过泛型receiver，泛型实用性得到了扩展，没有泛型之前，想实现通用的数据结构，比如：堆、栈、队列、链表之类，只有两个选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为每种类型写一个实现&lt;/li&gt;
&lt;li&gt;使用 接口+反射&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了泛型后，就能很简单创建通用数据结构。&lt;/p&gt;
&lt;h4 id=&#34;基于泛型的队列&#34;&gt;基于泛型的队列&lt;/h4&gt;
&lt;p&gt;队列是一种先入先出的数据结构，和现实中排队一样，数据只能从队尾放入，从队首取出。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 这里类型约束使用了空接口，代表的意思是所有类型都可以用来实例化泛型类型 Queue[T]
type Queue[T interface{}] struct {
    elements []T
}

// 将数据放入队列尾部
func (q *Queue[T]) Put(value T) {
    q.elements = append(q.elements, value)
}

// 从队列头部取出并从头部删除对应数据
func (q *Queue[T]) Pop() (T, bool) {
    var value T
    if len(q.elements) == 0 {
        return value, true
    }

    value = q.elements[0]
    q.elements = q.elements[1:]
    return value, len(q.elements) == 0
}

// 队列大小
func (q Queue[T]) Size() int {
    return len(q.elements)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Queue[T] 是泛型类型，要使用必须实例化，实例化与使用方式：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var q1 Queue[int]  // 可存放int类型数据的队列
q1.Put(1)
q1.Put(2)
q1.Put(3)
q1.Pop() // 1
q1.Pop() // 2
q1.Pop() // 3

var q2 Queue[string]  // 可存放string类型数据的队列
q2.Put(&amp;#34;A&amp;#34;)
q2.Put(&amp;#34;B&amp;#34;)
q2.Put(&amp;#34;C&amp;#34;)
q2.Pop() // &amp;#34;A&amp;#34;
q2.Pop() // &amp;#34;B&amp;#34;
q2.Pop() // &amp;#34;C&amp;#34;

var q3 Queue[struct{Name string}] 
var q4 Queue[[]int] // 可存放[]int切片的队列
var q5 Queue[chan int] // 可存放int通道的队列
var q6 Queue[io.Reader] // 可存放接口的队列
// ......
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;动态判断变量类型&#34;&gt;动态判断变量类型&lt;/h4&gt;
&lt;p&gt;使用接口时经常会用到类型断言或type switch 来确定接口具体类型，然后对不同类型做不同处理：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var i interface{} = 123
i.(int) // 类型断言

// type switch
switch i.(type) {
    case int:
        // do something
    case string:
        // do something
    default:
        // do something
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于 &lt;code&gt;value T&lt;/code&gt; 这样通过类型行参定义的变量，不允许判断具体类型然后对不同类型做出不同处理：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (q *Queue[T]) Put(value T) {
    value.(int) // 错误。泛型类型定义的变量不能使用类型断言

    // 错误。不允许使用type switch 来判断 value 的具体类型
    switch value.(type) {
    case int:
        // do something
    case string:
        // do something
    default:
        // do something
    }
    
    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然type switch和类型断言不能用，但可以通过反射实现：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (receiver Queue[T]) Put(value T) {
    // Printf() 可输出变量value的类型(底层就是通过反射实现的)
    fmt.Printf(&amp;#34;%T&amp;#34;, value) 

    // 通过反射可以动态获得变量value的类型从而分情况处理
    v := reflect.ValueOf(value)

    switch v.Kind() {
    case reflect.Int:
        // do something
    case reflect.String:
        // do something
    }

    // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了避免使用反射而选择泛型，结果为了一些功能在泛型中使用反射。当出现这种情况需要重新思考，需求是不是真的要用泛型。&lt;/p&gt;
&lt;h1 id=&#34;泛型函数&#34;&gt;泛型函数&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func Add[T int | float32 | float64](a T, b T) T {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;带类型行参的函数称为&lt;code&gt;泛型函数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;与泛型类型一样，泛型函数不能直接调用，要使用泛型函数必须传入类型实参。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Add[int](1,2) // 传入类型实参int，计算结果为 3
Add[float32](1.0, 2.0) // 传入类型实参float32, 计算结果为 3.0

Add[string](&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;) // 错误。因为泛型函数Add的类型约束中并不包含string
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go也支持类型实参自动推导，这是编译器帮助推导了类型实参，实际上传入实参步骤还是实际发生的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Add(1, 2)  // 1，2是int类型，编译请自动推导出类型实参T是int
Add(1.0, 2.0) // 1.0, 2.0 是浮点，编译请自动推导出类型实参T是float32
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;匿名函数不支持泛型&#34;&gt;匿名函数不支持泛型&lt;/h4&gt;
&lt;p&gt;匿名函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fn := func(a, b int) int {
    return a + b 
}  // 定义了一个匿名函数并赋值给 fn 

fmt.Println(fn(1, 2)) // 输出: 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;匿名函数不能自己定义类型行参.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 错误，匿名函数不能自己定义类型实参
fnGeneric := func[T int | float32](a, b T) T {
        return a + b
} 

fmt.Println(fnGeneric(1, 2))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是匿名函数可以使用已经定义好的类型实参：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func MyFunc[T int | float32 | float64](a, b T) {

    // 匿名函数可使用已经定义好的类型形参
    fn2 := func(i T, j T) T {
        return i*2 - j*2
    }

    fn2(a, b)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;泛型方法&#34;&gt;泛型方法&lt;/h4&gt;
&lt;p&gt;目前Go的方法不支持泛型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type A struct {
}

// 不支持泛型方法
func (receiver A) Add[T int | float32 | float64](a T, b T) T {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是因为receiver支持泛型：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type A[T int | float32 | float64] struct {
}

// 方法可以使用类型定义中的形参 T 
func (receiver A[T]) Add(a T, b T) T {
    return a + b
}

// 用法：
var a A[int]
a.Add(1, 2)

var aa A[float32]
aa.Add(1.0, 2.0)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;小结&#34;&gt;小结&lt;/h1&gt;
&lt;p&gt;Go泛型（类型行参）目前可使用在3个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;泛型类型 - 类型定义中带类型行参的类型&lt;/li&gt;
&lt;li&gt;泛型receiver - 泛型类型的receiver&lt;/li&gt;
&lt;li&gt;泛型函数 - 带类型行参的函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为实现泛型，Go引入新概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类型行参&lt;/li&gt;
&lt;li&gt;类型行参列表&lt;/li&gt;
&lt;li&gt;类型实参&lt;/li&gt;
&lt;li&gt;类型约束&lt;/li&gt;
&lt;li&gt;实例化 - 泛型类型不能直接使用，必须传入类型实参进行实例化&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;变得复杂的接口&#34;&gt;变得复杂的接口&lt;/h1&gt;
&lt;p&gt;有时使用泛型时，可能会写很长的类型约束，但是Go支持将类型约束单独拿出来定义到接口中，让代码更好看：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type IntUintFloat interface {
    int | int8 | int16 | int32 | int64 | uint | uint8 | uint16 | uint32 | uint64 | float32 | float64
}

type Slice[T IntUintFloat] []T
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段代码把类型约束给单独拿出来，写入了接口类型 IntUintFloat 当中。需要指定类型约束的时候直接使用接口 IntUintFloat 即可。&lt;/p&gt;
&lt;p&gt;接口和接口、接口和普通类型之间也是可以通过 &lt;code&gt;|&lt;/code&gt; 进行组合：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Int interface {
    int | int8 | int16 | int32 | int64
}

type Uint interface {
    uint | uint8 | uint16 | uint32
}

type Float interface {
    float32 | float64
}

type Slice[T Int | Uint | Float] []T  // 使用 &amp;#39;|&amp;#39; 将多个接口类型组合
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在接口里也能直接组合其他接口：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type SliceElement interface {
    Int | Uint | Float | string // 组合了三个接口类型并额外增加了一个 string 类型
}

type Slice[T SliceElement] []T 
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;指定底层类型&#34;&gt;指定底层类型&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;~&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Int interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32
}
type Float interface {
    ~float32 | ~float64
}

type Slice[T Int | Uint | Float] []T 

var s Slice[int] // 正确

type MyInt int
var s2 Slice[MyInt]  // MyInt底层类型是int，所以可以用于实例化

type MyMyInt MyInt
var s3 Slice[MyMyInt]  // 正确。MyMyInt 虽然基于 MyInt ，但底层类型也是int，所以也能用于实例化

type MyFloat32 float32  // 正确
var s4 Slice[MyFloat32]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 &lt;code&gt;~&lt;/code&gt; 的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 后面类型不能为接口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 后面类型必须为基本类型&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyInt int

type _ interface {
    ~[]byte  // 正确
    ~MyInt   // 错误，~后的类型必须为基本类型
    ~error   // 错误，~后的类型不能为接口
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;从方法集到类型集&#34;&gt;从方法集到类型集&lt;/h4&gt;
&lt;p&gt;Go1.18后，接口定义：An interface type defines a type set&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Float interface {
    ~float32 | ~float64
}

type Slice[T Float] []T 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接口类型Float代表了一个 类型集合，所有以 float32 或 float64 为底层类型的类型，都在这一类型集中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;type Slice[T Float] []T&lt;/code&gt;中，类型约束真正的意思是：&lt;strong&gt;类型约束&lt;/strong&gt;指定了类型行参可接受的类型集合，只有属于这个集合中的类型才能替换行参用于实例化。&lt;/p&gt;
&lt;h4 id=&#34;接口实现定义的变化&#34;&gt;接口实现定义的变化&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;接口实现implement&lt;/code&gt;：&lt;br&gt;
当满足以下条件时，可以说&lt;strong&gt;类型T实现了接口I&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;T不是接口时：类型T是接口I代表的类型集中的一个成员&lt;/li&gt;
&lt;li&gt;T是接口时，T接口代表的类型集是I代表的类型集的子集&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;类型的并集&#34;&gt;类型的并集&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Uint interface {  // 类型集 Uint 是 ~uint 和 ~uint8 等类型的并集
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;类型的交集&#34;&gt;类型的交集&lt;/h4&gt;
&lt;p&gt;如果一个接口有多行类型定义，那么取它们之间的交集。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type AllInt interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64 | ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint32
}

type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type A interface { // 接口A代表的类型集是 AllInt 和 Uint 的交集
    AllInt
    Uint
}

type B interface { // 接口B代表的类型集是 AllInt 和 ~int 的交集
    AllInt
    ~int
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;接口A代表的是AllInt 与 Uint 的 交集，即 ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64&lt;/li&gt;
&lt;li&gt;接口 B 代表的则是 AllInt 和 ~int 的交集，即 ~int&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还有一种交集：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type C interface {
    ~int
    int
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;~int 和int 交集只有 int 一种类型。&lt;/p&gt;
&lt;h4 id=&#34;空集&#34;&gt;空集&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Bad interface {
    int
    float32 
} // 类型 int 和 float32 没有相交的类型，所以接口 Bad 代表的类型集为空
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bad这个接口代表的类型集为一个空集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;没有一种类型属于空集&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;空接口和any&#34;&gt;空接口和any&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;空接口代表了所有类型的集合&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;虽然空接口内没有写入任何的类型，但它代表的是所有类型的集合，而非一个 空集&lt;/li&gt;
&lt;li&gt;类型约束中指定 空接口 的意思是指定了一个包含所有类型的类型集，并不是类型约束限定了只能使用 空接口 来做类型形参&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 空接口代表所有类型的集合。写入类型约束意味着所有类型都可拿来做类型实参
type Slice[T interface{}] []T

var s1 Slice[int]    // 正确
var s2 Slice[map[string]string]  // 正确
var s3 Slice[chan int]  // 正确
var s4 Slice[interface{}]  // 正确
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go1.18开始提供了一个空接口 interface{} 等价的新关键词 &lt;code&gt;any&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Slice[T any] []T // 代码等价于 type Slice[T interface{}] []T
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go1.18开始，所有用到空接口的地方都可以直接替换为any：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var s []any // 等价于 var s []interface{}
var m map[string]any // 等价于 var m map[string]interface{}

func MyPrint(value any){
    fmt.Println(value)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;事实上，Go源码中，any 实际上就是 interface{} 的别名:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type any = interface{}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;comparable-和-ordered&#34;&gt;comparable 和 ordered&lt;/h4&gt;
&lt;p&gt;Go内置了一个叫 &lt;code&gt;comparable&lt;/code&gt;的接口，代表了所有可用&lt;code&gt;!=&lt;/code&gt;和&lt;code&gt;==&lt;/code&gt;对比的类型：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyMap[KEY comparable, VALUE any] map[KEY]VALUE // 正确
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;comparable&lt;/code&gt;可比较指的是可以执行&lt;code&gt;!=&lt;/code&gt;和&lt;code&gt;==&lt;/code&gt;操作的类型，并不是这个类型可以执行大小比较&lt;code&gt;&amp;gt;,&amp;lt;,&amp;lt;=,&amp;gt;=&lt;/code&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type OhMyStruct struct {
    a int
}

var a, b OhMyStruct

a == b // 正确。结构体可使用 == 进行比较
a != b // 正确

a &amp;gt; b // 错误。结构体不可比大小
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可进行大小比较的类型称为&lt;code&gt;ordered&lt;/code&gt; ，Go没有内置它，想用的话，需要自己来定义：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Ordered 代表所有可比大小排序的类型
type Ordered interface {
    Integer | Float | ~string
}

type Integer interface {
    Signed | Unsigned
}

type Signed interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Unsigned interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr
}

type Float interface {
    ~float32 | ~float64
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然可以直接使用，但是属于实验，不推荐使用。&lt;/p&gt;
&lt;h4 id=&#34;接口两种类型&#34;&gt;接口两种类型&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type ReadWriter interface {
    ~string | ~[]rune

    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接口类型 ReadWriter 代表了一个类型集合，所有以 string 或 []rune 为底层类型，并且实现了 Read() Write() 这两个方法的类型都在 ReadWriter 代表的类型集当中.&lt;/p&gt;
&lt;p&gt;当定义一个接口变量时，不光要考虑方法的实现，还必须考虑具体底层类型，Go1.18开始将接口分为了两种类型：&lt;strong&gt;基本接口&lt;/strong&gt;和&lt;strong&gt;一般接口&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本接口&#34;&gt;基本接口&lt;/h4&gt;
&lt;p&gt;接口定义中如果只有方法，那么这种接口称为 &lt;strong&gt;基本接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyError interface { // 接口中只有方法，所以是基本接口
    Error() string
}

// 用法和 Go1.18之前保持一致
var err MyError = fmt.Errorf(&amp;#34;hello world&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;基本接口因为代表了一个类型集，所以也可以用在类型约束中。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// io.Reader 和 io.Writer 都是基本接口，也可以用在类型约束中
type MySlice[T io.Reader | io.Writer]  []Slice
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;一般接口&#34;&gt;一般接口&lt;/h4&gt;
&lt;p&gt;如果接口内不光有方法，还有类型的话，这种接口被称为&lt;strong&gt;一般接口&lt;/strong&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Uint interface { // 接口 Uint 中有类型，所以是一般接口
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type ReadWriter interface {  // ReadWriter 接口既有方法也有类型，所以是一般接口
    ~string | ~[]rune

    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;一般接口类型不能用来定义变量，只能用于泛型的类型约束中&lt;/strong&gt;：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

var uintInf Uint // 错误。Uint是一般接口，只能用于类型约束，不得用于变量定义
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个限制保证了一般接口的使用被限定在了泛型中，不会影响以前老版本的代码。&lt;/p&gt;
&lt;h4 id=&#34;泛型接口&#34;&gt;泛型接口&lt;/h4&gt;
&lt;p&gt;所有类型的定义都可以使用类型行参，所以接口定义也可以使用类型行参：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type DataProcessor[T any] interface {
    Process(oriData T) (newData T)
    Save(data T) error
}

type DataProcessor2[T any] interface {
    int | ~struct{ Data interface{} }

    Process(data T) (newData T)
    Save(data T) error
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为引入了类型行参，所以这两个接口是泛型类型，&lt;strong&gt;泛型类型要使用必须传入类型实参实例化&lt;/strong&gt;，所以来尝试实例化一下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DataProcessor[string]

// 实例化之后的接口定义相当于如下所示：
type DataProcessor[string] interface {
    Process(oriData string) (newData string)
    Save(data string) error
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实例化之后就好理解了，DataProcessor[string] 因为只有方法，所以它实际上是一个 基本接口 ， 这个接口包含两个能处理string类型的方法，下面这样实现了这两个能处理string类型的方法就算是实现了这个接口：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type CSVProcessor struct {
}

// 注意，方法中 oriData 等的类型是 string
func (c CSVProcessor) Process(oriData string) (newData string) {
    ....
}

func (c CSVProcessor) Save(oriData string) error {
    ...
}

// CSVProcessor实现了接口 DataProcessor[string] ，所以可赋值
var processor DataProcessor[string] = CSVProcessor{}  
processor.Process(&amp;#34;name,age\nbob,12\njack,30&amp;#34;)
processor.Save(&amp;#34;name,age\nbob,13\njack,31&amp;#34;)

// 错误。CSVProcessor没有实现接口 DataProcessor[int]
var processor2 DataProcessor[int] = CSVProcessor{}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用同样的方式实例化 DataProcessor2[T] :&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;DataProcessor2[string]

// 实例化后的接口定义可视为
type DataProcessor2[T string] interface {
    int | ~struct{ Data interface{} }

    Process(data string) (newData string)
    Save(data string) error
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;DataProcessor2[string] 因为带有类型并集所以它是 一般接口(General interface)，所以实例化之后的这个接口代表的意思是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有实现了 Process(string) string 和 Save(string) error 这两个方法，并且以 int 或 struct{ Data interface{} } 为底层类型的类型才算实现了这个接口.&lt;/li&gt;
&lt;li&gt;一般接口(General interface) 不能用于变量定义只能用于类型约束，所以接口 DataProcessor2[string] 只是定义了一个用于类型约束的类型集&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// XMLProcessor 虽然实现了接口 DataProcessor2[string] 的两个方法，但是因为它的底层类型是 []byte，所以依旧是未实现 DataProcessor2[string]
type XMLProcessor []byte
func (c XMLProcessor) Process(oriData string) (newData string) {
}
func (c XMLProcessor) Save(oriData string) error {
}

// JsonProcessor 实现了接口 DataProcessor2[string] 的两个方法，同时底层类型是 struct{ Data interface{} }。所以实现了接口 DataProcessor2[string]
type JsonProcessor struct {
    Data interface{}
}
func (c JsonProcessor) Process(oriData string) (newData string) {
}
func (c JsonProcessor) Save(oriData string) error {
}

// 错误。DataProcessor2[string]是一般接口不能用于创建变量
var processor DataProcessor2[string]

// 正确，实例化之后的 DataProcessor2[string] 可用于泛型的类型约束
type ProcessorList[T DataProcessor2[string]] []T

// 正确，接口可以并入其他接口
type StringProcessor interface {
    DataProcessor2[string]

    PrintString()
}

// 错误，带方法的一般接口不能作为类型并集的成员
type StringProcessor interface {
    DataProcessor2[string] | DataProcessor2[[]byte]

    PrintString()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;接口定义的限制&#34;&gt;接口定义的限制&lt;/h4&gt;
&lt;p&gt;1.用&lt;code&gt;|&lt;/code&gt;连接多个类型的时候，类型之间不能有相交的部分(即必须是不交集):&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyInt int

// 错误，MyInt的底层类型是int,和 ~int 有相交的部分
type _ interface {
    ~int | MyInt
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是相交的类型中是接口的话，则不受这一限制：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyInt int

type _ interface {
    ~int | interface{ MyInt }  // 正确
}

type _ interface {
    interface{ ~int } | MyInt // 也正确
}

type _ interface {
    interface{ ~int } | interface{ MyInt }  // 也正确
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.类型的并集中不能有类型形参&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyInf[T ~int | ~string] interface {
    ~float32 | T  // 错误。T是类型形参
}

type MyInf2[T ~int | ~string] interface {
    T  // 错误
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.接口不能直接或间接地并入自己&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Bad interface {
    Bad // 错误，接口不能直接并入自己
}

type Bad2 interface {
    Bad1
}
type Bad1 interface {
    Bad2 // 错误，接口Bad1通过Bad2间接并入了自己
}

type Bad3 interface {
    ~int | ~string | Bad3 // 错误，通过类型的并集并入了自己
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;4.接口的并集成员个数大于一的时候不能直接或间接并入 &lt;code&gt;comparable&lt;/code&gt; 接口&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type OK interface {
    comparable // 正确。只有一个类型的时候可以使用 comparable
}

type Bad1 interface {
    []int | comparable // 错误，类型并集不能直接并入 comparable 接口
}

type CmpInf interface {
    comparable
}
type Bad2 interface {
    chan int | CmpInf  // 错误，类型并集通过 CmpInf 间接并入了comparable
}
type Bad3 interface {
    chan int | interface{comparable}  // 理所当然，这样也是不行的
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;5.带方法的接口（&lt;strong&gt;无论是基本接口还是一般接口&lt;/strong&gt;），都不能写入接口的并集中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type _ interface {
    ~int | ~string | error // 错误，error是带方法的接口(一般接口) 不能写入并集中
}

type DataProcessor[T any] interface {
    ~string | ~[]byte

    Process(data T) (newData T)
    Save(data T) error
}

// 错误，实例化之后的 DataProcessor[string] 是带方法的一般接口，不能写入类型并集
type _ interface {
    ~int | ~string | DataProcessor[string] 
}

type Bad[T any] interface {
    ~int | ~string | DataProcessor[T]  // 也不行
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;最后&#34;&gt;最后&lt;/h1&gt;
&lt;p&gt;泛型并不取代Go1.18之前用接口+反射实现的动态类型，应用场景：当需要针对不同类型书写同样的逻辑，使用泛型来简化代码是最好的 (比如想写个队列，写个链表、栈、堆之类的数据结构）&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>14.其余的东东</title>
      <link>https://tinklespring.com/posts/14.%E5%85%B6%E4%BD%99%E7%9A%84%E4%B8%9C%E4%B8%9C/</link>
      <pubDate>Tue, 22 Aug 2023 18:47:20 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/14.%E5%85%B6%E4%BD%99%E7%9A%84%E4%B8%9C%E4%B8%9C/</guid>
      <description>&lt;h1 id=&#34;if的初始化语句&#34;&gt;if的初始化语句&lt;/h1&gt;
&lt;p&gt;有个saveString函数，返回一个error值（如没有错误，返回nil），在main函数中，可以在处理它之前将返回值存储在一个err变量中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func saveString(fileName string, str string) error {
	err := ioutil.WriteFile(fileName, []byte(str), 0600)
	return err
}

func main() {
	err := saveString(&amp;#34;hindi.txt&amp;#34;, &amp;#34;Namaste&amp;#34;)  //调用saveString并存储返回值
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在假设main中添加了另一个对saveString的调用，也使用了一个err变量，必须记住，在第一次使用err时使用一个短变量声明，以后更改为使用赋值，否则将得到一个编译错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	err := saveString(&amp;#34;english.txt&amp;#34;, &amp;#34;Hello&amp;#34;)  //使用了名为 err 的变量
	if err != nil {
		log.Fatal(err)
	}
	err := saveString(&amp;#34;hindi.txt&amp;#34;, &amp;#34;Namaste&amp;#34;)  //如果忘记将原始代码从短变量声明转换为赋值，将报错
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实际上，只是在if语句及其块中使用err变量，是否有一种方式可以限制变量的作用域，这样可以将每个事件当作一个单独的变量来处理呢？&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/14-%e5%85%b6%e4%bd%99%e7%9a%84%e4%b8%9c%e4%b8%9c/for%e5%be%aa%e7%8e%af.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;for循环它们可以包含一个初始化语句，可以在这里使用初始化变量，这些变量只在for循环块的作用域内。&lt;/p&gt;
&lt;p&gt;与for循环类似，Go允许在if语句中的条件之前添加初始化语句，初始化语句通常用于初始化一个或多个变量，以便在if块中使用。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/14-%e5%85%b6%e4%bd%99%e7%9a%84%e4%b8%9c%e4%b8%9c/if%e5%be%aa%e7%8e%af.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if count := 5, count &amp;gt; 4 {
	fmt.Println(&amp;#34;count is&amp;#34;, count)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;初始化语句中声明的变量的作用域仅限于if语句的条件表达式及其块。每个err变量被限制在if语句的条件和块中，将有两个独立的err变量，不用担心报错。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if err := saveString(&amp;#34;english.txt&amp;#34;, &amp;#34;Hello&amp;#34;); err != nil {  //第一个err变量的作用域
	log.Fatal(err)
}
if err := saveString(&amp;#34;hindi.txt&amp;#34;, &amp;#34;Namaste&amp;#34;); err != nil {  //第二个err变量的作用域
	log.Fatal(err)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这种对作用域的限制是双向的，如果一个函数有多个返回值，需要其中一个在if语句中，另一个在if语句外，那么可能无法在if初始化语句中调用它，会发现需要的在if块之外的值超出了作用域。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if number, err := strconv.ParseFloat(&amp;#34;3.14&amp;#34;, 64); err != nil {
	log.Fatal(err)
}
fmt.Println(number * 2) //超出了作用域
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相反，需要像往常一样在if语句前调用函数，这样它的返回值就在if语句的内部和外部的作用域之内：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;number, err := strconv.ParseFloat(&amp;#34;3.14&amp;#34;, 64)  //在if语句前声明变量
if err != nil {  //仍在作用域内
	log.Fatal(err)
}
fmt.Println(number * 2)  //number 仍在作用域内
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;switch语句&#34;&gt;switch语句&lt;/h1&gt;
&lt;p&gt;当需要根据表达式的值执行几个操作之一时，可能会导致if语句和else子句的混乱，&lt;code&gt;switch&lt;/code&gt;语句是表达这些选择的更有效的方式。&lt;/p&gt;
&lt;p&gt;switch关键字，然后是条件表达式，再添加几个case表达式，每个case表达式都有一个条件表达式可能有的值，选择其值与条件表达式匹配的第一个case，并运行其所包含的代码，其他case表达式被忽略，还可以提供一个default语句，如果没有匹配的case，将运行该语句。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;math/rand&amp;#34;
	&amp;#34;time&amp;#34;
)

func awardPrize() {
	switch rand.Intn(3) + 1 { //条件表达式
	case 1: //如果结果是1
		fmt.Println(&amp;#34;you win a cruise!&amp;#34;) //打印这条消息
	case 2:
		fmt.Println(&amp;#34;you win a car!&amp;#34;)
	case 3:
		fmt.Println(&amp;#34;you win a goat!&amp;#34;)
	default: //如果结果不是以上任何一个
		panic(&amp;#34;invalid door number&amp;#34;) //那么产生panic
	}
}

func main() {
	rand.Seed(time.Now().Unix())
	awardPrize()
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;问：其他语言，在每个case的末尾有个 break 语句，否则也会运行下一个case，Go不需要这样？&lt;br&gt;
答：Go会在case代码末尾自动退出switch，如果希望下一个case代码也能运行，那么可以在一个case中使用&lt;code&gt;fallthrough&lt;/code&gt;关键字。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt; &lt;code&gt;case&lt;/code&gt; &lt;code&gt;default&lt;/code&gt; &lt;code&gt;fallthrough&lt;/code&gt; 这四个是结合使用的，表达式或类型说明符与switch中的case相比较从而决定执行哪一个。如果存在一个且最多只能存在一个 default 默认分支，所有的 case 分支都不满足时将执行 default 分支，且 default 分支不一定要放在最后的位置。Go switch 语句在执行完某个 case 子句后，不会再顺序地执行后面的 case 子句，而是结束当前 switch 语句。&lt;/p&gt;
&lt;p&gt;使用 fallthrough 可以继续执行下一个 case 或 default 子句。case 表达式可以提供多个待匹配的值，使用逗号分隔。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch {		// 缺失的表达式为 true
case x &amp;lt; y: f1()
fallthrough		// 强制执行下一个 case 子句
case x &amp;lt; z: f2()
// 此处没有 fallthrough，switch 执行流在此终止	
case x == 4: f3()
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch tag {
default: s3()		// default 子句可以出现在任意位置，不一定是最后一个
case 0, 1, 2, 3: s1()	// case 表达式可以提供多个待匹配的值，使用逗号分隔
case 4, 5, 6, 7: s2()
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch x := f() {	// 缺省表达式试为 true 且前面存在一条短变量申明语句
case x &amp;lt; 0: return -x	// case 表达式无需为常量
default: return x
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;表达式选择可以没有表达式，缺省为true，这种写法也习惯的取代 if-else-if-else 语句链，表达式可以不是常量，表达式前面可以有简单语句，比如短变量声明语句。&lt;/p&gt;
&lt;p&gt;类型选择：&lt;br&gt;
类型选择比较类型而不是值，类似于表达式选择，由一个特殊的表达式表示类型，该表达式的形式是使用&lt;code&gt;type&lt;/code&gt;的类型断言而不是实际类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch x.(type) {
	// case
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用实际类型T与表达式x的动态类型进行匹配，与类型断言一样，x必须是接口类型，列出的每个非接口类型T必须实现x且不能相同。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch i := x.(type) {
case int:
	printInt(i)                            // i 类型为 int
case float64:
	printFloat64(i)                        // i 类型为 float64
case func(int) float64:
	printFunction(i)                       // i 类型为 func(int) float64
case bool, string:
	printString(&amp;#34;type is bool or string&amp;#34;)  // i 类型为 bool or string
default:
	printString(&amp;#34;don&amp;#39;t know the type&amp;#34;)     // i 类型未知
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;更多基本类型&#34;&gt;更多基本类型&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;br&gt;int16&lt;br&gt;int32&lt;br&gt;int64&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;这些保存整数，与int一样，但是它们在内存中是特定的大小（类型名称中的数字以位为单位指定大小）。更少的位消耗更少的内存或其他存储，更多的位意味着可以存储更多的数字，应该使用int，除非有特定的理由使用其他的。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;像int一样，但它只包含无符号整数，不能包含负数。这意味着可以在相同的内存中放入更大的数字，只要确定这些值永远不会为负。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;uint8&lt;br&gt;uint16&lt;br&gt;uint32&lt;br&gt;uint64&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;它们包含无符号整数，与int一样，它们在内存中消耗特定数量的位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;float32&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;float64类型保存浮点数并消耗64位内存，这是它较小的32位的表兄弟（浮点数没有8位或16位的变量）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;更多关于符文&#34;&gt;更多关于符文&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;rune&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;现代操作系统出现前，大多数计算都使用不带重音的英文字母来完成，共有26个字母（大小写），数量太少，一个字符可以用一个字节表示（还有1位可用），使用一种称为&lt;code&gt;ASCII&lt;/code&gt;的标准来确保在不同的系统上将相同的字节值转换为相同的字母。&lt;/p&gt;
&lt;p&gt;英文字母并不是唯一的书写系统；Unicode标准试图创建一组4字节的值，这些值可以表示这些不同书写系统中的每个字符（以及许多其他字符）。&lt;/p&gt;
&lt;p&gt;Go使用&lt;code&gt;rune&lt;/code&gt;类型的值来表示Unicode值，通常，一个符文代表一个字符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rune&lt;/code&gt;是&lt;code&gt;int32&lt;/code&gt;的类型别名，用于表示一个Unicode码点。&lt;/p&gt;
&lt;p&gt;Go使用 UTF-8 ，这是一种表示Unicode字符的标准，每个字符使用1到4个字节，旧ASCII字符集中的字符仍然可以用一个字节表示，其他字符可能需要2到4个字节。&lt;/p&gt;
&lt;p&gt;通常，无需担心字符如何存储的细节，也就是说，直到尝试将字符串转换为其组件字节并返回，例如，用两个字符串调用len函数，会得到不同结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;asciiString := &amp;#34;ABCDE&amp;#34;
utf8String := &amp;#34;БГДЖИ&amp;#34;
fmt.Println(len(asciiString))
fmt.Println(len(utf8String))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;5  //这个字符占用5个字节
10  //占用10个字节
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当将字符串传递给len函数时，将返回以字节（而不是符文）为单位的长度，英文字母可以占用5个字节&amp;ndash;每个符文只需1个字节，应为它来自旧的ASCII字符集，但是俄文需要10个字节&amp;ndash;每个符文需要2个字节存储。&lt;/p&gt;
&lt;p&gt;若需要字符串的字符长度，应该使用 unicode/utf8 包的 RuneCountInString 函数，此函数将返回正确的字符数，而不用考虑用于存储每个字符的字节数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(utf8.RuneCountInString(asciiString))
fmt.Println(utf8.RuneCountInString(utf8String))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;5   //这个字符串有5个符文
5  //这个字符串也有5个符文
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;安全地使用部分字符串意味着将字符串转换为符文，而不是字节。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Go支持将字符串转换为rune值的切片，并将符文切片转换回字符串，要使用部分字符串，应该将它们转换为rune值的切片，而不是byte值的切片，这样就不会意外抓取符文的部分字节。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;asciiRunes := []rune(asciiString)  //将字符串转换为符文切片
utf8Runes := []rune(utf8String)  //将字符串转换为符文切片
asciiRunesPartial := asciiRunes[3:]  //省略每个切片中的前3个符文
utf8RunesPartial := utf8Runes[3:]  //省略每个切片中的前3个符文
fmt.Println(string(asciiRunesPartial))
fmt.Println(string(utf8RunesPartial))  //将这个符文切片转换成字符串
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go允许对字符串使用for&amp;hellip;range循环，一次处理一个符文，而不是一个字节，这是一种更安全的方式。提供的第一个变量将被分配给字符串中的当前字节索引（而不是rune索引），第二个变量将被分配给当前的符文。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;s := &amp;#34;Hello, 世界&amp;#34;
for _, r := range s {
	fmt.Println(&amp;#34;%c &amp;#34;, r)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go的符文可以很容易处理部分字符串，而不必担心它们是否包含Unicode字符。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;任何时候想要处理字符串的一部分，就把它转换成符文，而不是字节！&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;有缓冲的channel&#34;&gt;有缓冲的channel&lt;/h1&gt;
&lt;p&gt;Go有两种channel：有缓冲的和无缓冲的。&lt;/p&gt;
&lt;p&gt;当goroutine在无缓冲的channel上发送值时，会立即阻塞，直到另一个goroutine接收到该值。&lt;/p&gt;
&lt;p&gt;有缓冲的channel可以在导致发送的goroutine阻塞之前保存一定数量的值。&lt;/p&gt;
&lt;p&gt;在创建channel时，可以通过给make传递第二个参数来创建有缓冲的channel，该参数包含channel应该能够在其缓冲区中保存的值的数量。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/14-%e5%85%b6%e4%bd%99%e7%9a%84%e4%b8%9c%e4%b8%9c/%e5%88%9b%e5%bb%ba%e7%bc%93%e5%86%b2channel.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;channel := make(chan string, 3)  //“3”此参数指定channel缓冲区的大小
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当goroutine通过channel发送一个值时，该值被添加到缓冲区中，发送的goroutine将继续运行，而不被阻塞。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;channel &amp;lt;- &amp;#34;a&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/14-%e5%85%b6%e4%bd%99%e7%9a%84%e4%b8%9c%e4%b8%9c/%e7%bc%93%e5%86%b2%e7%9a%84channel.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;发送的goroutine可以继续在channel上发送值，直到缓冲区被填满，只有这时，额外的发送操作才会导致goroutine阻塞。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;channel &amp;lt;- &amp;#34;b&amp;#34;
channel &amp;lt;- &amp;#34;c&amp;#34;
channel &amp;lt;- &amp;#34;d&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/14-%e5%85%b6%e4%bd%99%e7%9a%84%e4%b8%9c%e4%b8%9c/%e7%bc%93%e5%86%b2%e5%a1%ab%e6%bb%a1.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;当另一个goroutine从channel接收一个值时，它从缓冲区提取最早添加的值。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/14-%e5%85%b6%e4%bd%99%e7%9a%84%e4%b8%9c%e4%b8%9c/%e6%8f%90%e5%8f%96%e5%80%bc.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;额外的接收操作将继续清空缓冲区，而额外的发送操作将填充缓冲区。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/14-%e5%85%b6%e4%bd%99%e7%9a%84%e4%b8%9c%e4%b8%9c/%e6%8f%90%e5%8f%96%e5%92%8c%e5%a1%ab%e5%85%85.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;例：&lt;br&gt;
用一个无缓冲的channel运行一个程序，然后更新为带缓冲的channel，比较区别。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;time&amp;#34;
)

func sendLetters(channel chan string) {
	time.Sleep(1 * time.Second) //发送4个值，每个值前休眠1秒
	channel &amp;lt;- &amp;#34;a&amp;#34;
	time.Sleep(1 * time.Second)
	channel &amp;lt;- &amp;#34;b&amp;#34;
	time.Sleep(1 * time.Second)
	channel &amp;lt;- &amp;#34;c&amp;#34;
	time.Sleep(1 * time.Second)
	channel &amp;lt;- &amp;#34;d&amp;#34;
}

func main() {
	fmt.Println(time.Now())            //打印程序开始的时间
	channel := make(chan string)       //创建一个无缓冲的channel
	go sendLetters(channel)            //在新的goroutine上启动sendLetters
	time.Sleep(5 * time.Second)        //主goroutine休眠5秒
	fmt.Println(&amp;lt;-channel, time.Now()) //接收并打印4个值以及当前的时间
	fmt.Println(&amp;lt;-channel, time.Now())
	fmt.Println(&amp;lt;-channel, time.Now())
	fmt.Println(&amp;lt;-channel, time.Now())
	fmt.Println(time.Now()) //打印程序结束的时间
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023-08-23 15:12:28.402341 +0800 CST m=+0.000126414
a 2023-08-23 15:12:33.403655 +0800 CST m=+5.001530631  //当主goroutine醒来时，第一个值已经在等待接收
b 2023-08-23 15:12:34.404896 +0800 CST m=+6.002790206  //但sendLetters goroutine在收到第一个值前一直被阻塞，所以必须等待后面的值发送出去
c 2023-08-23 15:12:35.405858 +0800 CST m=+7.003769905
d 2023-08-23 15:12:36.406175 +0800 CST m=+8.004105594
2023-08-23 15:12:36.406232 +0800 CST m=+8.004162602  //程序运行花费8s
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当main goroutine醒来时，从channel接收4个值，但sendLetters goroutine被阻塞了，等待main接收第一个值，因此，当sendLetters goroutine恢复时，main goroutine必须在每个剩余值之间等待1秒。&lt;/p&gt;
&lt;p&gt;更新为带缓冲的channel：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	channel := make(chan string, 1)  //创建一个有缓冲的channel，在阻塞前可以保存一个值
	// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当sendLetter将它的第一个值发送到channel时，不会阻塞，直到主goroutine接收到它，所发送的值将进入channel的缓冲区，只有当第二个值被发送（但还没有任何值被接收）时，channel的缓冲区才会被填满，sendLetters goroutine才会被阻塞，向channel中添加一个单值缓冲区可减少1秒的时间。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	channel := make(chan string, 3)  //创建一个有缓冲的channel，在阻塞前可以保存三个值
	// ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将缓冲区大小增加到3，这允许sendLetters在不阻塞的情况下发送三个值，在最后一次发送时阻塞，但这是在它的所有1秒Sleep调用完成之后，因此，当主goroutine在5秒后醒来时，它立即接收到在有缓冲channel中等待的三个值，以及导致sendLetters阻塞的值。这让程序只需5秒完成。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>13.goroutine和channel</title>
      <link>https://tinklespring.com/posts/13.goroutine%E5%92%8Cchannel/</link>
      <pubDate>Sat, 19 Aug 2023 16:25:28 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/13.goroutine%E5%92%8Cchannel/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;一次只做一件事并不总是完成任务最快的方法。goroutine可以让程序同时处理几个不同的任务，goroutine可以使用channel来协调它们的工作，channel允许goroutine互相发送数据并同步，这样一个goroutine就不会领先与另一个goroutine。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;检索网页&#34;&gt;检索网页&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;io/ioutil&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;net/http&amp;#34;
)

func main() {
	responseSize(&amp;#34;https://example.com/&amp;#34;)
	responseSize(&amp;#34;https://golang.org/&amp;#34;)
	responseSize(&amp;#34;https://golang.org/doc&amp;#34;)
}

func responseSize(url string) { //将url作为参数，将获取页面的代码移动到单独的函数
	fmt.Println(&amp;#34;Getting&amp;#34;, url)    //打印正在检索的url
	response, err := http.Get(url) //获取给定的url
	if err != nil {
		log.Fatal(err)
	}
	defer response.Body.Close()
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(len(body)) //字符切片的大小与页面的大小相同

}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;多任务&#34;&gt;多任务&lt;/h1&gt;
&lt;p&gt;通过同时执行多个任务来找到加快程序运行速度的方式。&lt;/p&gt;
&lt;p&gt;程序对responseSize进行几次调用，每次一个，对responseSize的每次调用都建立到网站的网络连接，等待网站响应，打印响应大小并返回，只有一个调用响应返回时，下一个调用才能开始。&lt;/p&gt;
&lt;p&gt;如果有一种方式能同时运行所有三个responseSize调用，这个程序只需三分之一的时间即可完成。&lt;/p&gt;
&lt;h1 id=&#34;使用goroutine的并发性&#34;&gt;使用goroutine的并发性&lt;/h1&gt;
&lt;p&gt;当responseSize调用http.Get时，程序必须在等待网站的响应，只能干等没有别的事情做。&lt;/p&gt;
&lt;p&gt;另一个程序可能需要等待用户输入，再另一个可能需要等待数据从文件中读取，很多情况下，程序只能等待。&lt;/p&gt;
&lt;p&gt;并发性允许程序暂停一个任务并处理其他任务：等待用户输入的程序可能在后台执行其他处理，读取文件时更新进度条，responseSize程序可能在等待第一个请求完成时发出其他网络请求。&lt;/p&gt;
&lt;p&gt;并行：同时运行任务，一台只有一个处理器的计算机一次只能运行一个任务，但现代计算机都有多个处理器，计算机可能在不同的处理器之间分配并发任务，以便于同时运行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goroutine允许并发：暂停一个任务来处理其他任务；在某些情况下，它们允许并行：同时处理多个任务！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在Go中，并发称为 &lt;code&gt;goroutine&lt;/code&gt; ，其他语言有类似的概念，叫做线程，但是 goroutine 比线程需要更少的计算机内存，启动和停止时间更少，这意味着可以同时运行更多的goroutine。&lt;/p&gt;
&lt;p&gt;启动一个goroutine，可以使用&lt;code&gt;go&lt;/code&gt;语句，只是一个普通的函数或方法调用，前面有go关键字：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go myFunction()  //go关键字+函数调用
go otherFunction(&amp;#34;arguments&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;注意&lt;/font&gt;，我们说的是另一个goroutine，每个Go程序的main函数都是使用goroutine启动，因此每个Go程序至少运行一个goroutine。&lt;/p&gt;
&lt;h1 id=&#34;使用goroutine&#34;&gt;使用goroutine&lt;/h1&gt;
&lt;p&gt;这里有个程序，一次调用一个函数，a函数使用循环打印字符串 a 50次，b函数打印字符串 b 50次，main函数调用a，然后调用b，最后在退出时打印一条消息。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func a() {
	for i := 0, i &amp;lt; 50; i++ {
		fmt.Print(&amp;#34;a&amp;#34;)
	}
}

func b() {
	for i := 0, i &amp;lt; 50; i++ {
		fmt.Print(&amp;#34;b&amp;#34;)
	}
}

func main() {
	a()
	b()
	fmt.Println(&amp;#34;end main()&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;就像main函数包含了a函数所有代码，然后是b函数所有代码，最后是自己的代码。要在新的goroutine中启动a和b函数，只需在函数调用前添加go关键字，这能让新的goroutine与main函数同时运行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	go a()
	go b()
	fmt.Println(&amp;#34;end main()&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是运行这个程序，将只能看到来自main函数末尾的Println调用的输出，不会看到来自a或b函数的任何内容。&lt;/p&gt;
&lt;p&gt;Go程序在main goroutine（调用main函数的goroutine）结束后立即停止运行，即使其他goroutine仍在运行，main函数在a和b函数中的代码运行之前就完成了。&lt;/p&gt;
&lt;p&gt;需要保持main goroutine运行，知道aheb函数goroutine完成，需要暂停main goroutine一段时间，这样其他goroutine就可以运行。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	go a()
	go b()
	time.Sleep(time.Second)  //暂停main goroutine1秒
	fmt.Println(&amp;#34;end main()&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当程序在两个goroutine之间切换时，两个输出将混合在一起，当main goroutine唤醒时，会调用fmt.Println并退出。&lt;/p&gt;
&lt;h1 id=&#34;不能直接控制goroutine何时运行&#34;&gt;不能直接控制goroutine何时运行&lt;/h1&gt;
&lt;p&gt;每次运行程序时，可能会看到 goroutine 以不同的顺序运行，也无法知道上一个程序何时会在两个goroutine之间切换。&lt;/p&gt;
&lt;p&gt;正常情况下，Go不能保证何时在goroutine之间切换，或者切换多长时间，这允许goroutine以最有效的方式运行，若需要运行顺序，那么需要使用channel来同步它们。&lt;/p&gt;
&lt;h1 id=&#34;go语句不能使用返回值&#34;&gt;go语句不能使用返回值&lt;/h1&gt;
&lt;p&gt;切换到goroutine带来了另一个需要解决的问题：不能在go语句中使用函数返回值。假设想要改变responseSize来返回页面大小，而不是直接打印它：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	var size int
	size = go responseSize(&amp;#34;https://example.com/&amp;#34;)  //此段代码无效
	fmt.Println(size)  //此段代码无效
	size = go responseSize(&amp;#34;https://golang.org/&amp;#34;)  //此段代码无效
	fmt.Println(size)  //此段代码无效
	size = go responseSize(&amp;#34;https://golang.org/doc/&amp;#34;)  //此段代码无效
	fmt.Println(size)  //此段代码无效
	time.Sleep(5 * time.Second)
}

func responseSize(url string) int {  //添加返回值
	fmt.Println(&amp;#34;Getting&amp;#34;, url)
	response, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer response.Body.Close()
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Fatal(err)
	}
	return len(body)  //返回响应大小，而不是打印它

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会编译错误，编译器阻止尝试从使用go语句调用的函数中获取返回值。这实际上是好事，当将responseSize作为go语句的一部分调用时，会说“在单独的goroutine中运行responseSize，将一直运行此函数中的指令。” responseSize函数不会立即返回值，必须等待网页响应，但是 main goroutine 中的代码会立即期望一个返回值，但目前还没有返回值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;size = go responseSize(&amp;#34;https://example.com/&amp;#34;)  //去运行这个，不会再等了
fmt.Println(size)  //那么返回什么呢
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在go语句中调用的任何函数都是这样，而不仅仅是像responseSize这样的长时间运行函数，不能指望返回值会及时准备好，因此Go编译器会阻止任何使用它们的尝试。&lt;/p&gt;
&lt;p&gt;Go不允许使用go语句调用的函数的返回值，因为在尝试使用它之前，不能保证返回值已经准备好。&lt;/p&gt;
&lt;h3 id=&#34;channel&#34;&gt;channel&lt;/h3&gt;
&lt;p&gt;但是goroutine之间有一种交流方式：&lt;code&gt;channel&lt;/code&gt;，channel不仅允许将值从一个goroutine发送到另一个goroutine，还确保在接收的goroutine尝试使用该值之前，发送的goroutine已经发送了该值。&lt;/p&gt;
&lt;p&gt;使用channel的唯一方法是从一个goroutine到另一个goroutine的通信。&lt;/p&gt;
&lt;p&gt;为了演示channel，需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建一个channel&lt;/li&gt;
&lt;li&gt;编写一个函数，该函数接收一个channel作为参数，我们将在一个单独的goroutine中运行这个函数，并使用它通过channel发送值。&lt;/li&gt;
&lt;li&gt;在初始的goroutine中接收发送的值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个channel只携带特定类型的值，因此可能有一个channle用于int值，另一个channel用于struct类型的值，要声明包含channel的变量，可以使用&lt;code&gt;chan&lt;/code&gt;关键字，然后是channel将携带的值的类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myChannel chan float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要实际创建channel，需要调用内置 &lt;code&gt;make&lt;/code&gt; 函数（与创建映射和切片的函数相同）。传递make要创建的channel的类型（应该与要赋值给它的变量的类型相同）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myChannel chan float64  //声明一个变量来保存channel
myChannel =  make(chan float64)  //实际创建channel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不是单独声明channel变量，在大多数情况下，使用一个短变量声明更容易：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;myChannel := make(chan float64)  //创建一个channel并立即声明一个变量
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用channel发送和接收值&#34;&gt;使用channel发送和接收值&lt;/h1&gt;
&lt;p&gt;要在channel上发送值，使用&lt;code&gt;&amp;lt;-&lt;/code&gt;运算符，从发送的值指向发送该值的channel。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;myChannel &amp;lt;- 3.14   //向名为 &amp;#34;myChannel&amp;#34; 的channel发送一个值&amp;#34;3.14&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;还可以使用 &amp;lt;- 接收来自channel的值，但是位置不同：将箭头放在接收channel的左侧，看起来像从channel中取出一个值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;-myChannel
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例：&lt;br&gt;
向greeting添加一个myChannel参数，接受一个包含字符串值的channel，greeting现在不是返回一个字符串值，而是通过myChannel发送一个字符串。&lt;/p&gt;
&lt;p&gt;在main函数中，使用内置的make函数创建要传递给greeting的channel，然后调用greeting来作为一个新的goroutine，使用单独的goroutine很重要，因为channel应该只用于goroutine之间的通信。然后从传递给greeting的channel中接收一个值，并打印返回字符串。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func greeting(myChannel chan string) { //将channel作为参数
	myChannel &amp;lt;- &amp;#34;hi&amp;#34;  //通过channel发送给一个值
}

func main() {
	myChannel := make(chan string)  //创建一个新的channel
	go greeting(myChannel)  //将channel传递给在新goroutine中运行的函数
	fmt.Println(&amp;lt;-myChannel)  //从channel接收值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不必将从channel接收的值直接传递给Println，可以在任何需要值的上下文中从channel接收（在任何可以使用变量或函数的返回值的地方）。比如可以先将接收到的值赋给一个变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;receiveValue := &amp;lt;-myChannel  //也可以将接收的值存储在一个变量中
fmt.Println(receiveValue)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;同步goroutine与channel&#34;&gt;同步goroutine与channel&lt;/h1&gt;
&lt;p&gt;channel确保发送的goroutine在接收channel尝试使用该值前已经发送了该值，channel通过&lt;code&gt;blocking&lt;/code&gt;(阻塞)&amp;mdash;暂停当前goroutine中的所有进一步操作来实现。发送操作阻塞发送goroutine，直到另一个goroutine在同一cahnnel上执行了接收操作，反之亦然，接收操作阻塞接收goroutine，直到另一个goroutine在同一channel上执行了发送操作，这个行为允许goroutine同步它们的动作，协调它们的时间。&lt;/p&gt;
&lt;p&gt;例：&lt;br&gt;
创建两个channel并将它们传递给两个新goroutine中的函数，然后main goroutine从这些channel接收值并打印它们。与goroutine反复打印“a”或“b”的程序不同，可以预测这个程序的输出：总是按顺序打印“a”，然后打印“d” “b” “e” “c” “f”。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func abc(channel chan string) {
	channel &amp;lt;- &amp;#34;a&amp;#34;
	channel &amp;lt;- &amp;#34;b&amp;#34;
	channel &amp;lt;- &amp;#34;c&amp;#34;
}

func def(channel chan string) {
	channel &amp;lt;- &amp;#34;d&amp;#34;
	channel &amp;lt;- &amp;#34;e&amp;#34;
	channel &amp;lt;- &amp;#34;f&amp;#34;
}

func main() {
	channel1 := make(chan string)  //创建channel
	channel2 := make(chan string)  //创建channel
	go abc(channel1)  //将channel传递给新goroutine中运行的函数
	go def(channel2)  //将channel传递给新goroutine中运行的函数
	fmt.Print(&amp;lt;-channel1)  //从channel接收和打印值
	fmt.Print(&amp;lt;-channel2)
	fmt.Print(&amp;lt;-channel1)
	fmt.Print(&amp;lt;-channel2)
	fmt.Print(&amp;lt;-channel1)
	fmt.Print(&amp;lt;-channel2)
	fmt.Println()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;adbecf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;abc goroutine每次向channel发送一个值时都会阻塞，直到main goroutine接收到它为止，def goroutine也是如此。main goroutine称为abc goroutine和def goroutine的协调器，只有当它准备读取它们发送的值时，才允许它们继续。&lt;/p&gt;
&lt;p&gt;abc 和 def 函数都在单独的goroutine并发启动，abc 函数尝试将 “a” 发送到 channel1，由于channel1是无缓冲的，abc 会阻塞，直到main goroutine 从该通道上接收数据。main goroutine 使用 fmt.Print(&amp;lt;-channel1) 接收并打印“a”，此时 abc 函数中的阻塞解除，它会尝试将“b”发送到channel1，但同样会阻塞，因为需要一个接收操作。def 函数与 abc 函数类似，它尝试将“d”发送到 channel2，并在main goroutine接收并打印“d”之后继续执行，以此类推，main goroutine会交替从两个通道接收并打印数据，这就是为什么顺序是 “adbecf”。&lt;/p&gt;
&lt;h1 id=&#34;观察goroutine同步&#34;&gt;观察goroutine同步&lt;/h1&gt;
&lt;p&gt;abc goroutine 和 def goroutine 通过它们的channel发送它们的值的速度很快，所以看不到发生了什么，下边这个程序可以减慢速度，方便观察阻塞：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;time&amp;#34;
)

func reportNap(name string, delay int) { //休眠goroutine名字、时间
	for i := 0; i &amp;lt; delay; i++ {
		fmt.Println(name, &amp;#34;sleeping&amp;#34;)
		time.Sleep(1 * time.Second)
	}
	fmt.Println(name, &amp;#34;wakes up!&amp;#34;)
}

func send(myChannel chan string) {
	reportNap(&amp;#34;sending goroutine&amp;#34;, 2)
	fmt.Println(&amp;#34;***sending value***&amp;#34;)
	myChannel &amp;lt;- &amp;#34;a&amp;#34; //在main 仍处于休眠状态时阻塞此发送
	fmt.Println(&amp;#34;***sending value***&amp;#34;)
	myChannel &amp;lt;- &amp;#34;b&amp;#34;
}

func main() {
	myChannel := make(chan string)
	go send(myChannel)
	reportNap(&amp;#34;receiving goroutine&amp;#34;, 5)
	fmt.Println(&amp;lt;-myChannel)
	fmt.Println(&amp;lt;-myChannel)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从reportNap函数开始，该函数当前goroutine休眠指定的秒数，goroutine休眠时，每一秒会打印一个通知，说它在休眠。&lt;/p&gt;
&lt;p&gt;添加一个send函数，将在goroutine中运行，并将两个值发送到一个channel，在发送任何东西之前，首先调用reportNap，这样它的goroutine会休眠2秒。&lt;/p&gt;
&lt;p&gt;在main goroutine中，创建一个channel并将其传递给send，然后再次调用reportNap，使此goroutine休眠5秒（比send goroutine长3秒），最后在channel上执行两个接收操作。&lt;/p&gt;
&lt;p&gt;当运行这个程序时，会看到两个goroutine在前2秒都处于休眠状态，然后send goroutine醒来并发送它的值，但它没有做任何进一步的事情，发送操作阻塞了send goroutine，直到main goroutine接收到该值。&lt;/p&gt;
&lt;p&gt;这不会马上发生，因为main goroutine仍然需要再休眠3秒，当它醒来时，从channel接收值，此时，send goroutine才能解除阻塞，才能发送第二个值。&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;receiving goroutine sleeping  //发送和接收goroutine都休眠了
sending goroutine sleeping  //发送和接收goroutine都休眠了
receiving goroutine sleeping  //发送和接收goroutine都休眠了
sending goroutine sleeping  //发送和接收goroutine都休眠了
sending goroutine wakes up!  //发送goroutine醒来，并发送一个值
***sending value***  //发送goroutine醒来，并发送一个值
receiving goroutine sleeping  //接收goroutine还在休眠
receiving goroutine sleeping  //接收goroutine还在休眠
receiving goroutine sleeping
receiving goroutine wakes up!  //接收goroutine醒来，并接收一个值
a  //接收goroutine醒来，并接收一个值
***sending value***  //此时，发送goroutine才能解除阻塞，然后发送第二个值
b
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;下面是之前的演示代码，进行如下的更改：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func greeting(myChannel chan string) {
	myChannel &amp;lt;- &amp;#34;hi&amp;#34;
}
func main() {
	myChannel := make(chan string)
	go greeting(myChannel)
	fmt.Println(&amp;lt;-myChannel)
}
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;如果这样&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;会失败，因为&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;myChannel &amp;lt;- &amp;ldquo;hi from main&amp;rdquo;&lt;pre&gt;从main函数中发送一个值到channel&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;会得到一个“all goroutine are sleep-deadlock!”的错误，因为main goroutine阻塞了，还在等待另一个goroutine从channel接收，但是另一个goroutine没有做任何接收操作，所以main goroutine保持阻塞状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;&lt;del&gt;go&lt;/del&gt; greetine(myChannel)&lt;pre&gt;在调用greeting之前删除go关键字&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;这将导致greeting函数在main goroutine中运行，也会因为死锁错误而失败，原因与上面一样：greeting中的发送操作导致main goroutine阻塞，但是没有其他goroutine执行接收操作，所以会保持阻塞状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;&lt;del&gt;myChannel &amp;lt;- &amp;ldquo;hi&amp;rdquo;&lt;/del&gt;&lt;pre&gt;删除向channel发送值的行&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;这也会导致死锁，原因是main goroutine试图接收一个值，但现在没有任何东西可以发送值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;&lt;del&gt;fmt.Println(&amp;lt;-myChannel)&lt;/del&gt;&lt;pre&gt;删除从channel接收值的行&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;greeting中的发送操作会导致goroutine阻塞，但是由于没有接收操作使main goroutine阻塞，所以main立即完成，程序结束时不产生任何输出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;使用channel修复程序&#34;&gt;使用channel修复程序&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import ( //不使用time.Sleep，删除time包
	&amp;#34;fmt&amp;#34;
	&amp;#34;io/ioutil&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;net/http&amp;#34;
)

func responseSize(url string, channel chan int) { //将向responseSize传递一个channel，以便发送页面大小
	fmt.Println(&amp;#34;Getting&amp;#34;, url)
	response, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer response.Body.Close()
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Fatal()
	}
	channel &amp;lt;- len(body) //不返回页面大小，通过channel发送
}

func main() {
	sizes := make(chan int)                        //创建一个int值channel
	go responseSize(&amp;#34;https://example.com/&amp;#34;, sizes) //每次调用responseSize时都将channel传递过去
	go responseSize(&amp;#34;https://golang.org/&amp;#34;, sizes)
	go responseSize(&amp;#34;https://golang.org/doc&amp;#34;, sizes)
	fmt.Println(&amp;lt;-sizes) //channel上将有三个发送，所以要做三个接收
	fmt.Println(&amp;lt;-sizes)
	fmt.Println(&amp;lt;-sizes)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在main函数中，调用make创建int值的channel，更新对responseSize的每个调用，来添加channel作为参数，最后，在channel上执行三个接收操作，每个对应一个responseSize发送的值。&lt;/p&gt;
&lt;p&gt;运行这个程序，会看到程序的完成速度与网站响应速度一样快。&lt;/p&gt;
&lt;p&gt;接下来继续优化，为使代码更干净，可以将要检索的url列表存储在一个切片中，然后使用循环来调用responseSize，并从channel接收值。&lt;/p&gt;
&lt;p&gt;responseSize无需改变，只需更改main函数，用想要的url创建一个字符串切片，然后对切片进行循环，并使用当前url和channel来调用responseSize，最后执行第二个单独的循环，对切片中的每个url运行一次，并从channel接收和打印一个值。（在单独的循环中做很重要，若在启动responseSize goroutine的同一个循环中接收值，将导致main goroutine阻塞，直到接收完成，将返回一次一个页面的请求。）&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	sizes := make(chan int)
	urls := []string{ //将url移动到一个切片中
		&amp;#34;https://example.com/&amp;#34;,
		&amp;#34;https://golang.org/&amp;#34;,
		&amp;#34;https://golang.org/doc&amp;#34;,
	}
	for _, url := range urls {
		go responseSize(url, sizes) //对每个url调用responseSize
	}
	for i := 0; i &amp;lt; len(urls); i++ { //对每一个responseSize发送，都从channel接收一次
		fmt.Println(&amp;lt;-sizes)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;更新channel以携带一个struct&#34;&gt;更新channel以携带一个struct&lt;/h1&gt;
&lt;p&gt;ressponseSize函数还有一个问题，我们不知道输出的顺序，因为没有把页面url与响应大小放在一起，所以不知道它们之间的关系。&lt;/p&gt;
&lt;p&gt;channel可以像携带基础类型一样携带切片、映射和struct等复合类型，我们可以创建一个struct类型，它将存储一个页面url及其大小，这样就可以通过channel将两者一起发送了。&lt;/p&gt;
&lt;p&gt;将使用底层的struct类型声明一个新的Page类型，Page将有一个URL字段来记录页面的URL，以及一个Size字段来记录页面大小。&lt;/p&gt;
&lt;p&gt;将更新responseSize上的channel参数以保存新的Page类型，而不仅仅是int页面大小，让responseSize使用当前URL和页面大小创建一个新的Page值，并将其发送到channel。&lt;/p&gt;
&lt;p&gt;在main中，将更新channel在调用中保存的类型，当从channel接收一个值时，将是一个Page值，因此将同时打印它的URL和Size字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Page struct { //声明一个带有需要的字段的struct类型
	URL  string
	Size int
}

func responseSize(url string, channel chan Page) { //传递给responseSize的channel将携带Page，而不是int
	fmt.Println(&amp;#34;Getting&amp;#34;, url)
	response, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}
	defer response.Body.Close()
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Fatal()
	}
	channel &amp;lt;- Page{URL: url, Size: len(body)} //返回一个包含当前URL和页面大小的Page

}

func main() {
	pages := make(chan Page) //更改channel保存的类型
	urls := []string{
		&amp;#34;https://example.com/&amp;#34;,
		&amp;#34;https://golang.org/&amp;#34;,
		&amp;#34;https://golang.org/doc&amp;#34;,
	}
	for _, url := range urls {
		go responseSize(url, pages) //将channel传递给responseSize
	}
	for i := 0; i &amp;lt; len(urls); i++ {
		page := &amp;lt;-pages                              //接收Page
		fmt.Println(&amp;#34;%s: %d\n&amp;#34;, page.URL, page.Size) //将URL和大小一起打印
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在输出将把页面大小和URl配对，以前，我们的程序必须一次请求一个页面，goroutine让我们在等待网站响应时开始处理下一个请求，大大提高了速度。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>12.从失败中恢复</title>
      <link>https://tinklespring.com/posts/12.%E4%BB%8E%E5%A4%B1%E8%B4%A5%E4%B8%AD%E6%81%A2%E5%A4%8D/</link>
      <pubDate>Thu, 17 Aug 2023 18:08:56 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/12.%E4%BB%8E%E5%A4%B1%E8%B4%A5%E4%B8%AD%E6%81%A2%E5%A4%8D/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;每个程序都会遇到错误，有时处理错误可以像报告错误并退出程序一样简单，但其他错误可能需要额外的操作，比如需要关闭打开的文件或网络链接，或者以其他方式清理，这样程序不会混乱。本篇将展示如何延迟清理操作，以便在出现错误时也能执行这些操作；还将展示如何在适当的情况下使程序出现panic，以及如何在事后恢复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;从文件中读取数字重新访问&#34;&gt;从文件中读取数字，重新访问&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;os&amp;#34;
	&amp;#34;strconv&amp;#34;
)

func OpenFile(fileName string) (*os.File, error) {
	fmt.Println(&amp;#34;Opening&amp;#34;, fileName)
	return os.Open(fileName) //打开文件并返回指向该文件的指针，以及遇到的任何错误
}
func CloseFile(file *os.File) {
	fmt.Println(&amp;#34;Closing file&amp;#34;)
	file.Close() //关闭文件
}

func GetFloats(fileName string) ([]float64, error) {
	var numbers []float64
	file, err := OpenFile(fileName) //不是直接调用os.Open，而是调用OpenFile
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		number, err := strconv.ParseFloat(scanner.Text(), 64)
		if err != nil {
			return nil, err
		}
		numbers = append(numbers, number)
	}
	CloseFile(file) //不是直接调用file.Close，而是调用CloseFile
	if scanner.Err() != nil {
		return nil, scanner.Err()
	}
	return numbers, nil
}

func main() {
	numbers, err := GetFloats(os.Args[1]) //存储从文件中读取的数字切片以及任何错误，使用第一个命令行参数作为文件名
	if err != nil {                       //如果有错误，记录并退出
		log.Fatal(err)
	}
	var sum float64 = 0
	for _, number := range numbers { //把切片中的所有数字加起来
		sum += number
	}
	fmt.Printf(&amp;#34;Sum: %0.2f\n&amp;#34;, sum) //打印总和
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们希望将要读取的文件名称指定为命令行参数，因此在main函数中，通过访问 &lt;code&gt;os.Args[1]&lt;/code&gt; 从第一个命令行参数获取要打开文件的名称。（&lt;code&gt;os.Args[0]&lt;/code&gt;元素是正在运行的程序的名称，实际的程序参数出现在os.Args[1]和后面的元素中）。&lt;/p&gt;
&lt;p&gt;然后将文件名传递给GetFloats来读取文件，并得到一个返回float64值的切片。如果在这个过程中遇到任何错误，它们将从GetFloats函数返回，将把它们存储在err变量中，若err不是nil，意味着有错误，只需记录并退出。否则意味着文件被成功读取，使用for循环将切片中的每个值相加，并打印总和。&lt;/p&gt;
&lt;p&gt;data.txt:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1.25
8.75
5.0
10.5
15.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# go run sum.go data.txt
Opening 123.txt
Closing file
Sum: 41.00
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;任何错误都阻止关闭文件&#34;&gt;任何错误都阻止关闭文件&lt;/h1&gt;
&lt;p&gt;但是如果提供了一个格式不正确的文件，就会出现问题，比如文件的行不能解析为float64。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;20.25
hello   //无法解析为float64
123.11
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是正常的，因为每个程序都会遇到接收无效数据的情况，但是GetFloats函数在完成后，调用CloseFile函数，实际上却没有调用。&lt;/p&gt;
&lt;p&gt;当对无法转换为float64的字符串调用strconv.ParseFloat时，返回一个错误，我们的代码被设置为在此时从GetFloats函数返回，但是这个返回发生在调用CloseFile之前，这意味着文件永远不会被关闭。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func GetFloats(fileName string) ([]float64, error) {
	var numbers []float64
	file, err := OpenFile(fileName)
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		number, err := strconv.ParseFloat(scanner.Text(), 64) //当不能将文本行转换为float64时，ParseFloat返回一个错误，这回导致GetFloats返回一个错误
		if err != nil {
			return nil, err
		}
		numbers = append(numbers, number)
	}
	CloseFile(file)  //CloseFile永远不会被调用
	if scanner.Err() != nil {
		return nil, scanner.Err()
	}
	return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;延迟函数调用&#34;&gt;延迟函数调用&lt;/h1&gt;
&lt;p&gt;关闭文件失败似乎没什么大不了，对于一个只打开一个文件的简单程序来说，可能没问题，但是每个打开的文件都会消耗操作系统的资源，打开文件越多可能会累积并导致程序失败，甚至影响操作系统。&lt;/p&gt;
&lt;p&gt;如果有一个无论如何都希望运行的函数调用，可以使用&lt;code&gt;defer&lt;/code&gt;语句。可以将defer关键字放在任何普通函数或方法调用&lt;code&gt;之前&lt;/code&gt;，Go将延迟执行函数调用，直到当前函数退出之后。&lt;/p&gt;
&lt;p&gt;通常来说，函数调用一遇到就立即执行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func Socialize() {
        fmt.Println(&amp;#34;Goodbye!&amp;#34;)
        fmt.Println(&amp;#34;Hello!&amp;#34;)
        fmt.Println(&amp;#34;Nice!&amp;#34;)
}

func main() {
        Socialize()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，如果在调用fmt.Println(&amp;ldquo;Goodbye!&amp;rdquo;) 之前添加defer关键字，则在Socialize函数中的所有剩余代码运行之前以及Socialize退出之前，该调用不会执行。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func Socialize() {
        defer fmt.Println(&amp;#34;Goodbye!&amp;#34;)  //在函数调用之前添加defer关键字
        fmt.Println(&amp;#34;Hello!&amp;#34;)
        fmt.Println(&amp;#34;Nice!&amp;#34;)
}

func main() {
        Socialize()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hello!
Nice!
Goodbye!   //第一个函数调用被推迟到Socialize退出之后
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用延迟函数调用从错误中恢复&#34;&gt;使用延迟函数调用从错误中恢复&lt;/h1&gt;
&lt;p&gt;defer 用于“无论如何”都需要发生的函数调用：
defer 关键字通过使用return 关键字确保函数调用发生，即使调用函数提前退出。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;log&amp;#34;
)

func Socialize() error {
        defer fmt.Println(&amp;#34;Goodbye!&amp;#34;)
        fmt.Println(&amp;#34;Hello!&amp;#34;)
        return fmt.Errorf(&amp;#34;I don&amp;#39;t want to talk.&amp;#34;)
        fmt.Println(&amp;#34;Nice!&amp;#34;)  //不会运行
        return nil  //不会运行
}

func main() {
        err := Socialize()
        if err != nil {
                log.Fatal(err)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hello!
Goodbye!
2023/08/18 10:38:37 I don&amp;#39;t want to talk.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;defer 关键字确保函数调用发生，即使调用函数提前退出。&lt;/p&gt;
&lt;p&gt;当return语句被执行时：&lt;br&gt;
1.return语句首先计算其返回值（如果有的话），并保存在内部变量中；
2.执行所有defer语句；
3.实际返回已保存的返回值，并退出函数；&lt;/p&gt;
&lt;p&gt;在Socialize函数中的return语句被执行时，首先保存了要返回的错误值，然后执行defer，最后再执行return返回错误值，退出函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;先执行defer，最后执行return&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用延迟函数调用确保文件关闭&#34;&gt;使用延迟函数调用确保文件关闭&lt;/h1&gt;
&lt;p&gt;因为defer关键字可以确保“无论如何”都执行函数调用，所以通常用于需要运行的代码，即使在出现错误的情况下也是如此，比如在文件打开后关闭它们。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func GetFloats(fileName string) ([]float64, error) {
	var numbers []float64
	file, err := OpenFile(fileName) //不是直接调用os.Open，而是调用OpenFile
	if err != nil {
		return nil, err
	}
	defer CloseFile(file) //添加defer，这样即使函数退出后也会执行，并将其移动到OpenFile之后
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		number, err := strconv.ParseFloat(scanner.Text(), 64)
		if err != nil {
			return nil, err  //即使返回错误，CloseFile仍然会被调用
		}
		numbers = append(numbers, number)
	}
	if scanner.Err() != nil {
		return nil, scanner.Err()  //如果函数正常完成，就会调用CloseFile
	}
	return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用defer可以确保在GetFloats退出时调用CloseFile，不管它是正常完成还是解析文件出错。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;问：是否可以延迟其他语句，比如for循环或者变量赋值？&lt;/p&gt;
&lt;p&gt;答：不可以，只能延迟函数和方法调用，可以编写一个函数或方法，然后延迟对函数或方法的调用，但是defer关键字本身只能与函数或方法调用一起使用。&lt;/p&gt;
&lt;h1 id=&#34;列出目录中的文件&#34;&gt;列出目录中的文件&lt;/h1&gt;
&lt;p&gt;Go还有一些特性可以帮助处理错误。&lt;/p&gt;
&lt;p&gt;创建一个名为my_directory的内容，指出它包含的每个项的名称，以及它是文件还是子目录。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;├── my_directory
│   ├── a.txt
│   ├── subdir
│   └── z.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;io/ioutil 包 包含一个ReadDir函数，允许读取目录内容，向ReadDir传递一个目录的名称，将返回一个值切片，每个值切片对应目录包含的每个文件或子目录（以及遇到的任何错误）。&lt;/p&gt;
&lt;p&gt;每个切片的值都满足FileInfo接口，该接口包括一个返回文件名的Name方法和一个如果是目录则返回true的IsDir方法。&lt;/p&gt;
&lt;p&gt;因此，程序调用ReadDir，将my_directory的名称作为参数传递给它，然后循环遍历返回的切片中的每个值，如果IsDir返回值为true，将打印“Directory: ” 和文件名，否则将打印“File: ” 和文件名。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;io/ioutil&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        files, err := ioutil.ReadDir(&amp;#34;my_directory&amp;#34;)  //获取一个包含代表&amp;#34;my_directory&amp;#34;的内容的值的切片
        if err != nil {
                log.Fatal(err)
        }
        for _, file := range files {   //对于切片中的每个文件。。。
		if file.IsDir() {  //如果文件是一个目录...
                        fmt.Println(&amp;#34;Directory:&amp;#34;, file.Name())
		} else {  //否则，打印...
                        fmt.Println(&amp;#34;File:&amp;#34;, file.Name())
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;File: a.txt
Directory: subdir
File: z.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序运行并生成my_directory所包含的文件和目录的列表。&lt;/p&gt;
&lt;p&gt;读取单个目录内容的程序不复杂，但是若想列出更复杂的内容，比如Go工作区目录，它将包含嵌套在子目录中的整个子目录树，有些包含文件，有些不包含。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;├── go
│   └── src
│       ├── geo
│       │   ├── coordinates.go
│       │   └── landmark.go
│       ├── locked
│       │   └── secret.go
│       └── vehicle
│           └── car.go
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;递归函数调用&#34;&gt;递归函数调用&lt;/h1&gt;
&lt;p&gt;递归允许函数调用自身。&lt;/p&gt;
&lt;p&gt;若不小心，会得到一个无限循环，函数会不停调用自己：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func recurses() {
        fmt.Println(&amp;#34;Oh, no, I&amp;#39;m stuck!&amp;#34;)
        recurses()  //函数调用自己
}

func main() {
        recurses()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Oh, no, I&amp;#39;m stuck!
Oh, no, I&amp;#39;m stuck!
Oh, no, I&amp;#39;m stuck!
Oh, no, ^Csignal: interrupt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是如果能确保递归循环能停止，其实递归是有用的。&lt;/p&gt;
&lt;p&gt;这是一个递归count函数，从第一个数到最后一个数进行计数（通常来说循环更有效，这里仅演示递归工作原理）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func count(start int, end int) {
        fmt.Println(start)   //打印当前的起始数
        if start &amp;lt; end {  //如果还没有达到结束数字
                count(start+1, end)  //“count”函数使用比之前多1的起始数调用自身
        }
}

func main() {
        count(1, 3)  //第一次调用“count”，指定它应该从1到3计数
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序的顺序：&lt;br&gt;
1.main使用起始（start）参数1和结束（end）参数3调用count；&lt;/p&gt;
&lt;p&gt;2.count打印起始参数1；&lt;/p&gt;
&lt;p&gt;3.start(1) 小于end(3)，因此count以起始数2和结束数3调用自己；&lt;/p&gt;
&lt;p&gt;4.第二次调用count将打印其新的起始参数：2；&lt;/p&gt;
&lt;p&gt;5.start(2) 小于end(3)，因此count以起始数3和结束数3调用自己；&lt;/p&gt;
&lt;p&gt;6.第三次调用count将打印其新的起始参数：3；&lt;/p&gt;
&lt;p&gt;7.start(3) 不小于end(3)，因此count不再调用自己，只是返回；&lt;/p&gt;
&lt;p&gt;8.前两次count调用也返回了，程序结束。&lt;/p&gt;
&lt;p&gt;若再添加对Printf调用，来显示每次count的调用和输出，这个程序更明显：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func count(start int, end int) {
        fmt.Printf(&amp;#34;count(%d, %d) called\n&amp;#34;, start, end)
        fmt.Println(start)
        if start &amp;lt; end {
                count(start+1, end)
        }
        fmt.Printf(&amp;#34;Returning from count(%d, %d) call\n&amp;#34;, start, end)
}

func main() {
        count(1, 3)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;count(1, 3) called
1
count(2, 3) called
2
count(3, 3) called
3
Returning from count(3, 3) call
Returning from count(2, 3) call
Returning from count(1, 3) call
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;递归列出目录内容&#34;&gt;递归列出目录内容&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;io/ioutil&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;path/filepath&amp;#34;
)

func scanDirectory(path string) error { //递归函数，接受要扫描的路径，返回遇到的任何错误
	fmt.Println(path)                  //打印当前目录
	files, err := ioutil.ReadDir(path) //获取包含目录内容的切片
	if err != nil {
		return err
	}
	for _, file := range files {
		filePath := filepath.Join(path, file.Name()) //应斜杠将目录路径和文件名连接起来
		if file.IsDir() {                            //如果这是一个目录
			err := scanDirectory(filePath) //递归调用scanDirectory，这次是用子目录的路径
			if err != nil {
				return err
			}
		} else {
			fmt.Println(filePath) //如果这是一个普通文件，只需打印它的路径
		}
	}
	return nil
}

func main() {
	err := scanDirectory(&amp;#34;go&amp;#34;) //通过对顶部目录调用scanDirectory来启动该过程
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出；&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
go/src
go/src/geo
go/src/geo/coordinates.go
go/src/geo/landmark.go
go/src/locked
go/src/locked/secret.go
go/src/vehicle
go/src/vehicle/car.go
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;scanDirectory第一件事是打印当前路径，这样就知道我们在哪个目录下工作，然后它对该路径调用ioutil.ReadDir来获取目录的内容。&lt;/p&gt;
&lt;p&gt;循环遍历ReadDir返回FileInfo值切片，处理每个值，调用filepath.Join将当前目录路径与当前文件名用斜杠连接起来（因此&amp;quot;go&amp;quot;和&amp;quot;src&amp;quot;被连接成&amp;quot;go/src&amp;quot;）。&lt;/p&gt;
&lt;p&gt;如果当前文件不是一个目录，scanDirectory只打印其完整卢金个，然后移动到下一个文件（如果当前目录中有其他文件）。&lt;/p&gt;
&lt;p&gt;但是如果当前文件是一个目录，则会启动递归：scanDirectory使用该子目录的路径调用自己，如果该子目录有任何子目录，那么scanDirectory将使用每个子目录来调用自己，以此类推，遍历整个文件数。&lt;/p&gt;
&lt;p&gt;过程：&lt;br&gt;
1.main使用“go”路径调用scanDirectory；&lt;/p&gt;
&lt;p&gt;2.scanDirectory打印它所传递的路径“go”，代表它所工作的目录；&lt;/p&gt;
&lt;p&gt;3.使用“go”路径调用 ioutil.ReadDir;&lt;/p&gt;
&lt;p&gt;4.返回的切片中只有一条内容：“src”；&lt;/p&gt;
&lt;p&gt;5.对“go”的当前目录路径和“src”文件名调用filepath.Join，得到新路径“go/src”;&lt;/p&gt;
&lt;p&gt;6.src 是一个子目录，所以再次调用 scanDirectory，这次使用的路径是 &amp;ldquo;go/src&amp;rdquo;，&amp;lt;&amp;ndash;递归&lt;/p&gt;
&lt;p&gt;7.scanDirectory打印新路径：“go/src”&lt;/p&gt;
&lt;p&gt;8.使用“go/src”路径调用 ioutil.ReadDir ;&lt;/p&gt;
&lt;p&gt;9.返回的切片中的第一条内容是“geo”；&lt;/p&gt;
&lt;p&gt;10.对“go/src”的当前目录路径和“geo”文件名调用filepath.Join，得到新路径“go/src/geo”；&lt;/p&gt;
&lt;p&gt;11.geo是一个子目录，因此再次调用 scanDirectory，这次使用的路径是 “go/src/geo”；&lt;/p&gt;
&lt;p&gt;12.scanDirectory打印新路径&amp;quot;go/src/geo&amp;quot;;&lt;/p&gt;
&lt;p&gt;13.使用“go/src/geo”路径调用ioutil.ReadDir;&lt;/p&gt;
&lt;p&gt;14.返回的切片中第一条内容是“coordinates.go”;&lt;/p&gt;
&lt;p&gt;15.coordinates.go不是目录，所以只打印名字；&lt;/p&gt;
&lt;p&gt;16.以此类推。。。&lt;/p&gt;
&lt;p&gt;递归函数比较难写，并且通常会比非递归解决方式消耗更多的计算资源，但有时候递归函数可以解决用其他方式难以解决的问题。&lt;/p&gt;
&lt;h1 id=&#34;递归函数中的错误处理&#34;&gt;递归函数中的错误处理&lt;/h1&gt;
&lt;p&gt;如果scanDirectory在扫描任何子目录时遇到错误，比如没有访问该目录的权限，将返回一个错误。&lt;/p&gt;
&lt;p&gt;添加两个Printf语句来显示返回的错误，会发现处理此错误的方式并不理想，如果在递归的scanDirectory调用中发生错误，则必须沿整个链返回该错误，直到main函数为止。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func scanDirectory(path string) error {
	fmt.Println(path)
	files, err := ioutil.ReadDir(path)
	if err != nil {
		fmt.Printf(&amp;#34;Returning error form scanDirectory(\&amp;#34;%s\&amp;#34;) call\n&amp;#34;, path)  //对ReadDir调用中的错误打印调试信息
		return err
	}
	for _, file := range files {
		filePath := filepath.Join(path, file.Name())
		if file.IsDir() {
			err := scanDirectory(filePath)
			if err != nil {
				fmt.Printf(&amp;#34;Returning error form scanDirectory(\&amp;#34;%s\&amp;#34;) call\n&amp;#34;, path)  //对递归的scanDirectory调用中的错误打印调试信息
				return err
			}
		} else {
			fmt.Println(filePath)
		}
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;发起一个panic&#34;&gt;发起一个panic&lt;/h1&gt;
&lt;p&gt;以前遇到过panic，在访问数组和切片中的无效索引时。当类型断言失败时，也会看到：当程序出现panic时，当前函数停止运行，程序打印日志消息并崩溃。可以通过调用内置的panic函数来引发panic。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
func main() {
	panic(&amp;#34;oh, no, we&amp;#39;re going down&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: oh, no, we&amp;#39;re going down

goroutine 1 [running]:
main.main()
	/golang/panic.go:4 +0x39
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;panic函数需要一个满足空接口的参数（也就是说，它可以是任何类型），该参数将被转换为字符串（如果需要），并作为panic日志信息的一部分打印出来。&lt;/p&gt;
&lt;h1 id=&#34;堆栈跟踪&#34;&gt;堆栈跟踪&lt;/h1&gt;
&lt;p&gt;每个被调用的函数都需要返回到调用的它的函数，为了实现这一点，Go保持一个调用堆栈，即在任何给定点上处于活动状态的函数的调用的列表。&lt;/p&gt;
&lt;p&gt;当程序发生panic时，panic输出中包含堆栈跟踪，即调用堆栈列表，这对于确定导致程序崩溃的原因很有用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

func main() {
	one()
}
func one() {
	two()
}
func two() {
	three()
}
func three() {
	panic(&amp;#34;this call stack&amp;#39;s too deep for me!&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: this call stack&amp;#39;s too deep for me!

goroutine 1 [running]:
main.three(...)
	/golang/one.go:13
main.two(...)
	/golang/one.go:10
main.one(...)
	/golang/one.go:7
main.main()
	/golang/one.go:4 +0x3b
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;堆栈跟踪包括已执行的函数调用的列表。&lt;/p&gt;
&lt;h1 id=&#34;延迟调用在崩溃前完成&#34;&gt;延迟调用在崩溃前完成&lt;/h1&gt;
&lt;p&gt;当程序出现panic时，所有延迟的函数调用仍然会被执行，如果有多个延迟调用，它们的执行顺序将与被延迟的顺序相反。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
	one()
}
func one() {
	defer fmt.Println(&amp;#34;deferred in one()&amp;#34;)  //这个函数调用被延迟，所以排在最后执行
	two()
}
func two() {
	defer fmt.Println(&amp;#34;deferred in two()&amp;#34;)  //这个函数调用被延迟，所以排在最后执行
	panic(&amp;#34;Let&amp;#39;s see what&amp;#39;s been deferred!&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;deferred in two()
deferred in one()
panic: Let&amp;#39;s see what&amp;#39;s been deferred!

goroutine 1 [running]:
main.two()
	/golang/two.go:14 +0x95
main.one()
	/golang/two.go:10 +0x85
main.main()
	/golang/two.go:6 +0x20
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;通过scandirectory使用panic&#34;&gt;通过scanDirectory使用&amp;quot;panic&amp;quot;&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;io/ioutil&amp;#34;
	&amp;#34;path/filepath&amp;#34;
)

func scanDirectory(path string) { //不再需要返回错误值
	fmt.Println(path)
	files, err := ioutil.ReadDir(path)
	if err != nil {
		panic(err) //不返回错误值，而是将其传递给&amp;#34;panic&amp;#34;
	}
	for _, file := range files {
		filePath := filepath.Join(path, file.Name())
		if file.IsDir() {
			scanDirectory(filePath) //不再需要存储或检查错误返回值
		} else {
			fmt.Println(filePath)
		}
	}
}

func main() {
	scanDirectory(&amp;#34;go&amp;#34;) //不再需要存储或检查错误返回值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从scanDirectory声明中删除错误返回值，若从ReadDir返回一个error值，将其传递给panic，可以从对scanDirectory的递归调用中删除错误处理代码，也可以在main中从对scanDirectory的调用中删除错误处理代码。&lt;/p&gt;
&lt;p&gt;当scanDirectory在读取目录遇到错误时，就产生panic，所有对scanDirectory的递归调用都退出。&lt;/p&gt;
&lt;h1 id=&#34;何时产生panic&#34;&gt;何时产生panic&lt;/h1&gt;
&lt;p&gt;事实上，调用panic并不是处理错误的理想方法。&lt;/p&gt;
&lt;p&gt;无法访问的文件、网络故障和错误的用户输入通常是被允许的，应该通过错误值来进行适当的处理，通产，调用panic应该留给&amp;quot;不可能&amp;quot;的情况，比如错误表示的是程序中的错误，而不是用户方的错误。&lt;/p&gt;
&lt;p&gt;下面这个示例使用panic来指明一个bug。会颁发隐藏在三扇虚拟门中其中一扇门后面的奖品，doorNumber 变量不是由用户输入的，而是由rand.Intn函数选择的一个随机数，如果doorNumber 包含1、2或3以外的任何数字，就是程序的bug，而不是用户错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;math/rand&amp;#34;
	&amp;#34;time&amp;#34;
)

func awardPrize() {
	doorNumber := rand.Intn(3) + 1 //产生一个1到3之间的随机整数
	if doorNumber == 1 {
		fmt.Println(&amp;#34;you win a cruise!&amp;#34;)
	} else if doorNumber == 2 {
		fmt.Println(&amp;#34;you win a car!&amp;#34;)
	} else if doorNumber == 3 {
		fmt.Println(&amp;#34;you win a goat!&amp;#34;)
	} else {
		panic(&amp;#34;invalid door number&amp;#34;) //不应该产生其他数字，如果产生就panic
	}
}

func main() {
	rand.Seed(time.Now().Unix())
	awardPrize()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此，假如doorNumber包含无效值，调用panic是有意义的。&lt;/p&gt;
&lt;h1 id=&#34;recover函数&#34;&gt;&amp;ldquo;recover&amp;quot;函数&lt;/h1&gt;
&lt;p&gt;将scanDirectory函数改为使用panic而不是返回错误，这大大简化了错误处理代码，但panic也会导致程序崩溃，出现难看的堆栈跟踪，宁愿只显示错误信息。&lt;/p&gt;
&lt;p&gt;Go提供了一个内置的&lt;code&gt;recover&lt;/code&gt;函数，可以阻止程序陷入panic，需要使用它来体面的退出程序。&lt;/p&gt;
&lt;p&gt;正常程序执行过程中调用recover时，只返回nil，而不执行其他操作：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
	fmt.Println(recover())  //如果在一个程序中调用&amp;#34;recover&amp;#34;，而这个程序没有panic...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;nil&amp;gt;  //什么都不做，返回nil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果在程序处于panic状态时调用recover，将停止panic，但是当在函数中调用panic时，该函数将停止执行。因此，在panic所在的同一个函数中调用recover没有意义，因为panic无论如何都会继续：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func freakOut() {
	panic(&amp;#34;oh no&amp;#34;)  //panic阻止了freakOut函数的其余部分运行
	recover()
}
func main() {
	freakOut()
	fmt.Println(&amp;#34;Exiting normally&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: oh no

goroutine 1 [running]:
main.freakOut()
	/golang/freakOut.go:6 +0x39
main.main()
	/golang/freakOut.go:11 +0x22
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，当程序panic时，有一种方式可以调用recover。在panic期间，任何延迟的函数调用都将完成，因此可以在一个单独的函数中放置一个recover调用，并在引发panic的代码之前使用defer调用该函数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	recover()
}
func freakOut() {
	defer calmDown()
	panic(&amp;#34;oh no&amp;#34;)
}
func main() {
	freakOut()
	fmt.Println(&amp;#34;Exiting normally&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用recover不会导致在出现panic时恢复执行，至少不会完全恢复。产生panic的函数将立即返回，而该函数块中panic之后的任何代码都不会执行。但是在产生panic的函数返回之后，正常的执行将恢复。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	recover()
}
func freakOut() {
	defer calmDown()
	panic(&amp;#34;oh no&amp;#34;)  //当恢复时freakOut在这个位置返回
	fmt.Println(&amp;#34;I won&amp;#39;t be run!&amp;#34;)  //panic之后的代码永远不会运行
}
func main() {
	freakOut()
	fmt.Println(&amp;#34;Exiting normally&amp;#34;)  //这段代码在freakOut返回后运行
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;panic值从recover中返回&#34;&gt;panic值从recover中返回&lt;/h1&gt;
&lt;p&gt;程序当没有panic时，调用recover返回nil，但是当出现panic时，&lt;code&gt;recover返回传递给panic的任何值&lt;/code&gt;，这可以用来收集有关panic的信息，帮助恢复或向用户报告错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	fmt.Println(recover())   //调用&amp;#34;recover&amp;#34;并打印panic值
}
func main() {
	defer calmDown()
	panic(&amp;#34;oh no&amp;#34;)  //将从&amp;#34;recover&amp;#34;返回的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;oh no
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;panic函数其参数类型是 interface{} ，即空接口，因此panic可以接收任何值。同样recover的返回值类型也是 interface{} ，可以将recover的返回值传递给诸如Println（它接受interface{}值）之类的fmt函数，但不能直接对其调用方法。&lt;/p&gt;
&lt;p&gt;将error值传递给panic，但这样做时，error被转换为一个空接口值，当延迟的函数稍后调用recover时，返回的是interface{}值，即使底层的error值有一个Error方法，试图调用interface{}值上的Error会导致编译错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	p := recover()  //返回一个空接口
	fmt.Println(p.Error())   //即使底层的“error”值有一个Error方法，但interface{}没有
}
func main() {
	defer calmDown()
	err := fmt.Errorf(&amp;#34;there&amp;#39;s an error&amp;#34;)
	panic(err)  //将错误值而不是字符串传递给“panic”
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p.Error undefined (type interface{} is interface with no methods)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要对panic值调用方法或执行其他操作，需要使用类型断言将其转换回其底层类型：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	p := recover()
	err, ok := p.(error)  //断言panic值的类型为“error”
	if ok {
		fmt.Println(err.Error())  //现在有了一个“error”值，可以调用Error方法
	}
}
func main() {
	defer calmDown()
	err := fmt.Errorf(&amp;#34;there&amp;#39;s an error&amp;#34;)
	panic(err)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;there&amp;#39;s an error
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;从scandirectory中的panic恢复&#34;&gt;从scanDirectory中的panic恢复&lt;/h1&gt;
&lt;p&gt;添加一个reportPanic函数，在main中使用defer调用它，在调用scanDirectory前调用它，这可能会引起潜在的panic。&lt;/p&gt;
&lt;p&gt;在reportPanic中，调用recover并存储它返回的panic值，如果程序处于panic状态，这将会停止panic。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;io/ioutil&amp;#34;
	&amp;#34;path/filepath&amp;#34;
)

func reportPanic() {
	p := recover() //调用“recover”并存储它的返回值
	if p == nil {  //如果返回nil，则没有panic
		return
	}
	err, ok := p.(error) //否则，获取底层的“error”值
	if ok {
		fmt.Println(err) //然后打印出来
	}
}

func scanDirectory(path string) {
	fmt.Println(path)
	files, err := ioutil.ReadDir(path)
	if err != nil {
		panic(err)
	}
	for _, file := range files {
		filePath := filepath.Join(path, file.Name())
		if file.IsDir() {
			scanDirectory(filePath)
		} else {
			fmt.Println(filePath)
		}
	}
}

func main() {
	defer reportPanic() //在调用可能引起panic的代码前，延迟调用新reportPanic函数
	scanDirectory(&amp;#34;go&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果没有panic，从reportPanic返回，不做任何事情，若panic值不是nil，意味着出现了panic，因为scanDirectory将error值传递给panic，所以使用类型断言将 interface{}panic 值转换为error值，若转换成功，则打印error值。&lt;/p&gt;
&lt;p&gt;这样的话，程序输出只会看到错误信息，而不是难看的panic日志和堆栈跟踪。&lt;/p&gt;
&lt;h1 id=&#34;恢复panic&#34;&gt;恢复panic&lt;/h1&gt;
&lt;p&gt;reportPanic还存在一个潜在的问题，它可以拦截任何panic，即使不是来自scanDirectory，如果panic值不能转换为error类型，reportPanic将不会打印它。&lt;/p&gt;
&lt;p&gt;可以通过在main中使用一个string参数来添加另一个对panic的调用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	defer reportPanic()
	panic(&amp;#34;some other issue&amp;#34;)
	scanDirectory(&amp;#34;go&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   //没有输出
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;reportPanic函数从新的panic中恢复，但是因为panic值不是一个error，所以reportPanic不会打印它，我们不知道为什么程序失败了。&lt;/p&gt;
&lt;p&gt;有一种策略来处理不曾预料且不准备从中恢复的panic，即简单的恢复panic状态。&lt;/p&gt;
&lt;p&gt;如果将panic值转换为error的类型断言成功，只需像以前那样打印它，如果失败，只需用同样的panic值再次调用panic。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func reportPanic() {
	p := recover()
	if p == nil {
		return
	}
	err, ok := p.(error)
	if ok {
		fmt.Println(err)
	} else {
		panic(p) //如果panic值不是error，则使用相同的值恢复panic
	}
}

func scanDirectory(path string) {
// ...
}

func main() {
	defer reportPanic()
	panic(&amp;#34;some other issue&amp;#34;) //一旦确定reportPanic起作用，不要忘记删除这个测试panic
	scanDirectory(&amp;#34;go&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: some other issue [recovered]
	panic: some other issue

goroutine 1 [running]:
main.reportPanic()
	/golang/reportPanic_panic.go:18 +0xec
panic(0x10ab940, 0x10e8ff0)
	/usr/local/go/src/runtime/panic.go:969 +0x166
main.main()
	/golang/reportPanic_panic.go:40 +0x5b
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;reportPanic从我们对panic的测试调用中恢复了，但是当error类型断言失败，它将再次陷入panic。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Go语言本身的设计不鼓励使用panic和recover，Go鼓励以处理程序其他部分的方式处理错误，比如使用if和return语句，以及error值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;练习：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func snack() {
	defer fmt.Println(&amp;#34;closing&amp;#34;)
	fmt.Println(&amp;#34;opening&amp;#34;)
	panic(&amp;#34;empty&amp;#34;)
}
func main() {
	snack()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;opening
closing  //这个调用被延迟，直到snack函数退出（在panic期间）才进行调用
panic: empty
....
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>11.接口</title>
      <link>https://tinklespring.com/posts/11.%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 14 Aug 2023 17:48:56 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/11.%E6%8E%A5%E5%8F%A3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;有时并不关心一个值的特定类型，只需知道它能做特定的事情，能够在其上调用特定的接口。这就是Go接口的目标：允许定义能够保存任何类型的变量和函数参数，前提是定义了特定的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;具有相同方法的两种不同类型&#34;&gt;具有相同方法的两种不同类型&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package gadget

import &amp;#34;fmt&amp;#34;

type TapePlayer struct {
	Batteries string
}

func (t TapePlayer) Play(song string) {
	fmt.Println(&amp;#34;Playing&amp;#34;, song)
}
func (t TapePlayer) Stop() {
	fmt.Println(&amp;#34;Stopped!&amp;#34;)
}

type TapeRecorder struct {
	Microphones int
}

func (t TapeRecorder) Play(song, string) { //有个与TapePlayer相同的Play方法
	fmt.Println(&amp;#34;Playing&amp;#34;, song)
}
func (t TapeRecorder) Record() {
	fmt.Println(&amp;#34;Recording&amp;#34;)
}
func (t TapeRecorder) Stop() { //有个与TapePlayer相同的Stop方法
	fmt.Println(&amp;#34;Stopped!&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;TapePlayer类型有一个Play方法来模拟播放歌曲，一个Stop方法来停止播放，TapeRecorder类型也有Play和Stop方法，还有一个Record方法。&lt;/p&gt;
&lt;h1 id=&#34;只能接受一种类型的方法参数&#34;&gt;只能接受一种类型的方法参数&lt;/h1&gt;
&lt;p&gt;一个使用gadget包的示例：定义一个playList函数，接收一个TapePlayer值和一个在其上播放的一组歌名的切片，函数循环变量切片的每个歌名，并将它传递给TapePlayer的Play方法，当它播放列表后，调用TapePlayer的Stop方法。然后在main中，创建一个TapePlayer和一个歌单切片，并将其传递给playList。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;xxx/xxx/gadget&amp;#34;

func playList(device gadget.TapePlayer, songs []string) {
	for _, song := range songs { //循环每首歌曲
                device.Play(song)  //播放当前歌曲
	}
        device.Stop()  //播放完成后，停止播放
}

func main() {
        player := gadget.TapePlayer{}  //创建一个TapePlayer
        mixtape := []string{&amp;#34;Jessie&amp;#39;s Girl&amp;#34;, &amp;#34;Whip It&amp;#34;, &amp;#34;9 to 5&amp;#34;}  //创建一个歌名的切片
        playList(player, mixtape)  //使用TapePlayer播放歌曲
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Playing Jessie&amp;#39;s Girl
Playing Whip It
Playing 9 to 5
Stopped!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PlayList函数使用TapePlayer值工作正常，但是希望它可以使用TapeRecorder作为参数，但playList函数需要一个TapePlayer类型，尝试传入其他类型会编译错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
         player := gadget.TapeRecorder{}
         mixtape := []string{&amp;#34;Jessie&amp;#39;s Girl&amp;#34;, &amp;#34;Whip It&amp;#34;, &amp;#34;9 to 5&amp;#34;}
         playList(player, mixtape)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;playList函数只接受TapePlayer值。&lt;/p&gt;
&lt;h1 id=&#34;接口&#34;&gt;接口&lt;/h1&gt;
&lt;p&gt;当在电脑上安装程序时，通常希望程序提供一种交互的方式，希望文字处理器提供键入文字的地方。这一组程序提供的用来交互的控制方法通常称为接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;一个接口是特定值预期具有的一组方法。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在Go中，一个接口被定义为特定值预期具有的一组方法，可以把接口看作需要类型实现的一组行为。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;interface&lt;/code&gt; 关键字定义一个接口类型，后面跟着一个花括号，内部含有一组方法，以及方法期望的参数和返回值。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/11-interface/interface.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;任何拥有接口定义的所有方法的类型被称作&lt;code&gt;满足那个接口&lt;/code&gt;，一个满足接口的类型可以用在任何需要接口的地方。&lt;/p&gt;
&lt;p&gt;方法名称、参数类型（可能没有）和返回值（可能没有）都需要与接口中定义的一致，除了接口中列出的方法外，类型还可以有更多的方法，但不能缺少接口中的任何方法，否则就不满足那个接口。&lt;/p&gt;
&lt;p&gt;一个类型可以满足多个接口，一个接口可以有多个类型满足它。&lt;/p&gt;
&lt;h1 id=&#34;定义满足接口的类型&#34;&gt;定义满足接口的类型&lt;/h1&gt;
&lt;p&gt;一个名为mypkg的包，定义了一个有三个方法的名为MyInterface的接口，然后定义了一个名字MyType的类型，正好可满足MyInterface。&lt;/p&gt;
&lt;p&gt;为了满足MyInterface接口需要有三个方法：MethodWithoutParameters方法，接受float64参数的MethodWithParameter方法，返回string类型的MethodWithReturnValue方法。然后声明另外一个类型MyType，为了使MyType满足MyInterface，定义了接口需要的所有方法，另外包含一个并不属于接口的额外的方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package mypkg

import &amp;#34;fmt&amp;#34;

type MyInterface interface {  //声明一个接口类型
        MethodWithoutParameters()  //一个类型满足接口，如果有这个方法
        MethodWithParameter(float64)
        MethodWithReturnValue() string
}

type MyType int  //声明一个类型，让它满足MyInterface

func (m MyType) MethodWithoutParameters() {  //第一个需要的方法
        fmt.Println(&amp;#34;MethodWithoutParameters called&amp;#34;)
}
func (m MyType) MethodWithParameter(f float64) {  //第二个需要的方法
        fmt.Println(&amp;#34;MethodWithParameter called with&amp;#34;, f)
}
func (m MyType) MethodWithReturnValue() string {  //第三个需要的方法
        return &amp;#34;Hi from MethodWithReturnValue&amp;#34;
}
func (my MyType) MethodNotInterface() {  //一个类型即使有额外的不属于接口的方法，仍可以满足接口
        fmt.Println(&amp;#34;MethodNotInterface called&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他语言中可能需要明确，MyType满足MyInterface，但在Go中是自动发生的，若一个类型包含接口中声明的所有方法，那么它可以在任何需要接口的地方使用，而不需要更多声明。&lt;/p&gt;
&lt;p&gt;测试mypkg：一个接口类型的变量能够保存任何满足接口的类型的值，下面代码声明了一个MyInterface类型的名为value的变量，然后创建一个MyType的值并赋给value，（这样可以，因为Mytype满足MyInterface），然后可以在value上调用接口的任意方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;mypkg&amp;#34;
)

func main() {
        var value mypkg.MyInterface  //声明一个接口类型的变量
        value = mypkg.MyType(5)  //MyType的值满足MyInterface，所以可以将值赋给MyInterface的变量
        value.MethodWithoutParameters()
        value.MethodWithParameter(127.3)  //可以调用MyInterface的任何方法
        fmt.Println(value.MethodWithReturnValue())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MethodWithoutParameters called
MethodWithParameter called with 127.3
Hi from MethodWithReturnValue
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;接口只是一种约定或合同，描述了某种行为（方法），任何类型只要实现了这些方法，就可以说它“满足”了这个接口，这是Go多态性的基础。不需要像其他语言中那样显式说“这个类型实现了这个接口”，如果它有正确的方法，就自动满足接口。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;类型满足接口&amp;quot;意味着可以写一个函数，它接受定义的接口作为参数，并期望该参数有其包含的方法，而不必关心这个参数的实际类型。&lt;/p&gt;
&lt;h1 id=&#34;具体类型和接口类型&#34;&gt;具体类型和接口类型&lt;/h1&gt;
&lt;p&gt;之前定义的所有类型都是具体类型，一个具体类型不仅定义了它的值可以做什么（在其上可以调用哪些方法），也定义了它们是什么：它们定义了保存值的数据的基础类型。&lt;/p&gt;
&lt;p&gt;接口类型并不描述哪个值，不会说它的基础类型是什么，或者数据如何存储，仅仅描述这个值能做什么（它有哪些方法）。&lt;/p&gt;
&lt;h1 id=&#34;分配满足接口的任何类型&#34;&gt;分配满足接口的任何类型&lt;/h1&gt;
&lt;p&gt;当有一个接口类型的变量时，它可以保存满足此接口的任何类型的值。&lt;/p&gt;
&lt;p&gt;有Whistle和Horn类型，都有MakeSound方法，可以创建一个NoiseMaker接口来代替声明了MakeSound方法的任何类型。若定义了NoiseMaker类型的toy变量，可以将Whistle和Horn值赋给它（或者之后定义的任何类型，只要它定义了MakeSound方法）。&lt;/p&gt;
&lt;p&gt;可以调用任何赋给toy变量的值的MakeSound方法，虽然并不知道toy保存的值的具体类型是什么，但我们知道它能做什么：发出声音。若它的类型没有MakeSound方法，那么不满足NoiseMaker接口，将无法赋变量它。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Whistle string

func (w Whistle) MakeSound() {  //有MakeSound方法
	fmt.Println(&amp;#34;Tweet!&amp;#34;)
}

type Horn string

func (h Horn) MakeSound() {  //同样有MakeSound方法
	fmt.Println(&amp;#34;Honk!&amp;#34;)
}

type NoiseMaker interface {  //代表任何含有MakeSound方法的类型
	MakeSound()
}

func main() {
	var toy NoiseMaker
	toy = Whistle(&amp;#34;Toyco Canary&amp;#34;)  //将一个满足NoiseMaker的类型的值赋给变量
	toy.MakeSound()
	toy = Horn(&amp;#34;Toyco Blaster&amp;#34;)  //将另一个满足NoiseMaker的类型的值赋给变量
	toy.MakeSound()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以将函数的参数定义为接口类型（毕竟函数参数也就是变量）。若声明一个play函数来接受NoiseMaker类型，可以传入任何包含了MakeSound方法的值来播放。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func play(n NoiseMaker) {
        n.MakeSound()
}

func main() {
        play(Whistle(&amp;#34;Toyco Canary&amp;#34;))
        play(Horn(&amp;#34;Toyco Blaster&amp;#34;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;只能调用接口中定义的方法&#34;&gt;只能调用接口中定义的方法&lt;/h1&gt;
&lt;p&gt;一旦给一个接口类型的变量（或方法的参数）赋值，就只能调用接口定义的方法。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
加入创建了Robot类型，除了有一个MakeSound方法外，还有一个Walk方法，在play函数中增加对Walk的调用，并将Robot的值传入play。但是代码运行失败，因为NoiseMaker值没有Walk方法。&lt;/p&gt;
&lt;p&gt;为什么会这样？Robot值的确有Walk方法，我们传入play函数的并不是Robot值，而是NoiseMaker。假如传入Whistle或者Horn呢？它们没有包含Walk方法。&lt;/p&gt;
&lt;p&gt;当有接口类型的变量时，唯一能确定的方法是接口中的方法，并且这些是Go允许调用的方法。有一种能够获取值的具体类型的方法，这样就可以调用更多特定的方法了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Whistle string

func (w Whistle) MakeSound() {
	fmt.Println(&amp;#34;Tweet!&amp;#34;)
}

type Horn string

func (h Horn) MakeSound() {
	fmt.Println(&amp;#34;Honk!&amp;#34;)
}

type Robot string //声明一个新的Robot类型

func (r Robot) MakeSound() { //Robot满足NoiseMaker接口
	fmt.Println(&amp;#34;Beep Boop&amp;#34;)
}

func (r Robot) Walk() { //一个额外的方法
	fmt.Println(&amp;#34;Powering legs&amp;#34;)
}

type NoiseMaker interface {
	MakeSound()
}

func play(n NoiseMaker) {
	n.MakeSound() //正确，NoiseMaker接口的一部分
	n.Walk()      //错误，并非NoiseMaker的一部分
}

func main() {
	play(Robot(&amp;#34;Botco Ambler&amp;#34;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;n.Walk undefined (type NoiseMaker has no field or method Walk)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用接口修复playlist函数&#34;&gt;使用接口修复playList函数&lt;/h1&gt;
&lt;p&gt;使用一个接口来允许playList函数使用两种具体类型（TapePlayer和TapeRecorder）的Play和Stop方法。&lt;/p&gt;
&lt;p&gt;在main包中，声明了一个Player接口（也可以在gadget包中定义，但是接口定义在调用的包中会更灵活），指定接口需要有一个string参数的Play方法和一个无参的Stop方法，这意味着TapePlayer和TapeRecorder类型会满足Player接口。&lt;/p&gt;
&lt;p&gt;更新playList函数来接受满足Player的任何值，而不是特定类型的TapePlayer，也更新player变量的类型，有个TapePlayer改为Player，允许将TapePlayer和TapeRecorder类型赋给player，然后将两种类型的值都传递给playList。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;xxx/xxx/gadget&amp;#34;

type Player interface {  //定义一个接口类型
        Play(string)  //要求一个接受string参数的Play方法
        Stop()  //要求一个Stop方法
}

func playList(device Player, songs []string) {  //接受任何其他的类型，而不只是TapePlayer
	for _, song := range songs {
                device.Play(song)
	}
        device.Stop()
}

func main() {
        mixtape := []string{&amp;#34;Jessie&amp;#39;s Girl&amp;#34;, &amp;#34;Whip It&amp;#34;, &amp;#34;9 to 5&amp;#34;}  //创建一个歌名的切片
        var player Player = gadget.TapePlayer{}  //修改变量的类型来保存任何Player
        playList(player, mixtape)  //给playList传入TapePlayer
        player = gadget.TapeRecorder{}
        playList(player, mixtape)   //给playList传入TapeRecorder
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;若一个类型声明了指针接收器方法，那么就只能将那个类型的指针传递给接口变量。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Switch类型的toggle方法需要使用指针类型的接收器，这样才能修改接收器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pacakge main

import &amp;#34;fmt&amp;#34;

type Switch string

func (s *Switch) toggle() {
        if *s == &amp;#34;on&amp;#34; {
                *s = &amp;#34;off&amp;#34;
	} else {
                *s = &amp;#34;on&amp;#34;
	}
        fmt.Println(*s)
}

type Toggleable interface {
        toggle()
}

func main() {
        s := Switch(&amp;#34;off&amp;#34;)
        var t Toggleable = s
        t.toggle()
        t.toggle()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是当把Switch的值赋给Toggleable的时候导致错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Switch does not implement Toggleable (toggle method has pointer receive)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go判断值是否满足一个接口的时候，指针方法并没有包含直接的值，但是它们包含指针，所以要将一个指向Switch的指针赋值给Toggleable变量，来代替一个直接Switch值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var t Toggleable = &amp;amp;s  //赋给一个指针
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;类型断言&#34;&gt;类型断言&lt;/h1&gt;
&lt;p&gt;定义了一个新的TryOut函数来测试TapePlayer和TapeRecorder类型的多种方法，TryOut有一个单独的Player接口类型的参数，这样可以传入TapePlayer类型和TapeRecorder类型。&lt;/p&gt;
&lt;p&gt;在TryOut中，调用Player接口中的Play和Stop方法，同样也调用不在Player接口中的Record方法，它定义在TapeRecorder类型中，仅仅将TapeRecorder值传入TryOut。但是，这样不对，若把一个具体类型的值赋给了接口类型的变量（包括函数参数），然后就只能在其上调用接口的方法，不管具体类型还具有何种其他方法。在TryOut函数中，没有TapeRecorder值（具体类型），只有一个Player值（接口类型），并且Player接口并没有Record方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Player interface {
        Play(string)
        Stop()
}

func TryOut(player Player) {
        player.Play(&amp;#34;Test Track&amp;#34;)
        player.Stop()
        player.Record()  //不属于Player接口
}

func main() {
        TryOut(gadget.TapeRecorder{})  //给函数传入TapeRecorder，满足Player
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;player.Record undefined (type Player has no field or method Record)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们需要一个方法来取回具体类型（确实含有Record方法）的值。&lt;/p&gt;
&lt;p&gt;若使用类型转换将Player类型的值转换为TapeRecorder类型的值，但是类型转换并不适用于接口类型，所以会产生错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TryOut(player Player) {
        player.Play(&amp;#34;Test Track&amp;#34;)
        player.Stop()
        recorder := gadget.TapeRecorder(player)  //类型转换无法工作
        recorder.Record()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cannot convert player (type Player) to type gadget.TapeRecorder: need type assertion
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当将一个具体类型的值赋给一个接口类型的变量时，&lt;code&gt;类型断言&lt;/code&gt;让你能够取回具体类型。&lt;/p&gt;
&lt;p&gt;这像是一种形式的类型转换。它的语法像函数调用和类型转换的结合体。在一个接口值之后，输入一个点，后面接着一对括号括起来的具体类型（或者是想要断言的值的具体类型）。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/11-interface/%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;简单说类型断言就像说某物像“我知道这个变量使用接口类型NoiseMaker，但我很确信这个NoiseMaker实际上是Robot。”&lt;/p&gt;
&lt;p&gt;一旦使用类型断言来取回具体类型的值，可以调用那个类型上的方法，但这方法并不属于接口。&lt;/p&gt;
&lt;p&gt;代码将Robot赋值给了NoiseMaker接口值，可以调用NoiseMaker上的MakeSound方法，因为它是接口的一部分。但是为了调用Walk方法，需要使用类型断言来取回Robot值，一旦获取了Robot（而不是一个NoiseMaker），就能调用它上面的Walk方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Robot string

func (r Robot) MakeSound() {
        fmt.Println(&amp;#34;Beep Boop&amp;#34;)
}

func (r Robot) Walk() {
        fmt.Println(&amp;#34;Powering legs&amp;#34;)
}

type NoiseMaker interface {
        MakeSound()
}

func main() {
        var noiseMaker NoiseMaker = Robot(&amp;#34;Botco Ambler&amp;#34;)  //定义一个接口类型的变量，并且将满足接口的类型值赋给它
        noiseMaker.MakeSound()  //调用接口中的方法
        var robot Robot = noiseMaker.(Robot)  //使用类型断言取回具体类型
        robot.Walk()  //调用在具体类型（而不是接口）上定义的方法
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Beep Boop
Powering legs
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;类型断言失败&#34;&gt;类型断言失败&lt;/h1&gt;
&lt;p&gt;之前TryOut函数不能在Player值上调用Record方法，因为不是Player接口的一部分；我们传入一个TapeRecorder给TryOut，被赋值给一个Player类型的参数，能够调用Player值的Play和Stop方法，因为都是Player接口的一部分。然后使用一个类型断言来将Player转换回一个TapeRecorder，并调用其上的Record方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Player interface {
        Play(string)
        Stop()
}

func TryOut(player Player) {
        player.Play(&amp;#34;Test Track&amp;#34;)
        Player.Stop()
        recorder := player.(gadget.TapeRecorder) //保存TapeRecorder值，使用类型断言来获得一个TapeRecorder值
        recorder.Record()  //调用仅仅定义在具体类型上的方法
}

func main() {
        TryOut(gadget.TapeRecorder{})
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Playing Test Track
Stopped!
Recording
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于TapeRecorder，看起来很正常，考虑到类型断言说TryOut的参数实际上是一个TapeRecorder，如果给TryOut传入TapePlayer会如何呢？&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        TryOut(gadget.TapeRecorder{})
        TryOut(gadget.TapePlayer{})  //传入一个TapePlayer
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当运行时，得到一个运行时异常，尝试断言TapePlayer是一个TapeRecorder无法工作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: interface conversion: main.Player is gadget.TapePlayer, not gadget.TapeRecorder
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;当类型断言失败时避免异常&#34;&gt;当类型断言失败时避免异常&lt;/h1&gt;
&lt;p&gt;如果类型断言被用于仅有一个返回值的情况，并且原始的类型不与断言的类型相同，程序会在运行时（不在编译时）出现异常：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var player Player = gadget.TapePlayer{}
recorder := player.(gadget.TapeRecorder)  //断言原类型是TapeRecorder，但它实际上是TapePlayer
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: interface conversion: main.Player is gadget.TapePlayer, not gadget.TapeRecorder
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果类型断言被用于期待多个返回值的情况，能有第二个可选的返回值来表明断言是否成功。（并且断言并不会在不成功时出现异常。）第二个值是一个bool，并且当原类型和断言类型相同时，返回true，否则返回false。可以对第二个返回值做任何操作，但按惯例，通常被赋给一个名为ok的变量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var player Player = gadget.TapePlayer{}
recorder, ok := player.(gadget.TapeRecorder)  //将第二个返回值赋给ok变量
if ok {
        recorder.Record()  //如果原始类型是TapeRecorder，调用值上的Record
} else {
        fmt.Println(&amp;#34;Player was not a TapeRecorder&amp;#34;)  //否则报告断言失败
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体类型是TapePlayer，而不是TapeRecorder，所以断言失败，ok返回是false，if语句的else执行，一个运行时异常被避免。&lt;/p&gt;
&lt;p&gt;当使用类型断言时，如果不能完全确定接口的原类型是什么，应该使用可选ok值来处理与期望的类型不同的情况，避免一个运行时异常。&lt;/p&gt;
&lt;h1 id=&#34;使用类型断言测试tapeplayer和taperecorder&#34;&gt;使用类型断言测试TapePlayer和TapeRecorder&lt;/h1&gt;
&lt;p&gt;接下来修复TryOut函数以适应TapePlayer和TapeRecorder值，与忽略类型断言的第二个返回值不同，我们将它赋值给一个ok变量，如果类型断言成功，ok变量会为true（标识recorder变量保存了一个TapeRecorder值，准备调用Record方法），否则为false（标识调用Record不安全）。将Record方法的调用包裹在if语句中来确保它仅仅在类型断言成功的情况下才会被调用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Player interface {
        Play(string)
        Stop()
}

func TryOut(player Player) {
        player.Play(&amp;#34;Test Track&amp;#34;)
        player.Stop()
        recorder, ok := player.(gadget.TapeRecorder)  //将第二个返回值赋给变量
	if ok {  //仅仅在原值是TapeRecorder的时候调用Record方法
                recorder.Record()
	}
}

func main() {
        TruOut(gadget.TapeRecorder{})
        TryOut(gadget.TapePlayer{})
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Playing Test Track  //TapeRecorder被传入
Stopped!
Recording  //类型断言成功，Record被调用
Playing Test Track  //TapePlayer被传入
Stopped!  //类型断言未成功，Record没有被调用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与之前一样，在main方法中，首先传入了TapeRecorder值调用TryOut，TryOut获取传入的Player接口值，并调用Play和Stop方法。Player的值的具体类型是TapeRecorder的断言成功了，然后Record方法在TapeRecorder值上被调用。然后传入TapePlayer调用TryOut，这个调用在之前程序中停止，因为类型断言异常。Play和Stop被调用，类型断言失败，因为Player值保存着TapePlayer而不是TapeRecorder，因为捕获了ok值中的第二个返回值，类型断言不会导致异常，因为仅仅将ok值设置为false，导致if语句中的代码不被执行，也就导致了Record没有被调用。（因为TapePlayer值没有Record方法）&lt;/p&gt;
&lt;h1 id=&#34;error接口&#34;&gt;error接口&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;一个错误值就是任何含有名为Error的方法的值，此方法返回string&lt;/code&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type error interface {
        Error() string
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;声明一个接口的error类型意味着，若具有一个返回string的Error方法，就满足error接口，并且它是error的值。这意味着能定义自己的类型并用在任何需要error值的地方。&lt;/p&gt;
&lt;p&gt;ComedyError类型，有返回string的Error方法，满足error接口，就能将它赋值给error类型的变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type ComedyError string  //定义一个以string为基础类型的类型
func (c ComedyError) Error() string {  //满足error接口
        return string(c)  //Error方法需要返回一个string，所以做个类型转换
}

func main() {
        var err error  //声明一个error类型的变量
        err = ComedyError(&amp;#34;What&amp;#39;s a programmer&amp;#39;s favorite beer? Logger!&amp;#34;)  //ComedyError满足error接口，所能把它赋值给变量
        fmt.Println(err)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要一个error值，也需要追踪除了错误信息字符串之外更多的信息，可以创建自己的满足error接口的类型并保存需要的信息。&lt;/p&gt;
&lt;p&gt;例：有一个程序监控一些设备保证它们不会过热。
这个OverheatError类型可能游泳，有个确保满足error的Error方法，它使用float64作为基础类型，允许追踪过载的温度。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type OverheatError float64  //定义一个基础类型是float64的类型
func (o OverheatError) Error() string {  //满足error接口
        return fmt.Sprintf(&amp;#34;OverheatError by %0.2f degrees!&amp;#34;, o)  //在错误信息中使用温度
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有个使用OverheatError的checkTemperature函数，接收系统实际温度和被认为是安全的温度作为参数，指定返回一个error类型的值，而不是OverheatError，但因为它满足error接口，若actual温度超过了safe温度，checkTemperature返回一个新的记录了超出量的OverheatError：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func checkTemperature(actual float64, safe float64) error {  //指定函数返回原生error值
        excess := actual - safe
        if excess &amp;gt; 0 {  //如果actual温度高于safe温度
                return OverheatError(excess)  //就返回一个记录了超出量的OverheatError
        }
        return nil
}

func main() {
        var err error = checkTemperature(121.379, 100.0)
        if err != nil {
                log.Fatal(err)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;为什么可以在不同的包中使用error接口而不用导入？以小写字母开头？&lt;/p&gt;
&lt;p&gt;error类型像int或string一样是一个“预定义标识符”，不属于任何包，是“全局块”的一部分，能在任何地方使用，无需考虑当前包信息。&lt;/p&gt;
&lt;h1 id=&#34;stringer接口&#34;&gt;Stringer接口&lt;/h1&gt;
&lt;p&gt;fmt包定义了fmt.Stringer接口：允许任何类型决定在输出时如何展示，让其他类型满足Stringer接口很简单，只需要定义一个返回string类型的方法。&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Stringer interface {
        String() string
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如，我们建立了一个CoffeePot类型来满足Stringer：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type CoffeePot string

func (c CoffeePot) String() string {  //满足Stringer接口
        return string(c) + &amp;#34; coffee pot&amp;#34;  //方法需要返回一个string
}

func main() {
        coffeePot := CoffeePot(&amp;#34;LuxBrew&amp;#34;)
        fmt.Println(coffeePot.String())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;许多在fmt包中的函数都会判断传入的参数是否满足stringer接口，若满足就调用String方法，这些函数包括Print、Println和Printf等，CoffeePot满足了Stringer，可以把CoffeePot值直接传入这些函数，并且CoffeePot的String方法的返回值会在输出时使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;coffeePot ：= CoffeePot(&amp;#34;LuxBrew&amp;#34;)  //创建一个CoffeePot值
fmt.Print(coffeePot, &amp;#34;\n&amp;#34;)
fmt.Println(coffeePot)
fmt.Printf(&amp;#34;%s&amp;#34;, coffeePot)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;LuxBrew coffee pot  //String方法的返回值在输出中使用
LuxBrew coffee pot
LuxBrew coffee pot
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;空接口&#34;&gt;空接口&lt;/h1&gt;
&lt;p&gt;我们接触的大多数函数，只能使用指定的类型来调用，但是fmt.Println这样的fmt函数却能接受任何类型，这是怎么做到的？&lt;/p&gt;
&lt;p&gt;来看下go doc： &lt;code&gt;go doc fmt Println&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是一个可变参数的函数，意味着它可以接受任何个数的参数；接口声明定义了方法，类型必须实现这个方法才能满足接口。若定义一个不需要任何方法的接口，它会被任何类型满足。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Interface{}&lt;/code&gt;类型称为空接口，用来接受任何类型的值，不需要实现任何方法来满足空接口，所有的类型都满足空接口。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Anything interface {}

func AcceptAnything(thing interface{}) {
}

func main() {
        AcceptAnything(123.123)
        AcceptAnything(&amp;#34;A string&amp;#34;)
        AcceptAnything(true)
        AcceptAnything(Whistle(&amp;#34;xxxxxx&amp;#34;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先不要对所有的函数使用空接口，若有一个空接口类型的值，无法做任何操作。&lt;/p&gt;
&lt;p&gt;不要尝试在空接口值上调用任何函数，如果有一个接口类型的值，只能调用接口上的方法。空接口没有任何方法，意味着没法调用空接口类型值的任何方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func AcceptAnything(thing interface{}) {
        fmt.Println(thing)
        thing.MakeSound()  //尝试在空接口值上调用方法
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;thing.MakeSound undefined (type interface {} is interface with no mehtods)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了在空接口类型的值上调用方法，需要使用类型断言来获得具体类型的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func AcceptAnything(thing interface{}) {
        fmt.Println(thing)
        whistle, ok := thing.(Whistle)  //使用类型断言来获得Whistle
	if ok {
                whistle.MakeSound()  //调用Whistle上的方法
	}
}

func main() {
        AcceptAnything(3.1415)
        AcceptAnything(Whistle(&amp;#34;Toyco Canary&amp;#34;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最好写一个接收特定具体类型的函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func AcceptWhistle(whistle Whistle) {  //接收Whistle
        fmt.Println(whistle)
        whistle.MakeSound()  //调用方法，不需要类型转换
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>10.保密：封装和嵌入</title>
      <link>https://tinklespring.com/posts/10.%E4%BF%9D%E5%AF%86%E5%B0%81%E8%A3%85%E5%92%8C%E5%B5%8C%E5%85%A5/</link>
      <pubDate>Mon, 07 Aug 2023 16:27:10 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/10.%E4%BF%9D%E5%AF%86%E5%B0%81%E8%A3%85%E5%92%8C%E5%B5%8C%E5%85%A5/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;有时，程序会接收到无效的数据，从用户输入、文件读取或其他方式。&lt;code&gt;封装&lt;/code&gt;：一个保护string字段免受无效数据的方法。这样，数据字段能够安全使用。&lt;br&gt;
也会在类型内部嵌入其他的类型，若struct类型需要已经存在于其他类型的方法，不需要赋值方法代码，可以将其嵌入struct类型中，然后像使用自己的类型的定义方法一样使用嵌入的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;创建一个日期struct类型&#34;&gt;创建一个日期struct类型&lt;/h1&gt;
&lt;p&gt;在struct中增加Year、Month、Day字段，每个都是int类型，在main函数中，将执行一个快速的测试来测试新类型，使用struct字面量来创建一个Date值，并填充所有字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Date struct {
        Year  int
        Month int
        Day   int
}

func main() {
        date := Date{Year: 2023, Month: 8, Day: 10}
        fmt.Println(date)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;将date-struct字段设置为无效值&#34;&gt;将Date struct字段设置为无效值&lt;/h1&gt;
&lt;p&gt;用户将日期格式设置的很奇怪，比如：&amp;ldquo;2023 14 50&amp;rdquo; 或 &amp;ldquo;0 0 -2&amp;rdquo; 等，我们知道只有1以上的年的数字才合法，但程序没做任何措施预防用户把日志以外设置为0或-999，月份也只有1-12合法，日只有1-31合法。&lt;/p&gt;
&lt;p&gt;需要一种方法，让用户数据在被赋值之前是合法的，在CS领域中，被称为&lt;code&gt;数据校验&lt;/code&gt;，需要测试Year被设置为大于或等于1，Month被设置为1-12，Day被设置为1-31。&lt;/p&gt;
&lt;h1 id=&#34;setter方法&#34;&gt;setter方法&lt;/h1&gt;
&lt;p&gt;一个struct类型就是另一个定义的类型，可以像对其他类型一样定义它的方法。可以在Date类型上创建 SetYear、SetMonth、SetDay方法来接收值，判断是否有效，若有效则设置到struct字段。&lt;/p&gt;
&lt;p&gt;这类方法被称为 &lt;code&gt;setter方法&lt;/code&gt; , Go的setter方法名为&lt;code&gt;SetX&lt;/code&gt;的形式，X 是想要设置的名称。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setter 方法 是用来设置字段或基础类型中的其他值的方法。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在SetYear方法上进行第一次尝试，接收器参数是Date struct，SetYear接受想要设置的年份作为参数，并设置接收器Date struct上的Year字段，此时并不校验值有效性。在main方法中创建Date并调用SetYear，然后输出struct的Year字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Date struct {
        Year  int
        Month int
        Day   int
}

func (d Date) SetYear(year int) {
        d.Year = year    //设置struct字段
}

func main() {
        date := Date{}  //创建一个Date
        date.SetYear(2023)  //通过方法设置Year字段
        fmt.Println(date.Year)  //打印Year字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当执行时，并没有正常工作，创建了一个Date并使用新值调用了它的setYear方法，Year字段仍被设置为零值。&lt;/p&gt;
&lt;h1 id=&#34;setter方法需要指针接收器&#34;&gt;setter方法需要指针接收器&lt;/h1&gt;
&lt;p&gt;之前Number类型上的Double方法，使用了一个普通的值接收器类型Number，像其他参数一样，接收器参数接受了一个原值的拷贝，Double方法只是更新了拷贝，在方法退出时更新就丢失了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (n *Number) Double() {   //接收器类型为一个指针类型
        *n *= 2  //修改指针指向的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要更新Double来接受指针的接收器类型 &lt;code&gt;*Number&lt;/code&gt; ，当更新指针指向的值的时候，在Double退出后更新会保留。&lt;/p&gt;
&lt;p&gt;同样，SetYear也适用，Date接收器从原struct获取了一个拷贝，任何字段更新都在setYear退出后消失。&lt;/p&gt;
&lt;p&gt;通过将接收器的值修改为指针来修正，不需要更新SetYear方法块，因为 d.Year 会自动获取指针指向的值（与&lt;code&gt;(*d).Year&lt;/code&gt; 一样），main函数中的date.SetYear也不需要修改，因为当Date值传递给方法的时候，会自动转换为 &lt;code&gt;*Date&lt;/code&gt; 。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Date struct {
        Year  int
        Month int
        Day   int
}

func (d *Date) SetYear(year int) {
        d.Year = year
}

func main() {
        date := Date{}
        date.SetYear(2023)  //自动转换为指针
        fmt.Println(date.Year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;添加其余的setter方法&#34;&gt;添加其余的setter方法&lt;/h1&gt;
&lt;p&gt;按照这个模式在Date类型上定义SetMonth和SetDay方法，只需要在方法中使用指针接收器即可，在调用方法时，Go会自动把接收器转换为指针，并在修改struct字段时能够把指针转换回struct值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Date struct {
	Year  int
	Month int
	Day   int
}

func (d *Date) SetYear(year int) {
	d.Year = year
}

func (d *Date) SetMonth(month int) {
	d.Month = month
}

func (d *Date) SetDay(day int) {
	d.Day = day
}

func main() {
	date := Date{}
	date.SetYear(2023)
	date.SetMonth(5)
	date.SetDay(27)
	fmt.Println(date)  //输出所有字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在main函数中，创建了一个Date struct的值，通过新的方法设置了它的Year、Month和Day字段，并输出了整个struct查看结果。&lt;/p&gt;
&lt;h1 id=&#34;在setter方法中添加校验&#34;&gt;在setter方法中添加校验&lt;/h1&gt;
&lt;p&gt;在每个setter方法中，将测试值是否在正确合法范围内，若非法，返回error值，若合法，将正常设置 Date struct字段，并返回nil作为错误值。&lt;/p&gt;
&lt;p&gt;首先对SetYear方法增加校验，修改方法的声明，增加一个error类型的返回值，在方法块的开始处，测试调用者传入的year参数是否小于1，若小于1，返回一个error信息，若大于等于1，将其设置为struct的Year字段并返回nil，表示没有错误。&lt;/p&gt;
&lt;p&gt;在main函数中，调用SetYear并把返回值保存到名为err的变量中，若err不为nil，意味着赋值无效，所以记录错误并退出，否则继续输出Date struct的Year字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;errors&amp;#34; //允许创建error值
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34; //允许记录error并退出
)

type Date struct {
	Year  int
	Month int
	Day   int
}

func (d *Date) SetYear(year int) error { //增加一个error类型的返回值
	if year &amp;lt; 1 {
		return errors.New(&amp;#34;invalid year&amp;#34;) //若year是非法的，返回错误
	}
	d.Year = year
	return nil
}

func main() {
	date := Date{}
	err := date.SetYear(0) //抓捕任何错误
	if err != nil {
		log.Fatal(err)  //若值无效记录错误并退出
	}
	fmt.Println(date.Year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023/08/10 16:56:33 invalid year
exit status 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;传入一个无效的值给SetYear导致程序报错并退出，但若传入有效值，程序会继续输出，SetYear方法工作正常。&lt;/p&gt;
&lt;p&gt;SetMonth 与 SetDay 方法中的校验代码与SetYear类似：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (d *Date) SetYear(year int) error { //增加一个error类型的返回值
	if year &amp;lt; 1 {
		return errors.New(&amp;#34;invalid year&amp;#34;) //若year是非法的，返回错误
	}
	d.Year = year
	return nil
}

func (d *Date) SetMonth(month int) error {
	if month &amp;lt; 1 || month &amp;gt; 12 {
		return errors.New(&amp;#34;invalid month&amp;#34;)
	}
	d.Month = month
	return nil
}

func (d *Date) SetDay(day int) error {
	if day &amp;lt; 1 || day &amp;gt; 31 {
		return errors.New(&amp;#34;invalid day&amp;#34;)
	}
	d.Day = day
	return nil
}

func main() {
        //try
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在SetMonth中，测试提供的月份值，若小于1或大于12，就返回错误，否则设置字段并返回nil。&lt;/p&gt;
&lt;p&gt;在SetDay中，测试提供的日期小于1或大于31，返回错误，有效值设置字段并返回nil。&lt;/p&gt;
&lt;h1 id=&#34;字段仍可以设置为无效值&#34;&gt;字段仍可以设置为无效值&lt;/h1&gt;
&lt;p&gt;使用setter方法，提供校验很不错，但是用户可以直接设置struct字段，仍然能设置无效值。&lt;/p&gt;
&lt;p&gt;没有任何方法能阻止直接设置Date struct字段，若这么做，就会绕过setter方法中的校验代码。&lt;/p&gt;
&lt;p&gt;需要一个方式来保护这些字段，让Date类型只能使用setter方法来更新字段，Go提供了一个方式：&lt;code&gt;把Date类型移动到另一个包，并将数据字段设置为非导出的&lt;/code&gt;。未导出的变量、函数等在大多数情况下无法导出，即使之前的magazine包中的Subscriber struct类型被导出(字段首字母非大写)，但是它的字段并未被导出，导致在magazine包之外无法访问。&lt;/p&gt;
&lt;h1 id=&#34;将date类型移动到另外的包中&#34;&gt;将Date类型移动到另外的包中&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

import &amp;#34;errors&amp;#34;

type Date struct {
	year  int
	month int
	day   int
}  //将字段名称修改为小写字母让其不可被导出

func (d *Date) SetYear(year int) error {
	if year &amp;lt; 1 {
		return errors.New(&amp;#34;invalid year&amp;#34;)
	}
	d.year = year //更新字段名称匹配声明
	return nil
}

func (d *Date) SetMonth(month int) error {
	if month &amp;lt; 1 || month &amp;gt; 12 {
		return errors.New(&amp;#34;invalid month&amp;#34;)
	}
	d.month = month //更新字段名称匹配声明
	return nil
}

func (d *Date) SetDay(day int) error {
	if day &amp;lt; 1 || day &amp;gt; 31 {
		return errors.New(&amp;#34;invalid day&amp;#34;)
	}
	d.day = day  //更新字段名称匹配声明
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改main包：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/calendar&amp;#34;
)

func main() {
        date := calendar.Date{}
        date.year = 2023
        date.month = 14
        date.day = 50
        fmt.Println(date)

        date = calendar.Date{year: 0, month: 0, day: -2}
        fmt.Println(date)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Date的字段未导出，从main包中访问，会导致编译错误。&lt;/p&gt;
&lt;h1 id=&#34;通过导出的方法访问未导出的字段&#34;&gt;通过导出的方法访问未导出的字段&lt;/h1&gt;
&lt;p&gt;可以间接访问字段。未导出的变量、struct字段、函数、方法等仍然能被相同包的导出的函数或者方法访问。所以当mian包中的代码在Date值上调用导出方法SetYear时，SetYear可以修改Date的year字段，即使year是未导出的。导出方法SetYear可以更新未导出的month字段等。&lt;/p&gt;
&lt;p&gt;修改main包来使用setter方法，可以更新Date值的字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/calendar&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        date := calendar.Date{}
        err := date.SetYear(2023)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetMonth(5)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetDay(27)
        if err != nil {
                log.Fatal(err)
        }
        fmt.Println(date)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{2023 5 27}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;未导出的变量、struct字段、函数、方法等仍然能够被相同包的导出的函数或方法访问。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时若传入无效值，执行时会得到错误。&lt;/p&gt;
&lt;p&gt;现在的Date值的字段只能通过setter方法更新，程序被保护，避免意外输出无效数据。&lt;/p&gt;
&lt;h1 id=&#34;getter方法&#34;&gt;getter方法&lt;/h1&gt;
&lt;p&gt;将值设置给struct字段或者变量的方法称为 &lt;code&gt;setter&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;获取struct字段或者变量的值的方法称为 &lt;code&gt;getter&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;按照惯例，getter方法的名称应该与访问的字段或者变量的名字相同。（若希望方法被导出，首字母应该大写。）所以Date需要一个Year方法来访问year字段，Month方法来访问month字段，Day方法来访问day字段。&lt;/p&gt;
&lt;p&gt;getter方法不需要修改接收器，直接使用Date的值作为接收器。若类型的任何方法接受接收器指针类型，为了一致性，通常所有的方法都应该这样做。由于必须对所有的setter方法使用接收器指针，也应对所有的getter方法使用指针。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

import &amp;#34;errors&amp;#34;

type Date struct {
	year  int
	month int
	day   int
}

func (d *Date) Year() int {  //与setter方法一致，使用一个接收器指针类型；Year与字段名称相同，为了导出首字母大写。
	return d.year   //返回字段值
}

func (d *Date) Month() int {
	return d.month
}

func (d *Date) Day() int {
	return d.day
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改main：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        date := calendar.Date{}
        err := date.SetYear(2023)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetMonth(5)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetDay(27)
        if err != nil {
                log.Fatal(err)
        }
        fmt.Println(date.Year())
        fmt.Println(date.Month())
        fmt.Println(date.Day())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出(getter方法返回的值)：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023
5
27
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;封装&#34;&gt;封装&lt;/h1&gt;
&lt;p&gt;将程序中的数据隐藏在一部分代码中而对另一部分不可见的方法称为&lt;code&gt;封装&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;封装可以用来防止无效数据，同样也可以修改程序代码的封装部分，而不用担心其他代码的访问，因为它们不可直接访问。&lt;/p&gt;
&lt;p&gt;许多其他编程语言用类进行封装，类与Go的类型概念类似，但不完全相同，在Go中使用未导出的变量、struct字段、函数或者方法，把数据封装在包中。&lt;/p&gt;
&lt;p&gt;Go通常在需要的时候才使用封装，不需要封装一个字段，通常导出并且允许直接访问。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;问：其他语言不允许在定义封装的值的类之外访问该值，Go允许包内其他代码访问未导出代码是否安全？&lt;br&gt;
答：通常一个包内的所有代码是一个开发者（或一组开发者）开发，包里所有的代码通常有相似的目的，相同包的代码的作者有可能需要访问未导出数据，并且有可能只用合理的方式来使用数据，所以在包内共享未导出数据是安全的。包外的代码有可能是其他开发者编写，但未导出代码是隐藏的，不会意外将其值改为无效数据。&lt;/p&gt;
&lt;p&gt;问：其他语言所有getter方法的名字都以“Get”开头，比如GetName、GetCity等，在go中是否可以这样做？&lt;br&gt;
答：Go允许这样做，但不推荐。Go社区大会讨论后决定在getter方法前面去掉Get前缀，保留它只会让后继者感到困惑。Go仍然对setter方法使用Set前缀，因为需要区分同一个字段的setter方法和getter方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;练习：&lt;/p&gt;
&lt;p&gt;要求：
1.字段未导出&lt;br&gt;
2.为每个字段增加一个getter方法（遵守约定：一个getter方法应该与它访问的字段名称相同，若需要导出，首字母大写）&lt;br&gt;
3.为setter方法增加校验，SetLatitude若接收到小于-90或大于90的值返回错误，Setlongitude若接收到小于-180大于180的值返回错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package geo

import &amp;#34;errors&amp;#34;

type Coordinates struct {
	latitude  float64
	longitude float64 //字段需要未导出的
}

func (c *Coordinates) Latitude() float64 { //getter方法名应该与字段名相同，但是首字母需要大写；返回与字段类型相同
	return c.latitude
}

func (c *Coordinates) Longitude() float64 {
	return c.longitude
}

func (c *Coordinates) SetLatitude(latitude float64) error { //需要返回错误类型
	if latitude &amp;lt; -90 || latitude &amp;gt; 90 {
		return errors.New(&amp;#34;invalid latitude&amp;#34;) //返回一个新的错误值
	}
	c.latitude = latitude
	return nil //如果没有错误返回nil
}

func (c *Coordinates) SetLongitude(longitude float64) error {
	if longitude &amp;lt; -180 || longitude &amp;gt; 180 {
		return errors.New(&amp;#34;invalid longitude&amp;#34;)
	}
	c.longitude = longitude
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;main 包代码要求：
1.遍历每个settter方法，保存error返回值&lt;br&gt;
2.若error不为nil，使用log.Fatal函数记录错误并退出&lt;br&gt;
3.若设置字段没有错误，调用所有getter方法输出字段值&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;geo&amp;#34;
	&amp;#34;log&amp;#34;
)

func main() {
	coordinates := geo.Coordinates{}
	err := coordinates.SetLatitude(37.42) //保存返回的错误值
	if err != nil {                       //若有错误，记录并返回
		log.Fatal(err)
	}
	err = coordinates.SetLongitude(-1122.08) //一个无效值
	if err != nil {                          //若有错误记录并返回
		log.Fatal(err)
	}
	fmt.Println(coordinates.Latitude())
	fmt.Println(coordinates.Longitude()) //getter方法
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在event类型中嵌入date类型&#34;&gt;在Event类型中嵌入Date类型&lt;/h1&gt;
&lt;p&gt;Date类型很棒，setter方法确保了只有合法的数据才能设置字段，getter方法让我们能取回这些值，现在只需给事件分配标题。&lt;/p&gt;
&lt;p&gt;定义一个Event类型，并内嵌一个Date作为匿名字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

type Event struct {
        Title string
        Date   //使用一个匿名字段嵌入Date
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在calendar包中创建另外一个文件，名为event.go（将把它放到已存在的date.go），在那个文件中，定义一个含有两个字段的类型：一个string类型的Title字段和一个匿名的Date字段。&lt;/p&gt;
&lt;h1 id=&#34;未导出的字段不会被提升&#34;&gt;未导出的字段不会被提升&lt;/h1&gt;
&lt;p&gt;将Date嵌入到Event类型中并不会导致Date的字段被提升到Event，Date字段是未导出的，并且Go不会将未导出的字段提升到封闭类型。确认字段被封装，就只能够被setter 方法和getter方法访问，不希望封装被字段提升绕开。&lt;/p&gt;
&lt;p&gt;在main包中，若尝试通过包裹它的Event设置Date中的month字段，会得到错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;xxx/xxx/calendar&amp;#34;

func main() {
        event := calendar.Event{}
        event.month = 5  //未导出的Date字段并没有提升到Event
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        event := calendar.Event{}
        event.Date.year = 2023
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用点运算符链来返回Date字段并且直接访问其中的字段也无法工作，不能单独访问一个Date的未导出字段，当Date是Event的一部分的时，也不能访问Event中Date未导出的字段。&lt;/p&gt;
&lt;h1 id=&#34;导出的方法像字段一样被提升&#34;&gt;导出的方法像字段一样被提升&lt;/h1&gt;
&lt;p&gt;若嵌入了一个具有导出方法的struct类型，它的方法会被提升到外部类型，意味着可以调用这个方法，就像在外部类型上定义了该方法一样。&lt;/p&gt;
&lt;p&gt;有一个定义了两种类型的包，MyType是一个struct类型，其中嵌入了第二个类型EmbeddedType，是一个匿名字段：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package mypackage  //类型在它们自己的包中

import &amp;#34;fmt&amp;#34;

type MyType struct {  //声明MyType是一个struct类型
        EmbeddedType  //EmbeddedType是一个嵌入MyType的类型
}

type EmbeddedType string  //声明一个被嵌入的类型（并不在意它是否是个struct）

func (e EmbeddedType) ExportedMethod() {  //这个方法会被提升至MyType
        fmt.Println(&amp;#34;Hi from ExportedMethod on EmbeddedType&amp;#34;)
}

func (e EmbeddedType) unexportedMethod() {  //这个方法不会被提升

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为EmbeddedType定义了一个导出的方法（名为ExportedMethod），这个类型被提升到MyType，并可以被MyType值所调用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;mypackage&amp;#34;

func main() {
        value := mypackage.MyType{}
        value.ExportedMethod()  //调用从EmbeddedType提升的方法
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于未导出的字段，未导出的方法没有被提升，若尝试调用，会得到一个错误。&lt;/p&gt;
&lt;p&gt;Date字段不会被提升到Event类型，因为它们未导出，但是Date上的getter和setter方法被导出了，它们提升到了Event类型。&lt;/p&gt;
&lt;p&gt;意味着我们可以创建一个Event值，并在Event值上直接调用Date的getter和setter方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/calendar&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        event := calendar.Event{}
        err := event.SetYear(2023)
        if err != nil {
                log.Faltal(err)
        }
        err = event.SetMonth(5)
        if err != nil {
                log.Faltal(err)
        }
        err = event.SetDay(27)
        if err != nil {
                log.Faltal(err)
        }
        fmt.Println(event.Year())
        fmt.Println(event.Month())
        fmt.Println(event.Day())  //这个Date的getter方法被提升到了Event
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，也可以使用运算符链来调用Date值上的方式：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(event.Date.Year())
fmt.Println(event.Date.Month())
fmt.Println(event.Date.Day())   //获取Event的Date字段，然后调用其getter方法
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;封装event的title字段&#34;&gt;封装Event的Title字段&lt;/h1&gt;
&lt;p&gt;由于Event struct的Title字段被导出，仍然可以直接访问它。&lt;/p&gt;
&lt;p&gt;这会面临与之前Date字段相同的问题，例如，Title字符串没有长度限制：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        event := calendar.Event{}
        event.Title = &amp;#34;An extremely long title that is impractical to print&amp;#34;
        fmt.Println(event.Title)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将Title字段封装起来，这样就能校验新的值，将其命名为title，然后增加setter和getter方法，来自 unicode/utf8 包中的RuneCountInString函数被用来确保string中没有过多的字符。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

import (
        &amp;#34;errors&amp;#34;
        &amp;#34;unicode/utf8&amp;#34;
)

type Event struct {
        title string  //修改为非导出
        Date
}

func (e *Event) Title() string {   //getter方法
        return e.title
}

func (e *Event) SetTitle(title string) error {  //setter方法
	if utf.RuneCountInString(title) &amp;gt; 30 {
                return errors.New(&amp;#34;invalid title&amp;#34;)
	}
        e.title = title
        return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;提升的方法与外部类型的方法共存&#34;&gt;提升的方法与外部类型的方法共存&lt;/h1&gt;
&lt;p&gt;现在已经为title字段添加了getter和setter方法，若title长度超过30个字符，会返回错误。&lt;/p&gt;
&lt;p&gt;Event类型的Title和SetTitle方法与从嵌入的Date类型提升的方法一同存在，导入calendar包的代码可以让所有的方法被视为属于Event类型，而不用考虑它们真正定义在哪个类型上。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        event := calendar.Event{}
        err := event.SetTitle(&amp;#34;Mom&amp;#39;s birthday&amp;#34;)  //定义在Event上
        if err != nil {
                log.Fatal(err)
        }
        err = event.SetYear(2023)  //从Date提升
        if err != nil {
                log.Fatal(err)
        }
        err = event.SetMonth(5)  //从Date提升
        if err != nil {
                log.Fatal(err)
        }
        err = event.SetDay(27)  //从Date提升
        if err != nil {
                log.Fatal(err)
        }
        fmt.Println(event.Title())  //Event自己定义的
        fmt.Println(event.Year())   //从Date提升
        fmt.Println(event.Month())  //从Date提升
        fmt.Println(event.Day())    //从Date提升
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;现在能在Event上直接调用Title和SetTitle方法，并调用方法设置年月日就像它们是属于Event一样，它们实际上是在Date上定义的，但我们不需要关心。&lt;/p&gt;
&lt;p&gt;方法提升允许使用其他类型的方法就像使用自己的一样，可以用这个来组合类型，该类型组合了多种其他类型的方法，这可以帮助保持代码整洁，且不牺牲便利性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>9.定义类型</title>
      <link>https://tinklespring.com/posts/9.%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 05 Aug 2023 12:28:25 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/9.%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本篇展示使用任意类型作为基础类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;具有底层基础类型的定义类型&#34;&gt;具有底层基础类型的定义类型&lt;/h1&gt;
&lt;p&gt;Go经常使用 struct 作为基础类型来定义类型，但也能基于 int、string、bool或其他任何类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Liters float64
type Gallons float64  //定义两个新类型，基础类型都是float64

func main() {
        var carFuel Gallons
        var busFuel Liters
        carFuel = Gallons(10.0)   //把float64转换为Gallons
        busFuel = Liters(240.0)   //把float64转换为Liters
        fmt.Println(carFuel, busFuel)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一旦定义一个类型，可以把任何基础类型的值转换为定义的类型，像其他类型转换一样，写下需要转换到的类型，后面跟着小括号中的希望转换的值。&lt;/p&gt;
&lt;p&gt;若需要，上面代码中可以使用短变量声明:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;carFuel := Gallons(10.0)
busFuel := Liters(240.0)  //与类型转换同时使用短变量声明
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若变量使用了已定义的类型，不能把另一个类型的值赋给它，即使另一个类型也具有相同的基础类型。&lt;/p&gt;
&lt;p&gt;但是可以在具有相同基础类型的类型之间转换，Liters可以与Gallons互相转换，因为其基础类型都是float64，但是Go只在转换时考虑基础类型的值，Gallons(Liters(240.0)) 与 Liters(Gallons(240.0)) 没有区别，简单地把值从一个类型转换到另一个类型使针对这个类型应该出现的错误保护机制失效。&lt;/p&gt;
&lt;p&gt;升与加仑转换：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;carFuel = Gallons(Liters(40.0) * 0.264)
busFuel = Liters(Gallons(63.0) * 3.785)
fmt.Printf(&amp;#34;Gallons: %0.1f Liters: %0.1f\n&amp;#34;, carFuel, busFuel)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;定义类型和运算符&#34;&gt;定义类型和运算符&lt;/h1&gt;
&lt;p&gt;一个定义类型提供与所有基础类型相同的运算，基于float64类型，提供算数运算符&lt;code&gt;+、-、*、/&lt;/code&gt;，也提供比较运算&lt;code&gt;==、&amp;gt;、&amp;lt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;并且基于基础类型string的类型，支持&lt;code&gt;+、==、&amp;gt;、&amp;lt;&lt;/code&gt;，但是不支持&lt;code&gt;-&lt;/code&gt;，因为 - 对于string不是合法的运算符。&lt;/p&gt;
&lt;p&gt;一个定义类型可以被用来与字面值一起运算：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(Liters(1.2) + 3.4)
fmt.Println(Gallons(5.5) - 2.2)
fmt.Println(Gallons(1.2) == 1.2)
fmt.Println(Liters(1.2) &amp;lt; 3.4)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;4.6
3.3
true
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义类型不能用来与不同类型的值一起运算，即使它们来自相同的基础类型。若想要将一个Liters中的值与Gallons中的值作运算，需要将其中一个类型转换为另一个类型。&lt;/p&gt;
&lt;h1 id=&#34;使用函数进行类型转换&#34;&gt;使用函数进行类型转换&lt;/h1&gt;
&lt;p&gt;让不同类型的值一起运算，需要进行类型转换：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;carFuel = Gallons(Liters(40.0) * 0.264)
busFuel = Liters(Gallons(63.0) * 3.785)

	func ToGallons(l Liters) Gallons {
                return Gallons(l * 0.364)
	}

        func ToLiters(g Gallons) Liters {
                return Liters(g * 3.785)
        }

        func main() {
                carFuel := Gallons(1.2)
                busFuel := Liters(4.5)
                carFuel += ToGallons(Liters(40.0))   //先将Liters转换为Gallons
                busFuel += ToLiters(Gallons(30.0))   //先将Gallons转换为Liters
                fmt.Printf(&amp;#34;Car fuel: %0.1f gallons\n&amp;#34;, carFuel)
                fmt.Printf(&amp;#34;Bus fuel: %0.1f liters\n&amp;#34;, busFuel)
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Car fuel: 11.8 gallons
Bus fuel: 118.1 litters
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;增加一个新类型，Milliliters：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Liters float64
type Milliliters float64
type Gallons float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也需要将Milliliters类型进行转换，但如果增加一个Milliliters转换为Gallons的函数，会产生错误，不能在同一个包中出现两个ToGallons函数！&lt;/p&gt;
&lt;p&gt;可以分别修改两个ToGallons函数的名字：LitersToGallons和MillilitersToGallons：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func LitersToGallons(l Liters) Gallons {
        return Gallons(l * 0.264)
}
func MillilitersToGallons(m Milliliters) Gallons {
        return Gallons(m * 0.000264)
}
func GallonsToLiters(g Gallons) Liters {
        return Liters(g * 3.785)
}
func GallonsToMilliliters(g Gallons) Milliliters {
        return Milliliters(g * 3785.41)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然这样消除了冲突，但是名字很长，不方便。&lt;/p&gt;
&lt;p&gt;其他语言的重载，允许存在多个同名函数，只要其参数不同即可，但go不支持重载，有其他方式能达到类似的效果。&lt;/p&gt;
&lt;h1 id=&#34;使用方法修复函数名冲突&#34;&gt;使用方法修复函数名冲突&lt;/h1&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var now time.Time = time.Now()  //time.Now返回一个time.Time值代表当前日期和时间
        var year int = now.Year()  //time.Time值有一个Year方法来返回当前年
        fmt.Printlnt(year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        broken := &amp;#34;G# r#cks&amp;#34;
        replacer := strings.NewReplacer(&amp;#34;#&amp;#34;, &amp;#34;o&amp;#34;)  //返回一个strings.Replacer值，被设置为&amp;#34;#&amp;#34;到&amp;#34;o&amp;#34;的转换
        fixed := replacer.Replace(broken)  //调用strings.Replacer的Replace方法，并传入一个字符串来作转换
        fmt.Println(fixed)  //输出Replace方法返回的字符串
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以用自定义方法来帮助解决类型转换的问题。&lt;/p&gt;
&lt;p&gt;不允许有多个ToGallons函数，所以不得不写很长的函数名称；但是可以有多个名为ToGallons的方法，只要它们被定义在单独的类型中，不用担心名称冲突，让方法名称更短小。&lt;/p&gt;
&lt;h1 id=&#34;定义方法&#34;&gt;定义方法&lt;/h1&gt;
&lt;p&gt;方法定义与函数定义类似，只有一点不同：需要增加一个额外的参数，一个接收器参数，在函数名称之前的括号中；需要提供一个接收器参数的名称，后面跟着类型。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/9-type/%e5%ae%9a%e4%b9%89%e6%96%b9%e6%b3%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;为了调用定义的方法，键入要在其上调用方法的值，一个点和要调用的方法的名称，跟着一对括号；这里调用的方法被称为&lt;code&gt;方法接收器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当调用一个方法时，接收器要被列为第一个，并当定义一个方法的时候，接收器参数也被列为第一个。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;value := MyType(&amp;#34;a MyType value&amp;#34;)
value.sayHi()  //value为方法接收器，sayHi为方法名称
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法定义中的接收器参数的名称不重要，重要的是它的类型，定义的方法与此类型的值都关联。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type MyType string   //定义一个类型

func (m MyType) sayHi() {  //定义一个接收器，函数被定义在MyType上
        fmt.Println(&amp;#34;Hi&amp;#34;)
}

func main() {
        value := MyType(&amp;#34;a MyType value&amp;#34;)  //创建一个MyType值
        value.sayHi()  //在这个值上调用sayHi
        anotherValue := MyType(&amp;#34;another value&amp;#34;)  //创建另一个MyType值
        anotherValue.sayHi()  //在另一个值上调用sayHi
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hi
Hi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先定义了一个名为MyType的类型，使用string作为基础类型，然后定义一个名为sayHi的方法，由于sayHi有一个MyType类型的接收器参数，可以使用任何MyType的值来调用sayHi方法。&lt;/p&gt;
&lt;p&gt;一旦方法被定义在了某个类型，它就能被该类型的任何值调用。&lt;/p&gt;
&lt;h1 id=&#34;接收器参数几乎就是另一个参数&#34;&gt;接收器参数（几乎）就是另一个参数&lt;/h1&gt;
&lt;p&gt;接收器参数的类型是与之联系的方法的类型，除此以外，接收器在Go中没有什么特殊，可以在方法块中访问它们的内容，就像其他的函数参数一样。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type MyType string

func (m MyType) sayHi() {  //输出接收器参数的值
        fmt.Println(&amp;#34;Hi from&amp;#34;, m)
}

func main() {
        value := MyType(&amp;#34;a MyType value&amp;#34;)  //调用方法所需的值
        value.sayHi()  //传递给接收器参数的接收器
        anotherValue := MyType(&amp;#34;another value&amp;#34;)  //调用方法所需的值
        anotherValue.sayHi()  //传递给接收器参数的接收器
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hi from a MyType value
Hi from another value    //获取了输出中的接收器的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go可以命名接收器的名称，但是若类型定义的所有方法的接收器参数名称一致，则更易读。&lt;/p&gt;
&lt;p&gt;Go开发者通常使用一个字母作为名称：小写的接受器类型名称的首字母（使用m作为MyType接收器的参数名称）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1.能否为任何类型定义新的方法？&lt;br&gt;
方法和类型必须定义在同一包中；意味着不会在hacking包中定义security包中的类型的方法，并且不会为像int或string一类的普通类型定义新的方法。&lt;/p&gt;
&lt;p&gt;2.需要在别人的类型上使用自己的方法&lt;br&gt;
首先考虑是否需要一个函数就足够，函数可以接受需要的任何类型作为参数，但若真的需要一个值具有自定义的方法，在不同的包中给类型增加一些方法，可以创建一个新的类型并将其他包的类型作为匿名字段嵌入，后边会演示如何操作。&lt;/p&gt;
&lt;h1 id=&#34;方法几乎就像一个函数&#34;&gt;方法（几乎）就像一个函数&lt;/h1&gt;
&lt;p&gt;除了在接收器上被调用外，方法与函数完全相同，与其他函数一样，可以在方法名称后面的括号中定义额外的参数，参数变量与接收器参数一样，可以被方法块所访问。当调用方法时，将需要为每个参数提供值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (m MyType) MethodWithParameters(number int, flag bool) {
        fmt.Println(m)
        fmt.Println(number)
        fmt.Println(flag)
}

func main() {
        value := MyType(&amp;#34;MyType value&amp;#34;)
        value.MethodWithParameters(4, true)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MyType value
4
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与函数一样，可以为方法声明一个或多个返回值，返回值将在函数被调用时返回：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (m MyType) WithReturn() int {
        return len(m)
}

func main() {
        value := MyType(&amp;#34;MyType value&amp;#34;)
        fmt.Println(value.WithReturn())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与函数一样，方法名称以大写字母开头，则认为是可导出的，若以小写字母开头，认为是不可导出的。想要在当前包之外使用定义的方法，要确保名字以大写字母开头。&lt;/p&gt;
&lt;h1 id=&#34;指针类型的接收器参数&#34;&gt;指针类型的接收器参数&lt;/h1&gt;
&lt;p&gt;定义了一个新的以int为基础类型的Number类型，为Number类型提供一个名为double的方法，它将接收器的基础类型值乘以2并且重新赋值给接收器，从输出上看方法的接收器并未更新。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Number int  //定义一个基础类型为int的类型

func (n Number) Double() {   //定义一个Number类型
        n *= 2  //接收器的值乘以2，尝试更新接收器
}

func main() {
        number := Number(4)  //创建一个Number的值
        fmt.Println(&amp;#34;Original value of number:&amp;#34;, number)
        number.Double()  //尝试加倍Number
        fmt.Println(&amp;#34;number after calling Double:&amp;#34;, number)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Original value of number: 4
number after calling Double: 4  //Number并未加倍
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之前的double函数也有同样的问题，函数参数接收的是函数调用时的拷贝，不是原始值，当函数退出后任何更新都会失效，为了能让double函数正常，传递一个要更新的值的指针，然后更新该指针指向的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        amount := 6
        double(&amp;amp;amount)  //传递一个指针而不是值
        fmt.Println(amount)
}

func double(number *int) {  //接收指针而不是int值
        *number *= 2  //更新指针指向的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要修改Double方法以使用指针来作其接收器参数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (n *Number) Double() {  //接收器参数接收指针类型
        *n *= 2  //修改指针指向的值
}

func main() {
        number := Number(4)
        fmt.Println(&amp;#34;Original value of number:&amp;#34;, number)
        number.Double()  //不需要修改方法的调用
        fmt.Println(&amp;#34;number after calling Double:&amp;#34;, number)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Original value of number: 4
number after calling Double: 8  //指针指向的值被更新
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不需要修改方法的调用，当用一个非指针的变量调用一个需要指针的接收器的方法时，Go会自动将非指针类型转换为指针类型，同样指针类型也会自动转换为非指针类型，若调用一个要求值类型的接收器，Go会自动获取指针指向的值，然后传递给方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyType string

func (m MyType) method() {
        fmt.Println(&amp;#34;Method with value receiver&amp;#34;)
}
func (m *MyType) pointerMethod() {
        fmt.Println(&amp;#34;Method with pointer receiver&amp;#34;)
}

func main() {
        value := MyType(&amp;#34;a value&amp;#34;)
        pointer := &amp;amp;value
        value.method()
        value.pointerMethod()   //值类型自动转换为指针
        pointer.method()   //指针类型自动转换为值
        pointer.pointerMethod()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Method with value receiver
Method with pointer receiver
Method with value receiver
Method with pointer receiver
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;名为method的方法接受一个值类型的接收器，但我们同时使用了值类型和指针类型，如果需要，Go会自动转换；名为pointerMethod的方法接受一个指针类型的接收器，但是使用了值类型和指针类型调用，如果需要，Go会自动转换。&lt;/p&gt;
&lt;p&gt;为了一致性，所有的类型函数接受值类型或者都接受指针类型，避免混用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为了调用需要接收器指针的方法，需要或者这个值类型的指针！&lt;/p&gt;
&lt;p&gt;只能获取保存在变量中的指针，若尝试获取没有保存在变量中的值的地址，会得到错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;amp;MyType(&amp;#34;a value&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;错误输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cannot take the address of MyType(&amp;#34;a value&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相同的限制也存在于使用接收器指针调用方法时，Go无法将值类型转换为指针类型，除非将接收器的值保存在变量中，若尝试在值类型上调用方法，Go也不会转换为指针，会得到相同的错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MyType(&amp;#34;a value&amp;#34;).pointerMethod()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;错误输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cannot call pointer method on MyType(&amp;#34;a value&amp;#34;)
cannot take the address of MyType(&amp;#34;a value&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要将值保存在变量中，允许Go能得到一个指向它的指针：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;value := MyType(&amp;#34;a value&amp;#34;)
value.pointerMethod()   //将其转化为指针
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;这是一个Number类型，定义了两个方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import &amp;#34;fmt&amp;#34;
type Number int
func (n *Number) Display() {
        fmt.Println(*n)
}
func (n *Number) Double() {
        *n *= 2
}
func main() {
        number := Number(4)
        number.Double()
        number.Display()
}
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;若如此&amp;hellip;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代码会失败，因为：&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func (n &lt;del&gt;*Number&lt;/del&gt;int) Double() {&lt;br&gt;        *n *= 2&lt;br&gt;}&lt;br&gt;&lt;pre&gt;将接收器参数类型改为一个未在当前包中定义的类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能为定义在当前包中的类型定义方法。为一个像int一样全局定义的类型定义方法会导致编译错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func (n &lt;del&gt;*&lt;/del&gt;Number) Double() {&lt;br&gt;        &lt;del&gt;*&lt;/del&gt;n *= 2&lt;br&gt;}&lt;br&gt;&lt;pre&gt;将Double方法的接收器参数改为一个非指针类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收器参数接受了一个接收器的拷贝，若Double函数仅修改这个拷贝，当Double返回的时候，原值不会改变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;Number(4).Double()&lt;pre&gt;在一个没有保存到变量的值上直接调用一个需求接收器的指针的方法&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;当调用一个指针类型的接收器时，如果接收器保存在变量中，Go会自动将值转换为指针类型，若没有保存，会得到一个错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func (n &lt;del&gt;*&lt;/del&gt;Number) Display() {&lt;br&gt;        fmt.Println(&lt;del&gt;*&lt;/del&gt;n)&lt;br&gt;}&lt;br&gt;&lt;pre&gt;将Display方法的接收器参数改为一个非指针类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在修改之后，代码仍能正常运行，但破坏了惯例，方法中的接收器参数可以都是指针，或者都是值类型，避免混用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;使用方法将liters和milliliters转换为gallons&#34;&gt;使用方法将Liters和Milliliters转换为Gallons&lt;/h1&gt;
&lt;p&gt;不同于函数，只要方法定义在不同的类型中，就可以重名。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Liters float64
type Milliliters float64
type Gallons float64

func (l Liters) ToGallons() Gallons {
	return Gallons(l * 0.264)
}
func (m Milliliters) ToGallons() Gallons {
	return Gallons(m * 0.000264)
}

func main() {
	soda := Liters(2)
	fmt.Printf(&amp;#34;%0.3f liters equals %0.3f gallons\n&amp;#34;, soda, soda.ToGallons())
	water := Milliliters(500)
	fmt.Printf(&amp;#34;%0.3f milliliters equals %0.3f gallons\n&amp;#34;, water, water.ToGallons())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2.000 liters equals 0.528 gallons
500.000 milliliters equals 0.132 gallons
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没有使用指针类型作为接收器参数，不需要修改接收器，值类型没有消耗很多内存，参数接受一个拷贝也是合适的。&lt;/p&gt;
&lt;h1 id=&#34;使用方法将gallons转换为liters和milliliters&#34;&gt;使用方法将Gallons转换为Liters和Milliliters&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (g Gallons) ToLiters() Liters {
	return Liters(g * 3.785)
}
func (g Gallons) ToMilliliters() Milliliters {
	return Milliliters(g * 3785.41)
}

func main() {
	milk := Gallons(2)
	fmt.Printf(&amp;#34;%0.3f gallons equals %0.3f liters\n&amp;#34;, milk, milk.Toliters())
	fmt.Printf(&amp;#34;%0.3f gallons equals %0.3f milliliters\n&amp;#34;, milk, milk.ToMilliliters())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;练习：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Liters float64
type Milliliters float64
type Gallons float64

func (l Liters) ToMilliliters() Milliliters {
	return Milliliters(l * 1000)
}
func (m Milliliters) ToLiters() Liters {
	return Liters(m / 1000)
}

func main() {
	l := Liters(3)
	fmt.Printf(&amp;#34;%0.1f liters is %0.1f milliliters\n&amp;#34;, l, l.ToMilliliters())
	ml := Milliliters(500)
	fmt.Printf(&amp;#34;%0.1f milliliters is %0.1f liters\n&amp;#34;, ml, ml.ToLiters())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3.0 liters is 3000.0 milliliters
500.0 milliliters is 0.5 liters
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>8.结构体：struct</title>
      <link>https://tinklespring.com/posts/8.%E7%BB%93%E6%9E%84%E4%BD%93struct/</link>
      <pubDate>Sat, 29 Jul 2023 18:29:46 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/8.%E7%BB%93%E6%9E%84%E4%BD%93struct/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;有时需要保存超过一种类型的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;切片可以保存一组数据，映射能保存一组键和一组值，这两种数据结构都只能保存一种类型。有时需要一组不同类型的数据，例如邮件地址，其中包含了街道名、邮编等，无法使用切片或者映射来保存，但是可以使用 &lt;code&gt;struct&lt;/code&gt; 类型来保存。&lt;/p&gt;
&lt;h1 id=&#34;struct是由多种类型的值构成&#34;&gt;struct是由多种类型的值构成&lt;/h1&gt;
&lt;p&gt;使用struct关键字来声明一个 struct 类型，后面跟花括号，在括号中，可以定义一个或多个字段：struct 组合的值。每一个字段定义在一个单独的行，由字段名称、后面跟着的字段需要保存的值类型组成。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/8-struct/struct%e8%af%ad%e6%b3%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;可以使用一个struct类型来作为定义的变量的类型，例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myStruct struct {
       number float64
       word   string
       toggle bool
}
fmt.Printf(&amp;#34;%#v\n&amp;#34;, myStruct)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct { number float64; word string; toggle bool }
{number:0, word:&amp;#34;&amp;#34;, toggle:false}   //struct中每个字段都被设置成其类型的零值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当调用Printf中的 %#v 时，将myStruct中的值作为struct字面量打印。&lt;/p&gt;
&lt;p&gt;写struct字段时，仅仅在字段名称和类型之间插入一个空格即可，go fmt 会自动格式化。&lt;/p&gt;
&lt;h1 id=&#34;使用点运算符访问struct字段&#34;&gt;使用点运算符访问struct字段&lt;/h1&gt;
&lt;p&gt;我们使用点运算符来表示函数属于另一个包，或方法属于一个值。&lt;/p&gt;
&lt;p&gt;与此类似，可以使用点运算符来标识属于struct的字段，这也可以用于它们的赋值和检索。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myStruct struct {
        number float64
        word   string
        toggle bool
}
myStruct.number = 3.14
myStruct.word = &amp;#34;pie&amp;#34;
myStruct.toggle = &amp;#34;true&amp;#34;   //给struct字段赋值
fmt.Println(myStruct.number)  
fmt.Println(myStruct.word)
fmt.Println(myStruct.toggle)  //从struct字段取值
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在struct中保存订阅者的数据&#34;&gt;在struct中保存订阅者的数据&lt;/h1&gt;
&lt;p&gt;我们知道了如何声明一个保存了struct的变量和如何给字段赋值，可以创建一个来保存杂志订阅者的数据。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var subscriber struct {
        name   string
        rate   float64
        active bool
}
subscriber.name = &amp;#34;Aman Singh&amp;#34;
subscriber.rate = 4.99
subscriber.active = true
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber.name)
fmt.Println(&amp;#34;Monthly rate:&amp;#34;, subscriber.rate)
fmt.Println(&amp;#34;Active?&amp;#34;, subscriber.active)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;尽管订阅者的数据使用了多种方式存储，struct让我们把这些都集中在一个方便的包里。&lt;/p&gt;
&lt;h1 id=&#34;定义类型和struct&#34;&gt;定义类型和struct&lt;/h1&gt;
&lt;p&gt;定义struct变量很麻烦，定义每一个变量时需要重复整个struct类型声明。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var subscriber1 struct {
        name   string
        rate   float64
        active bool
}      //为subscriber1变量定义struct类型
subscriber1.name = &amp;#34;Aman Singh&amp;#34;
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber1.name)
var subscriber2 struct {
        name   string
        rate   float64
        active bool
}     //为subscriber2变量定义struct类型
subscriber2.name = &amp;#34;Beth Ryan&amp;#34;
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber2.name)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们已经使用了多种类型，像int、string、bool、切片、映射和struct，但是无法创建全新类型。&lt;/p&gt;
&lt;p&gt;类型定义允许自己创建新的类型，可以基于基础类型来创建新的定义类型。&lt;/p&gt;
&lt;p&gt;定义一个类型，需要使用&lt;code&gt;type&lt;/code&gt;关键字，后跟新类型的名字，然后是希望基于的基础类型，若使用struct类型作为基础类型，需要使用struct关键字，后跟以花括号包裹的一组字段定义，就像声明struct变量时一样。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/8-struct/type%e7%b1%bb%e5%9e%8b.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;与变量一样，类型定义可以被放在一个函数中，但把它的作用域限定在该函数块中，意味着不能在函数外面使用，所以类型经常定义在函数外的包级别。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type part struct {    //定义一个名为part的类型，part基础类型有下面这俩字段的结构体
	description string
	count       int
}   

type car struct {    //定义一个名为car的类型，car的基础类型是有下面这些字段的struct
	name     string
	topSpeed float64
}

func main() {
	var porsche car    //定义一个car类型的变量
	porsche.name = &amp;#34;Porsche 911 R&amp;#34;   //访问struct的字段
	porsche.topSpeed = 323
	fmt.Println(&amp;#34;Name:&amp;#34;, porsche.name)
	fmt.Println(&amp;#34;Top speed:&amp;#34;, porsche.topSpeed)

	var bolts part
	bolts.description = &amp;#34;Hex bolts&amp;#34;
	bolts.count = 24
	fmt.Println(&amp;#34;Description:&amp;#34;, bolts.description)
	fmt.Println(&amp;#34;Count:&amp;#34;, bolts.count)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当这些变量被声明后，可以设置这些字段的值和取回这些值。&lt;/p&gt;
&lt;h1 id=&#34;定义一个类型&#34;&gt;定义一个类型&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
        name    string
        rate    float64
        active  bool
}

func main() {
        var sub subscriber   //定义一个subscriber类型的变量
        sub.name = &amp;#34;Aman Singh&amp;#34;
        fmt.Println(&amp;#34;Name:&amp;#34;, sub.name)
        var sub2 subscriber  //使用subscriber类型定义第二个变量
        sub2.name = &amp;#34;Beth Ryan&amp;#34;
        fmt.Println(&amp;#34;Name:&amp;#34;, sub2.name)
        
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;与函数一起使用已定义类型&#34;&gt;与函数一起使用已定义类型&lt;/h1&gt;
&lt;p&gt;已定义类型可以用于变量类型以外的地方，也可以用于函数参数和返回值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type part struct {
	description string
	count       int
}

func showInfo(p part) { //声明一个以part作为类型的参数
	fmt.Println(&amp;#34;Description:&amp;#34;, p.description)
	fmt.Println(&amp;#34;Count:&amp;#34;, p.count)
}

func main() {
	var bolts part
	bolts.description = &amp;#34;Hex bolts&amp;#34;
	bolts.count = 24
	showInfo(bolts) //将part传递给函数
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数接受一个单独的参数，使用part作为参数的类型，在showInfo内部，可以像其他struct变量一样通过参数变量访问字段。&lt;/p&gt;
&lt;p&gt;还有一个minimumOrder函数来根据特定的描述创建part和预赋值其中的count字段，将minimumOrder的返回值类型定义为part，这样就能返回一个新的struct：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func minimumOrder(description string) part {  //声明一个part类型的返回值
        var p part    //创建一个part值
        p.description = description
        p.count = 100
        return p   //返回part
}

func main() {
        p := minimumOrder(&amp;#34;Hex bolts&amp;#34;)     //调用minimumOrder，使用一个变量的短声明来保存返回的part
        fmt.Println(p.description, p.count)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面例子，printInfo函数接受subscriber作为参数，并输出它的字段值，defaultSubscriber函数来建立一个新的subscriber struct并赋一些初始的值，它们接受一个名为name的字符串参数并用它来设置新的subscriber的name字段，然后把rate和active字段设置为默认值，最后将整个subscriber struce返回给调用者。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func printInfo(s subscriber) { //声明一个参数，使用subscriber类型
	fmt.Println(&amp;#34;Name:&amp;#34;, s.name)
	fmt.Println(&amp;#34;Monthly rate:&amp;#34;, s.rate)
	fmt.Println(&amp;#34;Active:&amp;#34;, s.active)
}

func defaultSubscriber(name string) subscriber { //返回一个subscriber值
	var s subscriber //创建一个新的subscriber
	s.name = name
	s.rate = 5.99
	s.active = true //设置struct字段
	return s        //返回subscriber
}

func main() {
	subscriber1 := defaultSubscriber(&amp;#34;Aman Singh&amp;#34;) //使用名字来建立一个subscriber
	subscriber1.rate = 4.99                        //使用一个特定的费率
	printInfo(subscriber1)                         //打印字段值
	subscriber2 := defaultSubscriber(&amp;#34;Beth Ryan&amp;#34;)  //使用名字来建立一个subscriber
	printInfo(subscriber2)                         //打印字段值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Name: Aman Singh
Monthly rate: 4.99
Active: true
Name: Beth Ryan
Monthly rate: 5.99
Active: true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在主函数中，可以将subscriber的名称传递给defaultSubscriber来创建一个新的subscriber struct，一个subscriber获取一个打折的费率，所以直接重设struct的字段，传递给一个已经填充完全的subscriber struct给printInfo函数来打印它的内容。&lt;/p&gt;
&lt;p&gt;不要使用一个已经存在的类型名称作为变量的名称！&lt;/p&gt;
&lt;h1 id=&#34;使用函数修改struct&#34;&gt;使用函数修改struct&lt;/h1&gt;
&lt;p&gt;go 是一个按值传递的语言，函数调用时接收的是一个参数的拷贝，若函数修改了参数值，其修改的只是拷贝，而不是原始值。&lt;/p&gt;
&lt;p&gt;对于 struct 也是一样。&lt;/p&gt;
&lt;p&gt;函数能够接收指针来代替直接接收值，当调用这个函数时，使用取址运算符&lt;code&gt;&amp;amp;&lt;/code&gt;来传送需要更新的值的指针，然后在函数内部，使用&lt;code&gt;*&lt;/code&gt;来更新指针指向的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        amount := 6
        double(&amp;amp;amount)   //传递一个指针来取代变量的值
        fmt.Println(amount)
}
func double(number *int) {  //接受一个指针来代替int值
        *number *= 2  //使用指针更新值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用指针来让函数也能更新struct：更新 s 参数类型来接受一个 subscriber struct 的指针，而不是直接使用struct，然后更新 struct 中的rate字段，在main中，调用applyDiscount并传入 subscriber struct 的指针，在输出rate字段时，能看到被更新成功。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func applyDiscount(s *subscriber) { //获取struct的指针，而不是struct
	s.rate = 4.99 //更新struct字段
}

func main() {
	var s subscriber
	applyDiscount(&amp;amp;s) //传入一个指针，而不是struct
	fmt.Println(s.rate)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在double函数中，需要使用 * 运算符来获取指针指向的值，当在applyDiscount函数中设置rate字段时不需要 * 吗？&lt;br&gt;
使用点运算符在struct指针和struct上都可以访问字段。&lt;/p&gt;
&lt;h1 id=&#34;通过指针访问struct的字段&#34;&gt;通过指针访问struct的字段&lt;/h1&gt;
&lt;p&gt;若尝试打印一个变量的指针，会看到其指向的内存地址：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var value int = 2
        var pointer *int = &amp;amp;value
        fmt.Println(pointer)  //输出的是指针不是值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;应该使用 &lt;code&gt;*&lt;/code&gt; 运算符，就像调用取值运算符一样，来获取指针指向的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var value int = 2
        var pointer *int = &amp;amp;value
        fmt.Println(*pointer)  //输出指针指向的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以也需要对指向 struct 的指针使用 &lt;code&gt;*&lt;/code&gt; 运算符，但是直接把 &lt;code&gt;*&lt;/code&gt; 放到指针前是无法工作的，需要使用括号包裹。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type myStruct struct {
        myField int
}

func main() {
        var value myStruct
        value.myField = 3
        var pointer *myStruct = &amp;amp;value
        fmt.Println((*pointer).myField)   //获取指针指向的的struct值，然后访问struct的字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;点运算符允许通过struct的指针来访问字段，就像可以通过struct值直接访问一样，可以不需要括号和&lt;code&gt;*&lt;/code&gt;运算符。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var value myStruct
        value.myField = 3
        var pointer *myStruct = &amp;amp;value
        fmt.Println(pointer.myField)   //通过指针访问struct字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以通过指针来赋值给struct字段：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var vaule myStruct
        var pointer *myStruct = &amp;amp;value
        pointer.myField = 9     //通过指针来赋值给struct字段
        fmt.Println(pointer.myField)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是上边 applyDiscount 函数可以更新struct字段而不用&lt;code&gt;*&lt;/code&gt;运算符，它通过struct指针赋值给rate字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func applyDiscount(s *subscriber) { //获取struct的指针，而不是struct
	s.rate = 4.99 //通过指针赋值给struct字段
}

func main() {
	var s subscriber
	applyDiscount(&amp;amp;s) //传入一个指针，而不是struct
	fmt.Println(s.rate)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在设置struct字段前展示了defaultSubscriber函数，但是它不需要任何指针，这是为什么？&lt;br&gt;
答：defaultSubscriber函数返回了一个struct值，若调用者保存了返回的值，那么struct值中的字段同时会被保存。只有函数修改已经存在的struct而没有返回它们的时候需要使用指针来保存修改项。&lt;br&gt;
若需要时，defaultSubscriber可以返回一个struct的指针。&lt;/p&gt;
&lt;h1 id=&#34;使用指针传递大型struct&#34;&gt;使用指针传递大型struct&lt;/h1&gt;
&lt;p&gt;函数行参接收一个函数调用的实参的拷贝，即使是struct也是这样，若传递一个有很多字段的比较大的struct，会占用很多内存，会为原始的struct和被拷贝的struct都划分空间。&lt;/p&gt;
&lt;p&gt;除非struct字段少，否则要向函数传入struct的指针，即使函数并不修改struct也是如此。当传递一个struct指针时，内存中只有一个原始的struct，并可以读取、修改等操作，都不会产生一个额外的拷贝。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func printInfo(s *subscriber) { //获取指针
	fmt.Println(&amp;#34;Name:&amp;#34;, s.name)
	fmt.Println(&amp;#34;Monthly rate:&amp;#34;, s.rate)
	fmt.Println(&amp;#34;Active:&amp;#34;, s.active)
}

func defaultSubscriber(name string) *subscriber { //返回指针
	var s subscriber
	s.name = name
	s.rate = 5.99
	s.active = true
	return &amp;amp;s //返回一个指向struct的指针，而不是struct自己
}

func applyDiscount(s *subscriber) {
	s.rate = 4.99
}

func main() {
	subscriber1 := defaultSubscriber(&amp;#34;Aman Singh&amp;#34;) //一个struct指针
	applyDiscount(subscriber1)                     //由于这里已经是struct的指针，去掉取址运算符
	printInfo(subscriber1)
	subscriber2 := defaultSubscriber(&amp;#34;Beth Ryan&amp;#34;)
	printInfo(subscriber2)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里defaultSubscriber函数，更改为返回一个指针，且printInfo函数也改成接受一个指针，这些函数不需要像applyDiscount一样修改struct，使用指针确保对于每个struct值，只有一个拷贝在内存中，也能保证程序正常工作。&lt;/p&gt;
&lt;h1 id=&#34;将struct类型移动到另一个包&#34;&gt;将struct类型移动到另一个包&lt;/h1&gt;
&lt;p&gt;将type类型保存在magazine包中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package magazine

type Subscriber struct {
        name   string
        Rate   float64
        active bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        var s magazine.Subscriber
        s.Rate = 4.99
        fmt.Println(s.Rate)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go类型名称与变量和函数名称规则一样，首字母大写被认为可导出，可以从外部包来访问。&lt;/p&gt;
&lt;p&gt;从包中导出struct字段，字段名称的首字母也必须大写。&lt;/p&gt;
&lt;h1 id=&#34;struct字面量&#34;&gt;struct字面量&lt;/h1&gt;
&lt;p&gt;代码定义一个struct并且一个一个的赋值，很不友好，跟切片、映射一样，Go提供了struct字面量来让你创建一个struct并同时为其字段赋值。&lt;/p&gt;
&lt;p&gt;类型列在前，跟着一对花括号，在花括号内部，可以给一些或所有的struct字段赋值，使用字段名称、冒号和值，若定义多个字段，使用逗号分隔。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/8-struct/type%e5%ad%97%e9%9d%a2%e9%87%8f.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;使用struct字面量，创建Subscriber并设置值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;, Rate: 4.99, Active: true}
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber.Name)
fmt.Println(&amp;#34;Rate:&amp;#34;, subscriber.Rate)
fmt.Println(&amp;#34;Active:&amp;#34;, subscriber.Active)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不得不对struct变量使用长声明的方式（除非struct从一个函数中返回），struct字面量允许对刚创建的struct使用短变量声明。&lt;/p&gt;
&lt;p&gt;可以在花括号中忽略一些甚至所有的字段，被忽略的字段会被设置为它们的零值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber{Rate: 4.99}
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber.Name)
fmt.Println(&amp;#34;Rate:&amp;#34;, subscriber.Rate)
fmt.Println(&amp;#34;Active:&amp;#34;, subscriber.Active)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Name:           //被忽略的字段获得了零值
Rate: 4.99
Active: false   //被忽略的字段获得了零值
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;创建一个employee-struct类型&#34;&gt;创建一个Employee struct类型&lt;/h1&gt;
&lt;p&gt;这个新的magazine包，在发布前，需要一个Employee strcut类型来追踪营业员的名称和薪水，并需要把邮件地址放到雇员和订阅者的结构中。&lt;/p&gt;
&lt;p&gt;在magazine包中增加一个类型：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pacakge magazine

type Subscriber struct {
        Name    string
        Rate    float64
        Active  bool
}

type Employee struct {
        Name    string
        Salary  float64
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        var emplpoyee magazine.Employee
        emplpoyee.Name = &amp;#34;Joy Carr&amp;#34;
        emplpoyee.Salary = 60000
        fmt.Println(emplpoyee.Name)
        fmt.Println(emplpoyee.Salary)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;创建一个address-struct类型&#34;&gt;创建一个Address struct类型&lt;/h1&gt;
&lt;p&gt;在Subscriber和Employee类型中增加一个地址，街道、城市、州、和邮编。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Subscriber struct {
        Name    string
        Rate    float64
        Active  bool
        Street  string
        City    string
        State   string
        PostalCode string
}

type Employee struct {
        Name    string
        Salary  float64
        Street  string
        City    string
        State   string
        PostalCode string
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是邮政地址都有相同的格式，无论属于哪个类型，将所有字段在多个类型中重复是痛苦的事情。&lt;/p&gt;
&lt;p&gt;struct字段可以保存任何类型，甚至是struct类型，所以我们创建一个Address struct 类型，然后在Subscriber和Employee类型中增加一个Address类型的字段，并且如果想要修改地址格式，可以保证类型之间的一致性。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Address struct {
        Street  string
        City    string
        State   string
        PostalCode string
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        var address magazine.Address
        address.Street = &amp;#34;123 Oak St&amp;#34;
        address.City = &amp;#34;Omaha&amp;#34;
        address.State = &amp;#34;NE&amp;#34;
        address.PostalCode = &amp;#34;12345&amp;#34;
        fmt.Println(address)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;将struct作为字段增加到另一个类型中&#34;&gt;将struct作为字段增加到另一个类型中&lt;/h1&gt;
&lt;p&gt;给 Subscriber 和 Employee 类型增加一个HomeAddress字段，在struct类型中增加一个struct类型字段与增加其他类型字段相同，字段名称和字段类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package magazine

type Address struct {
        Street  string
        City    string
        State   string
        PostalCode string
}

type Subscriber Struct {
        Name    string
        Rate    float64
        Active  bool
        HomeAddress Address
}

type Employee struct {
        Name    string
        Salary  float64
        HomeAddress Address
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在另一个struct中设置struct&#34;&gt;在另一个struct中设置struct&lt;/h1&gt;
&lt;p&gt;在Subscriber struct中设置 Address struct的字段值，这里有两种方式。&lt;/p&gt;
&lt;p&gt;第一种是创建一个独立的Address struct并使用它填充 Subscriber的整个Address字段：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        address := magazine.Address{Street: &amp;#34;123 Oak St&amp;#34;, City: &amp;#34;Omaha&amp;#34;, State: &amp;#34;NE&amp;#34;, PostalCode: &amp;#34;12345&amp;#34;}
        subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}  //创建一个Address所属的Subscriber struct
        subscriber.HomeAddress = address    //设置HomeAddress字段
        fmt.Println(subscriber.HomeAddress)  //打印HomeAddress字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一种方法是通过外部struct来设置内部struct的字段。&lt;br&gt;
当一个Subscriber struct被创建后，其HomeAddress字段也被设置：它是一个Address struct，所有的字段都被设置为零值，若对fmt.Printf使用&amp;quot;%#v&amp;quot;动词来打印HomeAddress，会打印出它在go代码中的样子，也就是说像struct字面量一样，将看到每一个Address字段被设置为空字符串，也就是string类型的零值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber()
fmt.Printf(&amp;#34;%#v\n&amp;#34;, subscriber.HomeAddress)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;magazine.Address{Street:&amp;#34;&amp;#34;, City:&amp;#34;&amp;#34;, State:&amp;#34;&amp;#34;, PostalCode:&amp;#34;&amp;#34;}  //字段已经像Address struct一样被设置了，每一个字段都被设置为空字符串（字符串的零值）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若subscriber是一个包含Subscriber struct的变量，当输入subscriber.HomeAddress时，会获得一个Address struct，即使没有明确设置HomeAddress。&lt;/p&gt;
&lt;p&gt;可以使用点运算符“链”的方式来访问Address struct中的字段，简单使用subscriber.HomeAddress来访问Address struct，后面跟另一个点运算符和想要访问的Address struct中的字段名称：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber.HomeAddress.City    //subscriber.HomeAddress 这部分返回一个Address struct，City 部分访问Address struct中的City部分
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在subscriber变量中保存一个Subscriber struct，在subscriber的HomeAddress字段中自动创建一个Address struct，设置subscriber.HomeAddress.Street、subscriber.HomeAddress.City和其他的值，然后输出这些值。然后在employee变量中保存Employee struct，并在HomeAddress struct中做相同操作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
	subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}
	subscriber.HomeAddress.Street = &amp;#34;123 Oak St&amp;#34;
	subscriber.HomeAddress.City = &amp;#34;Omaha&amp;#34;
	subscriber.HomeAddress.State = &amp;#34;NE&amp;#34;
	subscriber.HomeAddress.PostalCode = &amp;#34;12345&amp;#34;
	fmt.Println(&amp;#34;Subscriber Name:&amp;#34;, subscriber.Name)
	fmt.Println(&amp;#34;Street:&amp;#34;, subscriber.HomeAddress.Street)
	fmt.Println(&amp;#34;City:&amp;#34;, subscriber.HomeAddress.City)
	fmt.Println(&amp;#34;State&amp;#34;, subscriber.HomeAddress.State)
	fmt.Println(&amp;#34;Postal Code:&amp;#34;, subscriber.HomeAddress.PostalCode)

	// ...  //employee 省略
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;匿名struct字段&#34;&gt;匿名struct字段&lt;/h1&gt;
&lt;p&gt;通过外部struct访问内部struct的字段有点繁琐，想要访问内部struct字段的时候，不得不每次输入代表struct字段的名称。go允许定义一个匿名字段：struct字段没有名字，仅仅只有类型，可以使用匿名字段来让内部struct访问更简单。&lt;/p&gt;
&lt;p&gt;更新 Subscriber 和 Employee 类型，让HomeAddress字段作为一个匿名字段，只需移除字段名称，仅保留字段类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package magazine

type Subscriber struct {
        Name string
        Rate float64
        Active bool
        Address
}

type Employee struct {
        Name  string
        Salary float64
        Address   //删除字段名称（HomeAddress），仅保留类型
}

type Address struct {
        // Fields omitted
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当声明一个匿名字段时，可以使用字段类型名称作为字段名称，所以 subscriber.Address和 employee.Address在下面的代码中仍然访问Address struct：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}
subscriber.Address.Street = &amp;#34;123 Oak St&amp;#34;
subscriber.Address.City = &amp;#34;Omaha&amp;#34;
fmt.Println(&amp;#34;Street:&amp;#34;, subscriber.Address.Street)
fmt.Println(&amp;#34;City:&amp;#34;, subscriber.Address.City)
//...
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;嵌入struct&#34;&gt;嵌入struct&lt;/h1&gt;
&lt;p&gt;匿名字段不只是使struct定义中省略了字段名称。&lt;/p&gt;
&lt;p&gt;一个内部struct使用匿名字段的方式存储在了外部的struct中，这被称为嵌入了外部struct，嵌入struct的字段被提升到了外部struct，可以像访问外部struct的字段一样访问它们。&lt;/p&gt;
&lt;p&gt;所以Address struct类型被嵌入了Subscriber struct和Employee struct类型，不需要写下subscriber.Address.City来获取City字段，可以只写subscriber.City，不需要写下 employee.Address.State，可以只写employee.State。&lt;/p&gt;
&lt;p&gt;修改为将Address当作一个内嵌类型，可以将代码写成完全没有Address类型，就像Address的字段属于它嵌入的struct类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
	subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}
	subscriber.Street = &amp;#34;123 Oak St&amp;#34;
	subscriber.City = &amp;#34;Omaha&amp;#34;
	subscriber.State = &amp;#34;NE&amp;#34;
	subscriber.PostalCode = &amp;#34;12345&amp;#34;  //设置Address的字段就像它们在Subscriber上被定义过一样
	fmt.Println(&amp;#34;Subscriber Name:&amp;#34;, subscriber.Name)
	fmt.Println(&amp;#34;Street:&amp;#34;, subscriber.Street)
	fmt.Println(&amp;#34;City:&amp;#34;, subscriber.City)
	fmt.Println(&amp;#34;State&amp;#34;, subscriber.State)
	fmt.Println(&amp;#34;Postal Code:&amp;#34;, subscriber.PostalCode)

	...  //employee 省略

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不是必须内嵌内部struct，也不是必须使用内部struct，有时给外部struct增加新字段会使代码更干净。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.数据标签：映射</title>
      <link>https://tinklespring.com/posts/7.%E6%95%B0%E6%8D%AE%E6%A0%87%E7%AD%BE%E6%98%A0%E5%B0%84/</link>
      <pubDate>Sat, 22 Jul 2023 11:37:02 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/7.%E6%95%B0%E6%8D%AE%E6%A0%87%E7%AD%BE%E6%98%A0%E5%B0%84/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;当需要使用一个特定的值，为了找到它，需要从数组或切片中查看每一个元素，有一种集合，其中的每个值都有一个标签，那么就可以快速找到需要的值，&lt;code&gt;映射&lt;/code&gt;就是做这个工作的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;从文件中读取名字&#34;&gt;从文件中读取名字&lt;/h1&gt;
&lt;p&gt;有一个文件 votes.txt ：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Amber Graham
Brian Martin
Amber Graham
Brian Martin
Amber Graham
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每一行代表一次投票，需要处理文件的每一行并统计每个名称出现的总次数，获得多票的胜出。&lt;/p&gt;
&lt;p&gt;首先需要读取votes.txt文件的内容，之前有GetFloats函数来读取文件中的每一行，并转换为一个切片，但只能读取float64值，所以需要增加一个GetStrings函数，把每行作为string值添加到返回的切片中。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package datafile

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;os&amp;#34;
)

func GetStrings(fileName string) ([]string, error) {
	var lines []string
	file, err := os.Open(fileName)
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		lines = append(lines, line)
	}
	err = file.Close()
	if err != nil {
		return nil, err
	}
	if scanner.Err() != nil {
		return nil, scanner.Err()
	}
	return lines, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;xxx/xxx/datafile&amp;#34;
	&amp;#34;log&amp;#34;
)

func main() {
	lines, err: = datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(lines)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用困难的切片方法对名字计数&#34;&gt;使用困难的切片方法对名字计数&lt;/h1&gt;
&lt;p&gt;上述代码从文件中读取名字，如何计算名字出现了多少次？有两种方式，一种是切片，另一种是数据结构映射。&lt;/p&gt;
&lt;p&gt;关于使用切片的方式：创建两个切片，每个的长度都是元素的总个数，并是指定的顺序，第一个切片用来保存在文件中找到的名字，每个名字只出现一次，命名为 names；第二个切片命名为counts，保存文件中的名字出现的次数，元素 counts[0] 保存 names[0] 出现的次数，以次类推。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	lines, err := datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
	if err != nil {
		log.Fatal(err)
	}
	var names []string   //这个变量保存人名
	var counts []int     //这个变量保存每个人名出现的次数
	for _, line := range lines {
		matched := false
		for i, name := range names {   //循环处理names切片中的每一个值
			if name == line {      //若line与当前名称匹配
				counts[i]++    //增加对应的count值
				matched = true  //标识找到了匹配的名字
			}
		}
		if matched == false {       //若没有找到匹配名字
			names = append(names, line)  //添加它作为一个新名字
			counts = append(counts, 1)   //并增加一个新的计数（这行是第一次出现）
		}
	}
	for i, name := range names {
		fmt.Printf(&amp;#34;%s: %d\n&amp;#34;, name, counts[i])   //输出names切片中的每一个元素，和对应的counts切片中的元素
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序使用一个循环嵌套在另一个循环中的方式来统计名字的次数，外面的循环把文件中的每行以每次一行的方式赋值给line变量。内部循环通过遍历names切片中的每个元素来查找与文件中的当前行匹配的名称。&lt;/p&gt;
&lt;p&gt;若某人在选票上写一个名字，会导致文件中加载一个字符串，程序会一个一个确认names的元素中是否有等于这个名字。若没有找到匹配项，程序会在names切片末尾追加这个名字，并在counts切片中相应的位置增加1。假如下一行的这个名字已经存在于names切片中，程序会找到位置，在对应位置增加1。&lt;/p&gt;
&lt;h1 id=&#34;映射&#34;&gt;映射&lt;/h1&gt;
&lt;p&gt;保存名字使用的是切片，对于文件中的每一行，必须在许多names切片的值中寻找来进行比较，这样会导致性能差。&lt;/p&gt;
&lt;p&gt;go有一种方法保存数据集合： &lt;code&gt;映射&lt;/code&gt; 。 一个映射是通过&lt;code&gt;键&lt;/code&gt;来访问每一个值的集合，键是一个简单的方式从映射中找出数据。&lt;/p&gt;
&lt;p&gt;相对于数组和切片只能使用整型数字作为索引，映射可以使用任意类型的键（只要这个类型可以使用 == 来比较），包括数字、字符串和其他。所有的值只能是相同的类型，所有的健也需要是相同的类型，但是键和值的类型不必相同。&lt;/p&gt;
&lt;p&gt;声明一个保存映射的变量，需要 &lt;code&gt;map&lt;/code&gt; 关键字，后跟一对包含键类型的方括号&lt;code&gt;[]&lt;/code&gt;，然后在方括号后跟提供值的类型。&lt;br&gt;
&lt;code&gt;var myMap map[string]float64 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/7-%e6%98%a0%e5%b0%84/map%e8%af%ad%e6%b3%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;与切片一样，声明一个映射变量并不会自动创建一个映射，需要调用make函数（与创建切片相同的函数），可以传递给make想要创建的映射类型（与需要赋值到的类型相同）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var ranks map[string]int    //声明一个映射变量
ranks = make(map[string]int) //真正创建一个映射
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;短变量声明方式：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ranks := make(map[string]int)   //创建一个映射并声明一个用于保存它的变量
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;映射的赋值与取值语法跟数组和切片类似，但数组和切片仅允许使用整型作为元素索引，映射可以选择几乎所有的类型来作为键。&lt;/p&gt;
&lt;p&gt;这是一个名为ranks的映射：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ranks[&amp;#34;gold&amp;#34;] = 1
ranks[&amp;#34;silver&amp;#34;] = 2
ranks[&amp;#34;bronze&amp;#34;] = 3
fmt.Println(ranks[&amp;#34;bronze&amp;#34;])
fmt.Println(ranks[&amp;#34;gole&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个键和值都使用string的映射：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;elements := make(map[string]string)
elements[&amp;#34;H&amp;#34;] = &amp;#34;Hydrogen&amp;#34;
elements[&amp;#34;Li&amp;#34;] = &amp;#34;Lithium&amp;#34;
fmt.Println(elements[&amp;#34;Li&amp;#34;])
fmt.Println(elements[&amp;#34;H&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用整型作为键，bool类型作为值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;isPrime := make(map[int]bool)
isPrime[4] = false
isPrime[7] = true
fmt.Println(isPrime[4])
fmt.Println(isPrime[7])
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;映射字面量&#34;&gt;映射字面量&lt;/h1&gt;
&lt;p&gt;若预先知道映射的键和值，可以使用字面量来创建映射，映射字面量是以映射类型（以“映射[键类型]值类型”的形式）开始，后面跟花括号，内含想要映射初始就包含的 键/值 对。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;myMap := map[string]float64{&amp;#34;a&amp;#34;: 1.2, &amp;#34;b&amp;#34;: 5.6}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ranks := map[string]int{&amp;#34;bronze&amp;#34;: 3, &amp;#34;silver&amp;#34;: 2, &amp;#34;gold&amp;#34;: 1}
fmt.Println(ranks[&amp;#34;gold&amp;#34;])
fmt.Println(ranks[&amp;#34;bronze&amp;#34;])
elements := map[string]string{
        &amp;#34;H&amp;#34;: &amp;#34;Hydrogen&amp;#34;,
        &amp;#34;Li&amp;#34;: &amp;#34;Lithium&amp;#34;,
}   //多行映射字面量
fmt.Println(elements[&amp;#34;H&amp;#34;])
fmt.Println(elements[&amp;#34;Li&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与切片字面量一样，花括号为空创建一个空的映射：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;emptyMap := map[string]float64{}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;映射中的零值&#34;&gt;映射中的零值&lt;/h1&gt;
&lt;p&gt;对于数组和切片，若访问一个没有赋值过的键，会得到一个零值，根据值类型 不行，零值不一定是0。比如映射的值类型是string，零值就是空字符串。&lt;/p&gt;
&lt;p&gt;与数组和切片一样，零值可以更安全地修改映射的值，即使在没有给它赋值的情况下。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;counters := make(map[string]int)
counters[&amp;#34;a&amp;#34;]++
counters[&amp;#34;a&amp;#34;]++
counters[&amp;#34;c&amp;#34;]++
fmt.Println(counters[&amp;#34;a&amp;#34;], counters[&amp;#34;b&amp;#34;], counters[&amp;#34;c&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;映射变量的零值是nil&#34;&gt;映射变量的零值是nil&lt;/h1&gt;
&lt;p&gt;与切片一样，映射变量的零值是nil，若声明了一个映射变量但未赋值，是nil，意味着没有映射存在来增加键或值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var nilMap map[int]string
fmt.Printf(&amp;#34;%#v\n&amp;#34;, nilMap)
nilMap[3] = &amp;#34;three&amp;#34;   //映射是nil，无法添加新值，会导致panic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在增加一个新的键值对前，需要使用make或映射字面量来创建一个映射，并赋值给映射变量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myMap map[int]string = make(map[int]string)
myMap[3] = &amp;#34;three&amp;#34;
fmt.Printf(&amp;#34;%#v\n&amp;#34;, myMap)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;如何区分已经赋值的值和零值&#34;&gt;如何区分已经赋值的值和零值&lt;/h1&gt;
&lt;p&gt;虽然零值很有用，但无法判断一个键是被赋值成了零值还是未赋值。&lt;/p&gt;
&lt;p&gt;有一个例子：错误输出了名为 Carl 的人没有通过，实际上并没有记录他的成绩。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func status(name string) {
        grades := map[string]float64{&amp;#34;Alma&amp;#34;: 0, &amp;#34;Rohit&amp;#34;: 86.5}
        grade := grades[name]
        if grade &amp;lt; 60 {
                fmt.Printf(&amp;#34;%s is failing!\n&amp;#34;, name)
        }
}
func main() {
        status(&amp;#34;Alma&amp;#34;)   //一个映射中已经被赋值为0的键
        status(&amp;#34;Carl&amp;#34;)   //一个映射中未被赋值的键
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Alma is failing!
Carl is failing!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为解决此问题，访问映射键的时候可选地获取第2个布尔类型的值，若这个键已经被赋过值，返回true，否则返回false。通常情况下，开发者会将这个布尔值赋给一个名为&lt;code&gt;ok&lt;/code&gt;的变量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;counters := map[string]int{&amp;#34;a&amp;#34;: 3, &amp;#34;b&amp;#34;, 0}
var value int
var ok bool
value, ok = counters[&amp;#34;a&amp;#34;]   //访问一个已经被赋值过的值
fmt.Println(value, ok)      //ok会返回true
value, ok = counters[&amp;#34;b&amp;#34;]   //访问一个已经被赋值过的值
fmt.Println(value, ok)      //ok会返回true
value, ok = counters[&amp;#34;c&amp;#34;]   //访问一个未赋值过的值
fmt.Println(value, ok)      //ok会返回false
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若仅仅要测试值是否存在，可以通过将其赋值给 &lt;code&gt;_&lt;/code&gt; 空白标识符来忽略值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;counters := map[string]int{&amp;#34;a&amp;#34;: 3, &amp;#34;b&amp;#34;: 0}
var ok bool
_, ok = counters[&amp;#34;b&amp;#34;]   //测试值是否存在，但忽略值
fmt.Println(ok)
_, ok = counters[&amp;#34;c&amp;#34;]   //测试值是否存在，但忽略值
fmt.Println(ok)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二个返回值可以用来判断如何处理这个值，是已经赋值了但是正好等于零值，还是从未被赋值过。&lt;/p&gt;
&lt;p&gt;修改后：在输出不及格前测试请求的名字是否已经被赋值过。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func  status(name string) {
       grades := map[string]float64{&amp;#34;Alma&amp;#34;: 0, &amp;#34;Rohit&amp;#34;: 86.4}
       grade, ok := grades[name]
       if !ok {
               fmt.Printf(&amp;#34;No grade recorded for %s.\n&amp;#34;, name)
       } else if grade &amp;lt; 60 {
               fmt.Printf(&amp;#34;%s is failing!\n&amp;#34;, name)
       }
}

func main() {
       status(&amp;#34;Alma&amp;#34;)
       status(&amp;#34;Carl&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;练习：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;data := []string{&amp;#34;a&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;e&amp;#34;}   //需计算在切片中的每个字母的次数
counts := make(map[string]int)    //保存计数的映射
for _, item := range data {
        counts[item]++     //增加当前字母的次数
}    //处理每个字符
letters := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}   //是否这些字符都在映射中存在
for _, letter := range letters {
        count, ok := counts[letters]    //获取当前字符的计数以及是否出现的指示
        if !ok {   //如果字母未找到
                fmt.Printf(&amp;#34;%s: not found\n&amp;#34;, letter)
        } else {   //如果字母找到
                fmt.Printf(&amp;#34;%s: %d\n&amp;#34;, letter, count)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a:2
b:not found
c:1
d:not found
e:2
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用delete函数删除键值对&#34;&gt;使用&amp;quot;delete&amp;quot;函数删除键/值对&lt;/h1&gt;
&lt;p&gt;在分配了值之后，某个时候希望将其从映射中移除，go提供了内建的&lt;code&gt;delete&lt;/code&gt;函数，只需传递给delete两个参数：希望删除数据的映射和希望删除的键，然后键和其关联的值都会被删除。&lt;/p&gt;
&lt;p&gt;如下代码，给两个映射的键分配了值，然后将其删除，之后，尝试访问，获取到零值。（对于ranks映射是0，对于isPrime映射是false）。第二个布尔返回值也是false，说明键已经被删除。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var ok bool
ranks := make(map[string]int)
var rank int
ranks[&amp;#34;bronze&amp;#34;] = 3   //给“bronze”键分配值
rank, ok = ranks[&amp;#34;bronze&amp;#34;]  //由于值存在，ok会返回true
fmt.Printf(&amp;#34;rank: %d, ok: %v\n&amp;#34;, rank, ok)
delete(ranks, &amp;#34;bronze&amp;#34;)   //删除键“bronze”和相关的值
rank, ok = ranks[&amp;#34;bronze&amp;#34;]   //由于值已经被删除了ok返回false
fmt.Printf(&amp;#34;rank: %d, ok: %v\n&amp;#34;, rank, ok)

isPrime := make(map[int]bool)
var prime bool
isPrime[5] = true  //给键5分配值
prime, ok = isPrime[5]  //由于值存在，ok会返回true
fmt.Printf(&amp;#34;prime: %v, ok: %v\n&amp;#34;, prime, ok)
delete(isPrime, 5)   //删除键5和相关的值
prime, ok = isPrime[5]   //由于值被删除，ok会返回false
fmt.Printf(&amp;#34;prime: %v, ok: %v\n&amp;#34;, prime, ok)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rank: 3, ok: true
rank: 0, ok: false
prime: true, ok: true
prime: false, ok: false
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用映射来更新程序&#34;&gt;使用映射来更新程序&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/datafile&amp;#34;
        &amp;#34;log&amp;#34;
)
func main() {
        lines, err := datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
        if err != nil {
                log.Fatal(err)
        }
        counts := make(map[string]int)   //声明一个以人名为键，次数为值的映射
        for _, line := range lines {
                counts[lines]++     //为人名增加计数
        }
        fmt.Println(counts)   //输出填充的映射
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;对映射进行forrange循环&#34;&gt;对映射进行&amp;quot;for&amp;hellip;range&amp;quot;循环&lt;/h1&gt;
&lt;p&gt;为了从映射中格式化每个键和值作为一行，需要使用循环遍历映射中的每一条。&lt;/p&gt;
&lt;p&gt;与数组和切片的 for&amp;hellip;range 循环一样，与将一个整数索引赋值给第一个变量不同，映射将键赋给了第一个变量。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/7-%e6%98%a0%e5%b0%84/%e6%98%a0%e5%b0%84for...range%e5%be%aa%e7%8e%af.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;for&amp;hellip;range 循环让遍历映射中的键和值更方便，仅用一个变量保存键，再用一个变量保存值，并会自动遍历映射中的每一个条目。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import &amp;#34;fmt&amp;#34;
func main() {
        grades := map[string]float64{&amp;#34;Alma&amp;#34;: 74.2, &amp;#34;Rohit&amp;#34;: 86.5, &amp;#34;Carl&amp;#34;: 59.7}
        for name, grade := range grades {
                fmt.Printf(&amp;#34;%s has a grade of %0.1f%%\n&amp;#34;, name, grade)  //打印每一个键和它对应的值
        }  //循环遍历每一个键/值对
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Carl has a grade of 59.7%
Alma has a grade of 74.2%
Rohit has a grade of 86.5%
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若只需要循环所有的键，可以忽略对应的值变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(&amp;#34;Class roster:&amp;#34;)
for name := range grades {
        fmt.Println(name)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Class roster:
Alma
Rohit
Carl
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若只需要值，可以将键赋 _ 空白标识符：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(&amp;#34;Grades:&amp;#34;)
for _, grade := range grades {
        fmt.Println(grade)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Grades:
59.7
74.2
86.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有个问题，如果将之前的结果存入一个文件，并执行，会发现映射的键和值是按照随机顺序打印，若多次执行，每次的结果顺序是不一样的。&lt;/p&gt;
&lt;h1 id=&#34;forrange循环以随机顺序处理映射&#34;&gt;&amp;ldquo;for&amp;hellip;range&amp;quot;循环以随机顺序处理映射&lt;/h1&gt;
&lt;p&gt;for&amp;hellip;range 以随机的顺序遍历映射的键和值，因为映射是一个非有序的键/值对集合。但有时需要按照特定的顺序遍历时，要自己写一些代码了。&lt;/p&gt;
&lt;p&gt;例子：使名字按照字母表的顺序输出，使用了两个for循环，第一个循环遍历映射里边所有的键，忽略值，并把其增加到一个字符串的切片上，然后把切片传递给sort包中的Strings函数来以字母表顺序排序。第二个for循环并不遍历映射，而是遍历变量排序后的名字的切片，输出名字，并从映射中获取与名字对应的值，仍然处理映射中的每一个键和值，但是从已排序好的切片中获取而不是从映射中获取的键。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;sort&amp;#34;
)

func main() {
        grades := map[string]float64{&amp;#34;Alma&amp;#34;: 74.2, &amp;#34;Rohit&amp;#34;: 86.5, &amp;#34;Carl&amp;#34;: 59.7}
        var names []string
        for name := range grades {
                names = append(names, name)
        }
        sort.Strings(names)
        for _, name := range names {
                fmt.Printf(&amp;#34;%s has a grade of %0.1f%%\n&amp;#34;, name, grades[name])
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按照以上代码执行，名字是按照字母表顺序排列，不管执行多少次都是如此。&lt;/p&gt;
&lt;p&gt;若不在乎映射中的数据如何处理，使用for&amp;hellip;range循环就可以，但若是需要顺序，就需要自己写代码处理排序问题。&lt;/p&gt;
&lt;h1 id=&#34;使用forrange更新程序&#34;&gt;使用for&amp;hellip;range更新程序&lt;/h1&gt;
&lt;p&gt;将打印整个映射的行用for&amp;hellip;range替换，把键赋给name变量，把映射的值赋值给count变量，然后用printf输出人命和得票数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/datafile&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        lines, err := datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
        if err != nil {
                log.Fatal(err)       
        }
        counts := make(map[string]int)
        for _, line := range lines {
                counts[line]++
        }
        for name, count := range counts {
                fmt.Printf(&amp;#34;Votes for %s: %d\n&amp;#34;, name, count)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当可用的数据集合是数组和切片时，需要很多额外的代码和处理时间来查找，但使用映射处理起来更简便。&lt;/p&gt;
&lt;p&gt;当需要查找集合中的值的时候，可以考虑映射！&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>