<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 承离的觉前</title>
    <link>https://tinklespring.com/categories/linux/</link>
    <description>Recent content in Linux on 承离的觉前</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 25 May 2023 13:37:48 +0800</lastBuildDate>
    
        <atom:link href="https://tinklespring.com/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>13.goroutine和channel</title>
      <link>https://tinklespring.com/posts/13.goroutine%E5%92%8Cchannel/</link>
      <pubDate>Sat, 19 Aug 2023 16:25:28 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/13.goroutine%E5%92%8Cchannel/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;一次只做一件事并不总是完成任务最快的方法。goroutine可以让程序同时处理几个不同的任务，goroutine可以使用channel来协调它们的工作，channel允许goroutine互相发送数据并同步，这样一个goroutine就不会领先与另一个goroutine。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;检索网页&#34;&gt;检索网页&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>12.从失败中恢复</title>
      <link>https://tinklespring.com/posts/12.%E4%BB%8E%E5%A4%B1%E8%B4%A5%E4%B8%AD%E6%81%A2%E5%A4%8D/</link>
      <pubDate>Thu, 17 Aug 2023 18:08:56 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/12.%E4%BB%8E%E5%A4%B1%E8%B4%A5%E4%B8%AD%E6%81%A2%E5%A4%8D/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;每个程序都会遇到错误，有时处理错误可以像报告错误并退出程序一样简单，但其他错误可能需要额外的操作，比如需要关闭打开的文件或网络链接，或者以其他方式清理，这样程序不会混乱。本篇将展示如何延迟清理操作，以便在出现错误时也能执行这些操作；还将展示如何在适当的情况下使程序出现panic，以及如何在事后恢复。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;从文件中读取数字重新访问&#34;&gt;从文件中读取数字，重新访问&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;os&amp;#34;
	&amp;#34;strconv&amp;#34;
)

func OpenFile(fileName string) (*os.File, error) {
	fmt.Println(&amp;#34;Opening&amp;#34;, fileName)
	return os.Open(fileName) //打开文件并返回指向该文件的指针，以及遇到的任何错误
}
func CloseFile(file *os.File) {
	fmt.Println(&amp;#34;Closing file&amp;#34;)
	file.Close() //关闭文件
}

func GetFloats(fileName string) ([]float64, error) {
	var numbers []float64
	file, err := OpenFile(fileName) //不是直接调用os.Open，而是调用OpenFile
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		number, err := strconv.ParseFloat(scanner.Text(), 64)
		if err != nil {
			return nil, err
		}
		numbers = append(numbers, number)
	}
	CloseFile(file) //不是直接调用file.Close，而是调用CloseFile
	if scanner.Err() != nil {
		return nil, scanner.Err()
	}
	return numbers, nil
}

func main() {
	numbers, err := GetFloats(os.Args[1]) //存储从文件中读取的数字切片以及任何错误，使用第一个命令行参数作为文件名
	if err != nil {                       //如果有错误，记录并退出
		log.Fatal(err)
	}
	var sum float64 = 0
	for _, number := range numbers { //把切片中的所有数字加起来
		sum += number
	}
	fmt.Printf(&amp;#34;Sum: %0.2f\n&amp;#34;, sum) //打印总和
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们希望将要读取的文件名称指定为命令行参数，因此在main函数中，通过访问 &lt;code&gt;os.Args[1]&lt;/code&gt; 从第一个命令行参数获取要打开文件的名称。（&lt;code&gt;os.Args[0]&lt;/code&gt;元素是正在运行的程序的名称，实际的程序参数出现在os.Args[1]和后面的元素中）。&lt;/p&gt;
&lt;p&gt;然后将文件名传递给GetFloats来读取文件，并得到一个返回float64值的切片。如果在这个过程中遇到任何错误，它们将从GetFloats函数返回，将把它们存储在err变量中，若err不是nil，意味着有错误，只需记录并退出。否则意味着文件被成功读取，使用for循环将切片中的每个值相加，并打印总和。&lt;/p&gt;
&lt;p&gt;data.txt:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1.25
8.75
5.0
10.5
15.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# go run sum.go data.txt
Opening 123.txt
Closing file
Sum: 41.00
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;任何错误都阻止关闭文件&#34;&gt;任何错误都阻止关闭文件&lt;/h1&gt;
&lt;p&gt;但是如果提供了一个格式不正确的文件，就会出现问题，比如文件的行不能解析为float64。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;20.25
hello   //无法解析为float64
123.11
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是正常的，因为每个程序都会遇到接收无效数据的情况，但是GetFloats函数在完成后，调用CloseFile函数，实际上却没有调用。&lt;/p&gt;
&lt;p&gt;当对无法转换为float64的字符串调用strconv.ParseFloat时，返回一个错误，我们的代码被设置为在此时从GetFloats函数返回，但是这个返回发生在调用CloseFile之前，这意味着文件永远不会被关闭。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func GetFloats(fileName string) ([]float64, error) {
	var numbers []float64
	file, err := OpenFile(fileName)
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		number, err := strconv.ParseFloat(scanner.Text(), 64) //当不能将文本行转换为float64时，ParseFloat返回一个错误，这回导致GetFloats返回一个错误
		if err != nil {
			return nil, err
		}
		numbers = append(numbers, number)
	}
	CloseFile(file)  //CloseFile永远不会被调用
	if scanner.Err() != nil {
		return nil, scanner.Err()
	}
	return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;延迟函数调用&#34;&gt;延迟函数调用&lt;/h1&gt;
&lt;p&gt;关闭文件失败似乎没什么大不了，对于一个只打开一个文件的简单程序来说，可能没问题，但是每个打开的文件都会消耗操作系统的资源，打开文件越多可能会累积并导致程序失败，甚至影响操作系统。&lt;/p&gt;
&lt;p&gt;如果有一个无论如何都希望运行的函数调用，可以使用&lt;code&gt;defer&lt;/code&gt;语句。可以将defer关键字放在任何普通函数或方法调用&lt;code&gt;之前&lt;/code&gt;，Go将延迟执行函数调用，直到当前函数退出之后。&lt;/p&gt;
&lt;p&gt;通常来说，函数调用一遇到就立即执行：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func Socialize() {
        fmt.Println(&amp;#34;Goodbye!&amp;#34;)
        fmt.Println(&amp;#34;Hello!&amp;#34;)
        fmt.Println(&amp;#34;Nice!&amp;#34;)
}

func main() {
        Socialize()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，如果在调用fmt.Println(&amp;ldquo;Goodbye!&amp;rdquo;) 之前添加defer关键字，则在Socialize函数中的所有剩余代码运行之前以及Socialize退出之前，该调用不会执行。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func Socialize() {
        defer fmt.Println(&amp;#34;Goodbye!&amp;#34;)  //在函数调用之前添加defer关键字
        fmt.Println(&amp;#34;Hello!&amp;#34;)
        fmt.Println(&amp;#34;Nice!&amp;#34;)
}

func main() {
        Socialize()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hello!
Nice!
Goodbye!   //第一个函数调用被推迟到Socialize退出之后
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用延迟函数调用从错误中恢复&#34;&gt;使用延迟函数调用从错误中恢复&lt;/h1&gt;
&lt;p&gt;defer 用于“无论如何”都需要发生的函数调用：
defer 关键字通过使用return 关键字确保函数调用发生，即使调用函数提前退出。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;log&amp;#34;
)

func Socialize() error {
        defer fmt.Println(&amp;#34;Goodbye!&amp;#34;)
        fmt.Println(&amp;#34;Hello!&amp;#34;)
        return fmt.Errorf(&amp;#34;I don&amp;#39;t want to talk.&amp;#34;)
        fmt.Println(&amp;#34;Nice!&amp;#34;)  //不会运行
        return nil  //不会运行
}

func main() {
        err := Socialize()
        if err != nil {
                log.Fatal(err)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hello!
Goodbye!
2023/08/18 10:38:37 I don&amp;#39;t want to talk.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;defer 关键字确保函数调用发生，即使调用函数提前退出。&lt;/p&gt;
&lt;p&gt;当return语句被执行时：&lt;br&gt;
1.return语句首先计算其返回值（如果有的话），并保存在内部变量中；
2.执行所有defer语句；
3.实际返回已保存的返回值，并退出函数；&lt;/p&gt;
&lt;p&gt;在Socialize函数中的return语句被执行时，首先保存了要返回的错误值，然后执行defer，最后再执行return返回错误值，退出函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;先执行defer，最后执行return&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用延迟函数调用确保文件关闭&#34;&gt;使用延迟函数调用确保文件关闭&lt;/h1&gt;
&lt;p&gt;因为defer关键字可以确保“无论如何”都执行函数调用，所以通常用于需要运行的代码，即使在出现错误的情况下也是如此，比如在文件打开后关闭它们。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func GetFloats(fileName string) ([]float64, error) {
	var numbers []float64
	file, err := OpenFile(fileName) //不是直接调用os.Open，而是调用OpenFile
	if err != nil {
		return nil, err
	}
	defer CloseFile(file) //添加defer，这样即使函数退出后也会执行，并将其移动到OpenFile之后
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		number, err := strconv.ParseFloat(scanner.Text(), 64)
		if err != nil {
			return nil, err  //即使返回错误，CloseFile仍然会被调用
		}
		numbers = append(numbers, number)
	}
	if scanner.Err() != nil {
		return nil, scanner.Err()  //如果函数正常完成，就会调用CloseFile
	}
	return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用defer可以确保在GetFloats退出时调用CloseFile，不管它是正常完成还是解析文件出错。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;问：是否可以延迟其他语句，比如for循环或者变量赋值？&lt;/p&gt;
&lt;p&gt;答：不可以，只能延迟函数和方法调用，可以编写一个函数或方法，然后延迟对函数或方法的调用，但是defer关键字本身只能与函数或方法调用一起使用。&lt;/p&gt;
&lt;h1 id=&#34;列出目录中的文件&#34;&gt;列出目录中的文件&lt;/h1&gt;
&lt;p&gt;Go还有一些特性可以帮助处理错误。&lt;/p&gt;
&lt;p&gt;创建一个名为my_directory的内容，指出它包含的每个项的名称，以及它是文件还是子目录。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;├── my_directory
│   ├── a.txt
│   ├── subdir
│   └── z.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;io/ioutil 包 包含一个ReadDir函数，允许读取目录内容，向ReadDir传递一个目录的名称，将返回一个值切片，每个值切片对应目录包含的每个文件或子目录（以及遇到的任何错误）。&lt;/p&gt;
&lt;p&gt;每个切片的值都满足FileInfo接口，该接口包括一个返回文件名的Name方法和一个如果是目录则返回true的IsDir方法。&lt;/p&gt;
&lt;p&gt;因此，程序调用ReadDir，将my_directory的名称作为参数传递给它，然后循环遍历返回的切片中的每个值，如果IsDir返回值为true，将打印“Directory: ” 和文件名，否则将打印“File: ” 和文件名。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;io/ioutil&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        files, err := ioutil.ReadDir(&amp;#34;my_directory&amp;#34;)  //获取一个包含代表&amp;#34;my_directory&amp;#34;的内容的值的切片
        if err != nil {
                log.Fatal(err)
        }
        for _, file := range files {   //对于切片中的每个文件。。。
		if file.IsDir() {  //如果文件是一个目录...
                        fmt.Println(&amp;#34;Directory:&amp;#34;, file.Name())
		} else {  //否则，打印...
                        fmt.Println(&amp;#34;File:&amp;#34;, file.Name())
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;File: a.txt
Directory: subdir
File: z.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序运行并生成my_directory所包含的文件和目录的列表。&lt;/p&gt;
&lt;p&gt;读取单个目录内容的程序不复杂，但是若想列出更复杂的内容，比如Go工作区目录，它将包含嵌套在子目录中的整个子目录树，有些包含文件，有些不包含。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;├── go
│   └── src
│       ├── geo
│       │   ├── coordinates.go
│       │   └── landmark.go
│       ├── locked
│       │   └── secret.go
│       └── vehicle
│           └── car.go
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;递归函数调用&#34;&gt;递归函数调用&lt;/h1&gt;
&lt;p&gt;递归允许函数调用自身。&lt;/p&gt;
&lt;p&gt;若不小心，会得到一个无限循环，函数会不停调用自己：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func recurses() {
        fmt.Println(&amp;#34;Oh, no, I&amp;#39;m stuck!&amp;#34;)
        recurses()  //函数调用自己
}

func main() {
        recurses()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Oh, no, I&amp;#39;m stuck!
Oh, no, I&amp;#39;m stuck!
Oh, no, I&amp;#39;m stuck!
Oh, no, ^Csignal: interrupt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是如果能确保递归循环能停止，其实递归是有用的。&lt;/p&gt;
&lt;p&gt;这是一个递归count函数，从第一个数到最后一个数进行计数（通常来说循环更有效，这里仅演示递归工作原理）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func count(start int, end int) {
        fmt.Println(start)   //打印当前的起始数
        if start &amp;lt; end {  //如果还没有达到结束数字
                count(start+1, end)  //“count”函数使用比之前多1的起始数调用自身
        }
}

func main() {
        count(1, 3)  //第一次调用“count”，指定它应该从1到3计数
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序的顺序：&lt;br&gt;
1.main使用起始（start）参数1和结束（end）参数3调用count；&lt;/p&gt;
&lt;p&gt;2.count打印起始参数1；&lt;/p&gt;
&lt;p&gt;3.start(1) 小于end(3)，因此count以起始数2和结束数3调用自己；&lt;/p&gt;
&lt;p&gt;4.第二次调用count将打印其新的起始参数：2；&lt;/p&gt;
&lt;p&gt;5.start(2) 小于end(3)，因此count以起始数3和结束数3调用自己；&lt;/p&gt;
&lt;p&gt;6.第三次调用count将打印其新的起始参数：3；&lt;/p&gt;
&lt;p&gt;7.start(3) 不小于end(3)，因此count不再调用自己，只是返回；&lt;/p&gt;
&lt;p&gt;8.前两次count调用也返回了，程序结束。&lt;/p&gt;
&lt;p&gt;若再添加对Printf调用，来显示每次count的调用和输出，这个程序更明显：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func count(start int, end int) {
        fmt.Printf(&amp;#34;count(%d, %d) called\n&amp;#34;, start, end)
        fmt.Println(start)
        if start &amp;lt; end {
                count(start+1, end)
        }
        fmt.Printf(&amp;#34;Returning from count(%d, %d) call\n&amp;#34;, start, end)
}

func main() {
        count(1, 3)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;count(1, 3) called
1
count(2, 3) called
2
count(3, 3) called
3
Returning from count(3, 3) call
Returning from count(2, 3) call
Returning from count(1, 3) call
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;递归列出目录内容&#34;&gt;递归列出目录内容&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;io/ioutil&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;path/filepath&amp;#34;
)

func scanDirectory(path string) error { //递归函数，接受要扫描的路径，返回遇到的任何错误
	fmt.Println(path)                  //打印当前目录
	files, err := ioutil.ReadDir(path) //获取包含目录内容的切片
	if err != nil {
		return err
	}
	for _, file := range files {
		filePath := filepath.Join(path, file.Name()) //应斜杠将目录路径和文件名连接起来
		if file.IsDir() {                            //如果这是一个目录
			err := scanDirectory(filePath) //递归调用scanDirectory，这次是用子目录的路径
			if err != nil {
				return err
			}
		} else {
			fmt.Println(filePath) //如果这是一个普通文件，只需打印它的路径
		}
	}
	return nil
}

func main() {
	err := scanDirectory(&amp;#34;go&amp;#34;) //通过对顶部目录调用scanDirectory来启动该过程
	if err != nil {
		log.Fatal(err)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出；&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
go/src
go/src/geo
go/src/geo/coordinates.go
go/src/geo/landmark.go
go/src/locked
go/src/locked/secret.go
go/src/vehicle
go/src/vehicle/car.go
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;scanDirectory第一件事是打印当前路径，这样就知道我们在哪个目录下工作，然后它对该路径调用ioutil.ReadDir来获取目录的内容。&lt;/p&gt;
&lt;p&gt;循环遍历ReadDir返回FileInfo值切片，处理每个值，调用filepath.Join将当前目录路径与当前文件名用斜杠连接起来（因此&amp;quot;go&amp;quot;和&amp;quot;src&amp;quot;被连接成&amp;quot;go/src&amp;quot;）。&lt;/p&gt;
&lt;p&gt;如果当前文件不是一个目录，scanDirectory只打印其完整卢金个，然后移动到下一个文件（如果当前目录中有其他文件）。&lt;/p&gt;
&lt;p&gt;但是如果当前文件是一个目录，则会启动递归：scanDirectory使用该子目录的路径调用自己，如果该子目录有任何子目录，那么scanDirectory将使用每个子目录来调用自己，以此类推，遍历整个文件数。&lt;/p&gt;
&lt;p&gt;过程：&lt;br&gt;
1.main使用“go”路径调用scanDirectory；&lt;/p&gt;
&lt;p&gt;2.scanDirectory打印它所传递的路径“go”，代表它所工作的目录；&lt;/p&gt;
&lt;p&gt;3.使用“go”路径调用 ioutil.ReadDir;&lt;/p&gt;
&lt;p&gt;4.返回的切片中只有一条内容：“src”；&lt;/p&gt;
&lt;p&gt;5.对“go”的当前目录路径和“src”文件名调用filepath.Join，得到新路径“go/src”;&lt;/p&gt;
&lt;p&gt;6.src 是一个子目录，所以再次调用 scanDirectory，这次使用的路径是 &amp;ldquo;go/src&amp;rdquo;，&amp;lt;&amp;ndash;递归&lt;/p&gt;
&lt;p&gt;7.scanDirectory打印新路径：“go/src”&lt;/p&gt;
&lt;p&gt;8.使用“go/src”路径调用 ioutil.ReadDir ;&lt;/p&gt;
&lt;p&gt;9.返回的切片中的第一条内容是“geo”；&lt;/p&gt;
&lt;p&gt;10.对“go/src”的当前目录路径和“geo”文件名调用filepath.Join，得到新路径“go/src/geo”；&lt;/p&gt;
&lt;p&gt;11.geo是一个子目录，因此再次调用 scanDirectory，这次使用的路径是 “go/src/geo”；&lt;/p&gt;
&lt;p&gt;12.scanDirectory打印新路径&amp;quot;go/src/geo&amp;quot;;&lt;/p&gt;
&lt;p&gt;13.使用“go/src/geo”路径调用ioutil.ReadDir;&lt;/p&gt;
&lt;p&gt;14.返回的切片中第一条内容是“coordinates.go”;&lt;/p&gt;
&lt;p&gt;15.coordinates.go不是目录，所以只打印名字；&lt;/p&gt;
&lt;p&gt;16.以此类推。。。&lt;/p&gt;
&lt;p&gt;递归函数比较难写，并且通常会比非递归解决方式消耗更多的计算资源，但有时候递归函数可以解决用其他方式难以解决的问题。&lt;/p&gt;
&lt;h1 id=&#34;递归函数中的错误处理&#34;&gt;递归函数中的错误处理&lt;/h1&gt;
&lt;p&gt;如果scanDirectory在扫描任何子目录时遇到错误，比如没有访问该目录的权限，将返回一个错误。&lt;/p&gt;
&lt;p&gt;添加两个Printf语句来显示返回的错误，会发现处理此错误的方式并不理想，如果在递归的scanDirectory调用中发生错误，则必须沿整个链返回该错误，直到main函数为止。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func scanDirectory(path string) error {
	fmt.Println(path)
	files, err := ioutil.ReadDir(path)
	if err != nil {
		fmt.Printf(&amp;#34;Returning error form scanDirectory(\&amp;#34;%s\&amp;#34;) call\n&amp;#34;, path)  //对ReadDir调用中的错误打印调试信息
		return err
	}
	for _, file := range files {
		filePath := filepath.Join(path, file.Name())
		if file.IsDir() {
			err := scanDirectory(filePath)
			if err != nil {
				fmt.Printf(&amp;#34;Returning error form scanDirectory(\&amp;#34;%s\&amp;#34;) call\n&amp;#34;, path)  //对递归的scanDirectory调用中的错误打印调试信息
				return err
			}
		} else {
			fmt.Println(filePath)
		}
	}
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;发起一个panic&#34;&gt;发起一个panic&lt;/h1&gt;
&lt;p&gt;以前遇到过panic，在访问数组和切片中的无效索引时。当类型断言失败时，也会看到：当程序出现panic时，当前函数停止运行，程序打印日志消息并崩溃。可以通过调用内置的panic函数来引发panic。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
func main() {
	panic(&amp;#34;oh, no, we&amp;#39;re going down&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: oh, no, we&amp;#39;re going down

goroutine 1 [running]:
main.main()
	/golang/panic.go:4 +0x39
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;panic函数需要一个满足空接口的参数（也就是说，它可以是任何类型），该参数将被转换为字符串（如果需要），并作为panic日志信息的一部分打印出来。&lt;/p&gt;
&lt;h1 id=&#34;堆栈跟踪&#34;&gt;堆栈跟踪&lt;/h1&gt;
&lt;p&gt;每个被调用的函数都需要返回到调用的它的函数，为了实现这一点，Go保持一个调用堆栈，即在任何给定点上处于活动状态的函数的调用的列表。&lt;/p&gt;
&lt;p&gt;当程序发生panic时，panic输出中包含堆栈跟踪，即调用堆栈列表，这对于确定导致程序崩溃的原因很有用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

func main() {
	one()
}
func one() {
	two()
}
func two() {
	three()
}
func three() {
	panic(&amp;#34;this call stack&amp;#39;s too deep for me!&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: this call stack&amp;#39;s too deep for me!

goroutine 1 [running]:
main.three(...)
	/golang/one.go:13
main.two(...)
	/golang/one.go:10
main.one(...)
	/golang/one.go:7
main.main()
	/golang/one.go:4 +0x3b
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;堆栈跟踪包括已执行的函数调用的列表。&lt;/p&gt;
&lt;h1 id=&#34;延迟调用在崩溃前完成&#34;&gt;延迟调用在崩溃前完成&lt;/h1&gt;
&lt;p&gt;当程序出现panic时，所有延迟的函数调用仍然会被执行，如果有多个延迟调用，它们的执行顺序将与被延迟的顺序相反。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
	one()
}
func one() {
	defer fmt.Println(&amp;#34;deferred in one()&amp;#34;)  //这个函数调用被延迟，所以排在最后执行
	two()
}
func two() {
	defer fmt.Println(&amp;#34;deferred in two()&amp;#34;)  //这个函数调用被延迟，所以排在最后执行
	panic(&amp;#34;Let&amp;#39;s see what&amp;#39;s been deferred!&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;deferred in two()
deferred in one()
panic: Let&amp;#39;s see what&amp;#39;s been deferred!

goroutine 1 [running]:
main.two()
	/golang/two.go:14 +0x95
main.one()
	/golang/two.go:10 +0x85
main.main()
	/golang/two.go:6 +0x20
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;通过scandirectory使用panic&#34;&gt;通过scanDirectory使用&amp;quot;panic&amp;quot;&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;io/ioutil&amp;#34;
	&amp;#34;path/filepath&amp;#34;
)

func scanDirectory(path string) { //不再需要返回错误值
	fmt.Println(path)
	files, err := ioutil.ReadDir(path)
	if err != nil {
		panic(err) //不返回错误值，而是将其传递给&amp;#34;panic&amp;#34;
	}
	for _, file := range files {
		filePath := filepath.Join(path, file.Name())
		if file.IsDir() {
			scanDirectory(filePath) //不再需要存储或检查错误返回值
		} else {
			fmt.Println(filePath)
		}
	}
}

func main() {
	scanDirectory(&amp;#34;go&amp;#34;) //不再需要存储或检查错误返回值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从scanDirectory声明中删除错误返回值，若从ReadDir返回一个error值，将其传递给panic，可以从对scanDirectory的递归调用中删除错误处理代码，也可以在main中从对scanDirectory的调用中删除错误处理代码。&lt;/p&gt;
&lt;p&gt;当scanDirectory在读取目录遇到错误时，就产生panic，所有对scanDirectory的递归调用都退出。&lt;/p&gt;
&lt;h1 id=&#34;何时产生panic&#34;&gt;何时产生panic&lt;/h1&gt;
&lt;p&gt;事实上，调用panic并不是处理错误的理想方法。&lt;/p&gt;
&lt;p&gt;无法访问的文件、网络故障和错误的用户输入通常是被允许的，应该通过错误值来进行适当的处理，通产，调用panic应该留给&amp;quot;不可能&amp;quot;的情况，比如错误表示的是程序中的错误，而不是用户方的错误。&lt;/p&gt;
&lt;p&gt;下面这个示例使用panic来指明一个bug。会颁发隐藏在三扇虚拟门中其中一扇门后面的奖品，doorNumber 变量不是由用户输入的，而是由rand.Intn函数选择的一个随机数，如果doorNumber 包含1、2或3以外的任何数字，就是程序的bug，而不是用户错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;math/rand&amp;#34;
	&amp;#34;time&amp;#34;
)

func awardPrize() {
	doorNumber := rand.Intn(3) + 1 //产生一个1到3之间的随机整数
	if doorNumber == 1 {
		fmt.Println(&amp;#34;you win a cruise!&amp;#34;)
	} else if doorNumber == 2 {
		fmt.Println(&amp;#34;you win a car!&amp;#34;)
	} else if doorNumber == 3 {
		fmt.Println(&amp;#34;you win a goat!&amp;#34;)
	} else {
		panic(&amp;#34;invalid door number&amp;#34;) //不应该产生其他数字，如果产生就panic
	}
}

func main() {
	rand.Seed(time.Now().Unix())
	awardPrize()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因此，假如doorNumber包含无效值，调用panic是有意义的。&lt;/p&gt;
&lt;h1 id=&#34;recover函数&#34;&gt;&amp;ldquo;recover&amp;quot;函数&lt;/h1&gt;
&lt;p&gt;将scanDirectory函数改为使用panic而不是返回错误，这大大简化了错误处理代码，但panic也会导致程序崩溃，出现难看的堆栈跟踪，宁愿只显示错误信息。&lt;/p&gt;
&lt;p&gt;Go提供了一个内置的&lt;code&gt;recover&lt;/code&gt;函数，可以阻止程序陷入panic，需要使用它来体面的退出程序。&lt;/p&gt;
&lt;p&gt;正常程序执行过程中调用recover时，只返回nil，而不执行其他操作：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
	fmt.Println(recover())  //如果在一个程序中调用&amp;#34;recover&amp;#34;，而这个程序没有panic...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;nil&amp;gt;  //什么都不做，返回nil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果在程序处于panic状态时调用recover，将停止panic，但是当在函数中调用panic时，该函数将停止执行。因此，在panic所在的同一个函数中调用recover没有意义，因为panic无论如何都会继续：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func freakOut() {
	panic(&amp;#34;oh no&amp;#34;)  //panic阻止了freakOut函数的其余部分运行
	recover()
}
func main() {
	freakOut()
	fmt.Println(&amp;#34;Exiting normally&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: oh no

goroutine 1 [running]:
main.freakOut()
	/golang/freakOut.go:6 +0x39
main.main()
	/golang/freakOut.go:11 +0x22
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，当程序panic时，有一种方式可以调用recover。在panic期间，任何延迟的函数调用都将完成，因此可以在一个单独的函数中放置一个recover调用，并在引发panic的代码之前使用defer调用该函数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	recover()
}
func freakOut() {
	defer calmDown()
	panic(&amp;#34;oh no&amp;#34;)
}
func main() {
	freakOut()
	fmt.Println(&amp;#34;Exiting normally&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用recover不会导致在出现panic时恢复执行，至少不会完全恢复。产生panic的函数将立即返回，而该函数块中panic之后的任何代码都不会执行。但是在产生panic的函数返回之后，正常的执行将恢复。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	recover()
}
func freakOut() {
	defer calmDown()
	panic(&amp;#34;oh no&amp;#34;)  //当恢复时freakOut在这个位置返回
	fmt.Println(&amp;#34;I won&amp;#39;t be run!&amp;#34;)  //panic之后的代码永远不会运行
}
func main() {
	freakOut()
	fmt.Println(&amp;#34;Exiting normally&amp;#34;)  //这段代码在freakOut返回后运行
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;panic值从recover中返回&#34;&gt;panic值从recover中返回&lt;/h1&gt;
&lt;p&gt;程序当没有panic时，调用recover返回nil，但是当出现panic时，&lt;code&gt;recover返回传递给panic的任何值&lt;/code&gt;，这可以用来收集有关panic的信息，帮助恢复或向用户报告错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	fmt.Println(recover())   //调用&amp;#34;recover&amp;#34;并打印panic值
}
func main() {
	defer calmDown()
	panic(&amp;#34;oh no&amp;#34;)  //将从&amp;#34;recover&amp;#34;返回的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;oh no
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;panic函数其参数类型是 interface{} ，即空接口，因此panic可以接收任何值。同样recover的返回值类型也是 interface{} ，可以将recover的返回值传递给诸如Println（它接受interface{}值）之类的fmt函数，但不能直接对其调用方法。&lt;/p&gt;
&lt;p&gt;将error值传递给panic，但这样做时，error被转换为一个空接口值，当延迟的函数稍后调用recover时，返回的是interface{}值，即使底层的error值有一个Error方法，试图调用interface{}值上的Error会导致编译错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	p := recover()  //返回一个空接口
	fmt.Println(p.Error())   //即使底层的“error”值有一个Error方法，但interface{}没有
}
func main() {
	defer calmDown()
	err := fmt.Errorf(&amp;#34;there&amp;#39;s an error&amp;#34;)
	panic(err)  //将错误值而不是字符串传递给“panic”
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;p.Error undefined (type interface{} is interface with no methods)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要对panic值调用方法或执行其他操作，需要使用类型断言将其转换回其底层类型：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func calmDown() {
	p := recover()
	err, ok := p.(error)  //断言panic值的类型为“error”
	if ok {
		fmt.Println(err.Error())  //现在有了一个“error”值，可以调用Error方法
	}
}
func main() {
	defer calmDown()
	err := fmt.Errorf(&amp;#34;there&amp;#39;s an error&amp;#34;)
	panic(err)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;there&amp;#39;s an error
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;从scandirectory中的panic恢复&#34;&gt;从scanDirectory中的panic恢复&lt;/h1&gt;
&lt;p&gt;添加一个reportPanic函数，在main中使用defer调用它，在调用scanDirectory前调用它，这可能会引起潜在的panic。&lt;/p&gt;
&lt;p&gt;在reportPanic中，调用recover并存储它返回的panic值，如果程序处于panic状态，这将会停止panic。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;io/ioutil&amp;#34;
	&amp;#34;path/filepath&amp;#34;
)

func reportPanic() {
	p := recover() //调用“recover”并存储它的返回值
	if p == nil {  //如果返回nil，则没有panic
		return
	}
	err, ok := p.(error) //否则，获取底层的“error”值
	if ok {
		fmt.Println(err) //然后打印出来
	}
}

func scanDirectory(path string) {
	fmt.Println(path)
	files, err := ioutil.ReadDir(path)
	if err != nil {
		panic(err)
	}
	for _, file := range files {
		filePath := filepath.Join(path, file.Name())
		if file.IsDir() {
			scanDirectory(filePath)
		} else {
			fmt.Println(filePath)
		}
	}
}

func main() {
	defer reportPanic() //在调用可能引起panic的代码前，延迟调用新reportPanic函数
	scanDirectory(&amp;#34;go&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果没有panic，从reportPanic返回，不做任何事情，若panic值不是nil，意味着出现了panic，因为scanDirectory将error值传递给panic，所以使用类型断言将 interface{}panic 值转换为error值，若转换成功，则打印error值。&lt;/p&gt;
&lt;p&gt;这样的话，程序输出只会看到错误信息，而不是难看的panic日志和堆栈跟踪。&lt;/p&gt;
&lt;h1 id=&#34;恢复panic&#34;&gt;恢复panic&lt;/h1&gt;
&lt;p&gt;reportPanic还存在一个潜在的问题，它可以拦截任何panic，即使不是来自scanDirectory，如果panic值不能转换为error类型，reportPanic将不会打印它。&lt;/p&gt;
&lt;p&gt;可以通过在main中使用一个string参数来添加另一个对panic的调用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	defer reportPanic()
	panic(&amp;#34;some other issue&amp;#34;)
	scanDirectory(&amp;#34;go&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   //没有输出
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;reportPanic函数从新的panic中恢复，但是因为panic值不是一个error，所以reportPanic不会打印它，我们不知道为什么程序失败了。&lt;/p&gt;
&lt;p&gt;有一种策略来处理不曾预料且不准备从中恢复的panic，即简单的恢复panic状态。&lt;/p&gt;
&lt;p&gt;如果将panic值转换为error的类型断言成功，只需像以前那样打印它，如果失败，只需用同样的panic值再次调用panic。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func reportPanic() {
	p := recover()
	if p == nil {
		return
	}
	err, ok := p.(error)
	if ok {
		fmt.Println(err)
	} else {
		panic(p) //如果panic值不是error，则使用相同的值恢复panic
	}
}

func scanDirectory(path string) {
// ...
}

func main() {
	defer reportPanic()
	panic(&amp;#34;some other issue&amp;#34;) //一旦确定reportPanic起作用，不要忘记删除这个测试panic
	scanDirectory(&amp;#34;go&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: some other issue [recovered]
	panic: some other issue

goroutine 1 [running]:
main.reportPanic()
	/golang/reportPanic_panic.go:18 +0xec
panic(0x10ab940, 0x10e8ff0)
	/usr/local/go/src/runtime/panic.go:969 +0x166
main.main()
	/golang/reportPanic_panic.go:40 +0x5b
exit status 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;reportPanic从我们对panic的测试调用中恢复了，但是当error类型断言失败，它将再次陷入panic。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Go语言本身的设计不鼓励使用panic和recover，Go鼓励以处理程序其他部分的方式处理错误，比如使用if和return语句，以及error值。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;练习：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func snack() {
	defer fmt.Println(&amp;#34;closing&amp;#34;)
	fmt.Println(&amp;#34;opening&amp;#34;)
	panic(&amp;#34;empty&amp;#34;)
}
func main() {
	snack()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;opening
closing  //这个调用被延迟，直到snack函数退出（在panic期间）才进行调用
panic: empty
....
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>11.接口</title>
      <link>https://tinklespring.com/posts/11.%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 14 Aug 2023 17:48:56 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/11.%E6%8E%A5%E5%8F%A3/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;有时并不关心一个值的特定类型，只需知道它能做特定的事情，能够在其上调用特定的接口。这就是Go接口的目标：允许定义能够保存任何类型的变量和函数参数，前提是定义了特定的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;具有相同方法的两种不同类型&#34;&gt;具有相同方法的两种不同类型&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package gadget

import &amp;#34;fmt&amp;#34;

type TapePlayer struct {
	Batteries string
}

func (t TapePlayer) Play(song string) {
	fmt.Println(&amp;#34;Playing&amp;#34;, song)
}
func (t TapePlayer) Stop() {
	fmt.Println(&amp;#34;Stopped!&amp;#34;)
}

type TapeRecorder struct {
	Microphones int
}

func (t TapeRecorder) Play(song, string) { //有个与TapePlayer相同的Play方法
	fmt.Println(&amp;#34;Playing&amp;#34;, song)
}
func (t TapeRecorder) Record() {
	fmt.Println(&amp;#34;Recording&amp;#34;)
}
func (t TapeRecorder) Stop() { //有个与TapePlayer相同的Stop方法
	fmt.Println(&amp;#34;Stopped!&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;TapePlayer类型有一个Play方法来模拟播放歌曲，一个Stop方法来停止播放，TapeRecorder类型也有Play和Stop方法，还有一个Record方法。&lt;/p&gt;
&lt;h1 id=&#34;只能接受一种类型的方法参数&#34;&gt;只能接受一种类型的方法参数&lt;/h1&gt;
&lt;p&gt;一个使用gadget包的示例：定义一个playList函数，接收一个TapePlayer值和一个在其上播放的一组歌名的切片，函数循环变量切片的每个歌名，并将它传递给TapePlayer的Play方法，当它播放列表后，调用TapePlayer的Stop方法。然后在main中，创建一个TapePlayer和一个歌单切片，并将其传递给playList。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;xxx/xxx/gadget&amp;#34;

func playList(device gadget.TapePlayer, songs []string) {
	for _, song := range songs { //循环每首歌曲
                device.Play(song)  //播放当前歌曲
	}
        device.Stop()  //播放完成后，停止播放
}

func main() {
        player := gadget.TapePlayer{}  //创建一个TapePlayer
        mixtape := []string{&amp;#34;Jessie&amp;#39;s Girl&amp;#34;, &amp;#34;Whip It&amp;#34;, &amp;#34;9 to 5&amp;#34;}  //创建一个歌名的切片
        playList(player, mixtape)  //使用TapePlayer播放歌曲
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Playing Jessie&amp;#39;s Girl
Playing Whip It
Playing 9 to 5
Stopped!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;PlayList函数使用TapePlayer值工作正常，但是希望它可以使用TapeRecorder作为参数，但playList函数需要一个TapePlayer类型，尝试传入其他类型会编译错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
         player := gadget.TapeRecorder{}
         mixtape := []string{&amp;#34;Jessie&amp;#39;s Girl&amp;#34;, &amp;#34;Whip It&amp;#34;, &amp;#34;9 to 5&amp;#34;}
         playList(player, mixtape)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;playList函数只接受TapePlayer值。&lt;/p&gt;
&lt;h1 id=&#34;接口&#34;&gt;接口&lt;/h1&gt;
&lt;p&gt;当在电脑上安装程序时，通常希望程序提供一种交互的方式，希望文字处理器提供键入文字的地方。这一组程序提供的用来交互的控制方法通常称为接口。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;一个接口是特定值预期具有的一组方法。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在Go中，一个接口被定义为特定值预期具有的一组方法，可以把接口看作需要类型实现的一组行为。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;interface&lt;/code&gt; 关键字定义一个接口类型，后面跟着一个花括号，内部含有一组方法，以及方法期望的参数和返回值。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/11-interface/interface.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;任何拥有接口定义的所有方法的类型被称作&lt;code&gt;满足那个接口&lt;/code&gt;，一个满足接口的类型可以用在任何需要接口的地方。&lt;/p&gt;
&lt;p&gt;方法名称、参数类型（可能没有）和返回值（可能没有）都需要与接口中定义的一致，除了接口中列出的方法外，类型还可以有更多的方法，但不能缺少接口中的任何方法，否则就不满足那个接口。&lt;/p&gt;
&lt;p&gt;一个类型可以满足多个接口，一个接口可以有多个类型满足它。&lt;/p&gt;
&lt;h1 id=&#34;定义满足接口的类型&#34;&gt;定义满足接口的类型&lt;/h1&gt;
&lt;p&gt;一个名为mypkg的包，定义了一个有三个方法的名为MyInterface的接口，然后定义了一个名字MyType的类型，正好可满足MyInterface。&lt;/p&gt;
&lt;p&gt;为了满足MyInterface接口需要有三个方法：MethodWithoutParameters方法，接受float64参数的MethodWithParameter方法，返回string类型的MethodWithReturnValue方法。然后声明另外一个类型MyType，为了使MyType满足MyInterface，定义了接口需要的所有方法，另外包含一个并不属于接口的额外的方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package mypkg

import &amp;#34;fmt&amp;#34;

type MyInterface interface {  //声明一个接口类型
        MethodWithoutParameters()  //一个类型满足接口，如果有这个方法
        MethodWithParameter(float64)
        MethodWithReturnValue() string
}

type MyType int  //声明一个类型，让它满足MyInterface

func (m MyType) MethodWithoutParameters() {  //第一个需要的方法
        fmt.Println(&amp;#34;MethodWithoutParameters called&amp;#34;)
}
func (m MyType) MethodWithParameter(f float64) {  //第二个需要的方法
        fmt.Println(&amp;#34;MethodWithParameter called with&amp;#34;, f)
}
func (m MyType) MethodWithReturnValue() string {  //第三个需要的方法
        return &amp;#34;Hi from MethodWithReturnValue&amp;#34;
}
func (my MyType) MethodNotInterface() {  //一个类型即使有额外的不属于接口的方法，仍可以满足接口
        fmt.Println(&amp;#34;MethodNotInterface called&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其他语言中可能需要明确，MyType满足MyInterface，但在Go中是自动发生的，若一个类型包含接口中声明的所有方法，那么它可以在任何需要接口的地方使用，而不需要更多声明。&lt;/p&gt;
&lt;p&gt;测试mypkg：一个接口类型的变量能够保存任何满足接口的类型的值，下面代码声明了一个MyInterface类型的名为value的变量，然后创建一个MyType的值并赋给value，（这样可以，因为Mytype满足MyInterface），然后可以在value上调用接口的任意方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;mypkg&amp;#34;
)

func main() {
        var value mypkg.MyInterface  //声明一个接口类型的变量
        value = mypkg.MyType(5)  //MyType的值满足MyInterface，所以可以将值赋给MyInterface的变量
        value.MethodWithoutParameters()
        value.MethodWithParameter(127.3)  //可以调用MyInterface的任何方法
        fmt.Println(value.MethodWithReturnValue())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MethodWithoutParameters called
MethodWithParameter called with 127.3
Hi from MethodWithReturnValue
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;接口只是一种约定或合同，描述了某种行为（方法），任何类型只要实现了这些方法，就可以说它“满足”了这个接口，这是Go多态性的基础。不需要像其他语言中那样显式说“这个类型实现了这个接口”，如果它有正确的方法，就自动满足接口。&lt;/p&gt;
&lt;p&gt;&amp;ldquo;类型满足接口&amp;quot;意味着可以写一个函数，它接受定义的接口作为参数，并期望该参数有其包含的方法，而不必关心这个参数的实际类型。&lt;/p&gt;
&lt;h1 id=&#34;具体类型和接口类型&#34;&gt;具体类型和接口类型&lt;/h1&gt;
&lt;p&gt;之前定义的所有类型都是具体类型，一个具体类型不仅定义了它的值可以做什么（在其上可以调用哪些方法），也定义了它们是什么：它们定义了保存值的数据的基础类型。&lt;/p&gt;
&lt;p&gt;接口类型并不描述哪个值，不会说它的基础类型是什么，或者数据如何存储，仅仅描述这个值能做什么（它有哪些方法）。&lt;/p&gt;
&lt;h1 id=&#34;分配满足接口的任何类型&#34;&gt;分配满足接口的任何类型&lt;/h1&gt;
&lt;p&gt;当有一个接口类型的变量时，它可以保存满足此接口的任何类型的值。&lt;/p&gt;
&lt;p&gt;有Whistle和Horn类型，都有MakeSound方法，可以创建一个NoiseMaker接口来代替声明了MakeSound方法的任何类型。若定义了NoiseMaker类型的toy变量，可以将Whistle和Horn值赋给它（或者之后定义的任何类型，只要它定义了MakeSound方法）。&lt;/p&gt;
&lt;p&gt;可以调用任何赋给toy变量的值的MakeSound方法，虽然并不知道toy保存的值的具体类型是什么，但我们知道它能做什么：发出声音。若它的类型没有MakeSound方法，那么不满足NoiseMaker接口，将无法赋变量它。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Whistle string

func (w Whistle) MakeSound() {  //有MakeSound方法
	fmt.Println(&amp;#34;Tweet!&amp;#34;)
}

type Horn string

func (h Horn) MakeSound() {  //同样有MakeSound方法
	fmt.Println(&amp;#34;Honk!&amp;#34;)
}

type NoiseMaker interface {  //代表任何含有MakeSound方法的类型
	MakeSound()
}

func main() {
	var toy NoiseMaker
	toy = Whistle(&amp;#34;Toyco Canary&amp;#34;)  //将一个满足NoiseMaker的类型的值赋给变量
	toy.MakeSound()
	toy = Horn(&amp;#34;Toyco Blaster&amp;#34;)  //将另一个满足NoiseMaker的类型的值赋给变量
	toy.MakeSound()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以将函数的参数定义为接口类型（毕竟函数参数也就是变量）。若声明一个play函数来接受NoiseMaker类型，可以传入任何包含了MakeSound方法的值来播放。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func play(n NoiseMaker) {
        n.MakeSound()
}

func main() {
        play(Whistle(&amp;#34;Toyco Canary&amp;#34;))
        play(Horn(&amp;#34;Toyco Blaster&amp;#34;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;只能调用接口中定义的方法&#34;&gt;只能调用接口中定义的方法&lt;/h1&gt;
&lt;p&gt;一旦给一个接口类型的变量（或方法的参数）赋值，就只能调用接口定义的方法。&lt;/p&gt;
&lt;p&gt;示例：&lt;br&gt;
加入创建了Robot类型，除了有一个MakeSound方法外，还有一个Walk方法，在play函数中增加对Walk的调用，并将Robot的值传入play。但是代码运行失败，因为NoiseMaker值没有Walk方法。&lt;/p&gt;
&lt;p&gt;为什么会这样？Robot值的确有Walk方法，我们传入play函数的并不是Robot值，而是NoiseMaker。假如传入Whistle或者Horn呢？它们没有包含Walk方法。&lt;/p&gt;
&lt;p&gt;当有接口类型的变量时，唯一能确定的方法是接口中的方法，并且这些是Go允许调用的方法。有一种能够获取值的具体类型的方法，这样就可以调用更多特定的方法了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Whistle string

func (w Whistle) MakeSound() {
	fmt.Println(&amp;#34;Tweet!&amp;#34;)
}

type Horn string

func (h Horn) MakeSound() {
	fmt.Println(&amp;#34;Honk!&amp;#34;)
}

type Robot string //声明一个新的Robot类型

func (r Robot) MakeSound() { //Robot满足NoiseMaker接口
	fmt.Println(&amp;#34;Beep Boop&amp;#34;)
}

func (r Robot) Walk() { //一个额外的方法
	fmt.Println(&amp;#34;Powering legs&amp;#34;)
}

type NoiseMaker interface {
	MakeSound()
}

func play(n NoiseMaker) {
	n.MakeSound() //正确，NoiseMaker接口的一部分
	n.Walk()      //错误，并非NoiseMaker的一部分
}

func main() {
	play(Robot(&amp;#34;Botco Ambler&amp;#34;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;n.Walk undefined (type NoiseMaker has no field or method Walk)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用接口修复playlist函数&#34;&gt;使用接口修复playList函数&lt;/h1&gt;
&lt;p&gt;使用一个接口来允许playList函数使用两种具体类型（TapePlayer和TapeRecorder）的Play和Stop方法。&lt;/p&gt;
&lt;p&gt;在main包中，声明了一个Player接口（也可以在gadget包中定义，但是接口定义在调用的包中会更灵活），指定接口需要有一个string参数的Play方法和一个无参的Stop方法，这意味着TapePlayer和TapeRecorder类型会满足Player接口。&lt;/p&gt;
&lt;p&gt;更新playList函数来接受满足Player的任何值，而不是特定类型的TapePlayer，也更新player变量的类型，有个TapePlayer改为Player，允许将TapePlayer和TapeRecorder类型赋给player，然后将两种类型的值都传递给playList。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;xxx/xxx/gadget&amp;#34;

type Player interface {  //定义一个接口类型
        Play(string)  //要求一个接受string参数的Play方法
        Stop()  //要求一个Stop方法
}

func playList(device Player, songs []string) {  //接受任何其他的类型，而不只是TapePlayer
	for _, song := range songs {
                device.Play(song)
	}
        device.Stop()
}

func main() {
        mixtape := []string{&amp;#34;Jessie&amp;#39;s Girl&amp;#34;, &amp;#34;Whip It&amp;#34;, &amp;#34;9 to 5&amp;#34;}  //创建一个歌名的切片
        var player Player = gadget.TapePlayer{}  //修改变量的类型来保存任何Player
        playList(player, mixtape)  //给playList传入TapePlayer
        player = gadget.TapeRecorder{}
        playList(player, mixtape)   //给playList传入TapeRecorder
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;若一个类型声明了指针接收器方法，那么就只能将那个类型的指针传递给接口变量。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Switch类型的toggle方法需要使用指针类型的接收器，这样才能修改接收器。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pacakge main

import &amp;#34;fmt&amp;#34;

type Switch string

func (s *Switch) toggle() {
        if *s == &amp;#34;on&amp;#34; {
                *s = &amp;#34;off&amp;#34;
	} else {
                *s = &amp;#34;on&amp;#34;
	}
        fmt.Println(*s)
}

type Toggleable interface {
        toggle()
}

func main() {
        s := Switch(&amp;#34;off&amp;#34;)
        var t Toggleable = s
        t.toggle()
        t.toggle()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是当把Switch的值赋给Toggleable的时候导致错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Switch does not implement Toggleable (toggle method has pointer receive)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go判断值是否满足一个接口的时候，指针方法并没有包含直接的值，但是它们包含指针，所以要将一个指向Switch的指针赋值给Toggleable变量，来代替一个直接Switch值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var t Toggleable = &amp;amp;s  //赋给一个指针
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;类型断言&#34;&gt;类型断言&lt;/h1&gt;
&lt;p&gt;定义了一个新的TryOut函数来测试TapePlayer和TapeRecorder类型的多种方法，TryOut有一个单独的Player接口类型的参数，这样可以传入TapePlayer类型和TapeRecorder类型。&lt;/p&gt;
&lt;p&gt;在TryOut中，调用Player接口中的Play和Stop方法，同样也调用不在Player接口中的Record方法，它定义在TapeRecorder类型中，仅仅将TapeRecorder值传入TryOut。但是，这样不对，若把一个具体类型的值赋给了接口类型的变量（包括函数参数），然后就只能在其上调用接口的方法，不管具体类型还具有何种其他方法。在TryOut函数中，没有TapeRecorder值（具体类型），只有一个Player值（接口类型），并且Player接口并没有Record方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Player interface {
        Play(string)
        Stop()
}

func TryOut(player Player) {
        player.Play(&amp;#34;Test Track&amp;#34;)
        player.Stop()
        player.Record()  //不属于Player接口
}

func main() {
        TryOut(gadget.TapeRecorder{})  //给函数传入TapeRecorder，满足Player
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;player.Record undefined (type Player has no field or method Record)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们需要一个方法来取回具体类型（确实含有Record方法）的值。&lt;/p&gt;
&lt;p&gt;若使用类型转换将Player类型的值转换为TapeRecorder类型的值，但是类型转换并不适用于接口类型，所以会产生错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func TryOut(player Player) {
        player.Play(&amp;#34;Test Track&amp;#34;)
        player.Stop()
        recorder := gadget.TapeRecorder(player)  //类型转换无法工作
        recorder.Record()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cannot convert player (type Player) to type gadget.TapeRecorder: need type assertion
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当将一个具体类型的值赋给一个接口类型的变量时，&lt;code&gt;类型断言&lt;/code&gt;让你能够取回具体类型。&lt;/p&gt;
&lt;p&gt;这像是一种形式的类型转换。它的语法像函数调用和类型转换的结合体。在一个接口值之后，输入一个点，后面接着一对括号括起来的具体类型（或者是想要断言的值的具体类型）。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/11-interface/%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;简单说类型断言就像说某物像“我知道这个变量使用接口类型NoiseMaker，但我很确信这个NoiseMaker实际上是Robot。”&lt;/p&gt;
&lt;p&gt;一旦使用类型断言来取回具体类型的值，可以调用那个类型上的方法，但这方法并不属于接口。&lt;/p&gt;
&lt;p&gt;代码将Robot赋值给了NoiseMaker接口值，可以调用NoiseMaker上的MakeSound方法，因为它是接口的一部分。但是为了调用Walk方法，需要使用类型断言来取回Robot值，一旦获取了Robot（而不是一个NoiseMaker），就能调用它上面的Walk方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Robot string

func (r Robot) MakeSound() {
        fmt.Println(&amp;#34;Beep Boop&amp;#34;)
}

func (r Robot) Walk() {
        fmt.Println(&amp;#34;Powering legs&amp;#34;)
}

type NoiseMaker interface {
        MakeSound()
}

func main() {
        var noiseMaker NoiseMaker = Robot(&amp;#34;Botco Ambler&amp;#34;)  //定义一个接口类型的变量，并且将满足接口的类型值赋给它
        noiseMaker.MakeSound()  //调用接口中的方法
        var robot Robot = noiseMaker.(Robot)  //使用类型断言取回具体类型
        robot.Walk()  //调用在具体类型（而不是接口）上定义的方法
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Beep Boop
Powering legs
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;类型断言失败&#34;&gt;类型断言失败&lt;/h1&gt;
&lt;p&gt;之前TryOut函数不能在Player值上调用Record方法，因为不是Player接口的一部分；我们传入一个TapeRecorder给TryOut，被赋值给一个Player类型的参数，能够调用Player值的Play和Stop方法，因为都是Player接口的一部分。然后使用一个类型断言来将Player转换回一个TapeRecorder，并调用其上的Record方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Player interface {
        Play(string)
        Stop()
}

func TryOut(player Player) {
        player.Play(&amp;#34;Test Track&amp;#34;)
        Player.Stop()
        recorder := player.(gadget.TapeRecorder) //保存TapeRecorder值，使用类型断言来获得一个TapeRecorder值
        recorder.Record()  //调用仅仅定义在具体类型上的方法
}

func main() {
        TryOut(gadget.TapeRecorder{})
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Playing Test Track
Stopped!
Recording
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于TapeRecorder，看起来很正常，考虑到类型断言说TryOut的参数实际上是一个TapeRecorder，如果给TryOut传入TapePlayer会如何呢？&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        TryOut(gadget.TapeRecorder{})
        TryOut(gadget.TapePlayer{})  //传入一个TapePlayer
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当运行时，得到一个运行时异常，尝试断言TapePlayer是一个TapeRecorder无法工作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: interface conversion: main.Player is gadget.TapePlayer, not gadget.TapeRecorder
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;当类型断言失败时避免异常&#34;&gt;当类型断言失败时避免异常&lt;/h1&gt;
&lt;p&gt;如果类型断言被用于仅有一个返回值的情况，并且原始的类型不与断言的类型相同，程序会在运行时（不在编译时）出现异常：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var player Player = gadget.TapePlayer{}
recorder := player.(gadget.TapeRecorder)  //断言原类型是TapeRecorder，但它实际上是TapePlayer
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;panic: interface conversion: main.Player is gadget.TapePlayer, not gadget.TapeRecorder
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果类型断言被用于期待多个返回值的情况，能有第二个可选的返回值来表明断言是否成功。（并且断言并不会在不成功时出现异常。）第二个值是一个bool，并且当原类型和断言类型相同时，返回true，否则返回false。可以对第二个返回值做任何操作，但按惯例，通常被赋给一个名为ok的变量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var player Player = gadget.TapePlayer{}
recorder, ok := player.(gadget.TapeRecorder)  //将第二个返回值赋给ok变量
if ok {
        recorder.Record()  //如果原始类型是TapeRecorder，调用值上的Record
} else {
        fmt.Println(&amp;#34;Player was not a TapeRecorder&amp;#34;)  //否则报告断言失败
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体类型是TapePlayer，而不是TapeRecorder，所以断言失败，ok返回是false，if语句的else执行，一个运行时异常被避免。&lt;/p&gt;
&lt;p&gt;当使用类型断言时，如果不能完全确定接口的原类型是什么，应该使用可选ok值来处理与期望的类型不同的情况，避免一个运行时异常。&lt;/p&gt;
&lt;h1 id=&#34;使用类型断言测试tapeplayer和taperecorder&#34;&gt;使用类型断言测试TapePlayer和TapeRecorder&lt;/h1&gt;
&lt;p&gt;接下来修复TryOut函数以适应TapePlayer和TapeRecorder值，与忽略类型断言的第二个返回值不同，我们将它赋值给一个ok变量，如果类型断言成功，ok变量会为true（标识recorder变量保存了一个TapeRecorder值，准备调用Record方法），否则为false（标识调用Record不安全）。将Record方法的调用包裹在if语句中来确保它仅仅在类型断言成功的情况下才会被调用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Player interface {
        Play(string)
        Stop()
}

func TryOut(player Player) {
        player.Play(&amp;#34;Test Track&amp;#34;)
        player.Stop()
        recorder, ok := player.(gadget.TapeRecorder)  //将第二个返回值赋给变量
	if ok {  //仅仅在原值是TapeRecorder的时候调用Record方法
                recorder.Record()
	}
}

func main() {
        TruOut(gadget.TapeRecorder{})
        TryOut(gadget.TapePlayer{})
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Playing Test Track  //TapeRecorder被传入
Stopped!
Recording  //类型断言成功，Record被调用
Playing Test Track  //TapePlayer被传入
Stopped!  //类型断言未成功，Record没有被调用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与之前一样，在main方法中，首先传入了TapeRecorder值调用TryOut，TryOut获取传入的Player接口值，并调用Play和Stop方法。Player的值的具体类型是TapeRecorder的断言成功了，然后Record方法在TapeRecorder值上被调用。然后传入TapePlayer调用TryOut，这个调用在之前程序中停止，因为类型断言异常。Play和Stop被调用，类型断言失败，因为Player值保存着TapePlayer而不是TapeRecorder，因为捕获了ok值中的第二个返回值，类型断言不会导致异常，因为仅仅将ok值设置为false，导致if语句中的代码不被执行，也就导致了Record没有被调用。（因为TapePlayer值没有Record方法）&lt;/p&gt;
&lt;h1 id=&#34;error接口&#34;&gt;error接口&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;一个错误值就是任何含有名为Error的方法的值，此方法返回string&lt;/code&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type error interface {
        Error() string
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;声明一个接口的error类型意味着，若具有一个返回string的Error方法，就满足error接口，并且它是error的值。这意味着能定义自己的类型并用在任何需要error值的地方。&lt;/p&gt;
&lt;p&gt;ComedyError类型，有返回string的Error方法，满足error接口，就能将它赋值给error类型的变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type ComedyError string  //定义一个以string为基础类型的类型
func (c ComedyError) Error() string {  //满足error接口
        return string(c)  //Error方法需要返回一个string，所以做个类型转换
}

func main() {
        var err error  //声明一个error类型的变量
        err = ComedyError(&amp;#34;What&amp;#39;s a programmer&amp;#39;s favorite beer? Logger!&amp;#34;)  //ComedyError满足error接口，所能把它赋值给变量
        fmt.Println(err)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果需要一个error值，也需要追踪除了错误信息字符串之外更多的信息，可以创建自己的满足error接口的类型并保存需要的信息。&lt;/p&gt;
&lt;p&gt;例：有一个程序监控一些设备保证它们不会过热。
这个OverheatError类型可能游泳，有个确保满足error的Error方法，它使用float64作为基础类型，允许追踪过载的温度。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type OverheatError float64  //定义一个基础类型是float64的类型
func (o OverheatError) Error() string {  //满足error接口
        return fmt.Sprintf(&amp;#34;OverheatError by %0.2f degrees!&amp;#34;, o)  //在错误信息中使用温度
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有个使用OverheatError的checkTemperature函数，接收系统实际温度和被认为是安全的温度作为参数，指定返回一个error类型的值，而不是OverheatError，但因为它满足error接口，若actual温度超过了safe温度，checkTemperature返回一个新的记录了超出量的OverheatError：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func checkTemperature(actual float64, safe float64) error {  //指定函数返回原生error值
        excess := actual - safe
        if excess &amp;gt; 0 {  //如果actual温度高于safe温度
                return OverheatError(excess)  //就返回一个记录了超出量的OverheatError
        }
        return nil
}

func main() {
        var err error = checkTemperature(121.379, 100.0)
        if err != nil {
                log.Fatal(err)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;为什么可以在不同的包中使用error接口而不用导入？以小写字母开头？&lt;/p&gt;
&lt;p&gt;error类型像int或string一样是一个“预定义标识符”，不属于任何包，是“全局块”的一部分，能在任何地方使用，无需考虑当前包信息。&lt;/p&gt;
&lt;h1 id=&#34;stringer接口&#34;&gt;Stringer接口&lt;/h1&gt;
&lt;p&gt;fmt包定义了fmt.Stringer接口：允许任何类型决定在输出时如何展示，让其他类型满足Stringer接口很简单，只需要定义一个返回string类型的方法。&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Stringer interface {
        String() string
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如，我们建立了一个CoffeePot类型来满足Stringer：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type CoffeePot string

func (c CoffeePot) String() string {  //满足Stringer接口
        return string(c) + &amp;#34; coffee pot&amp;#34;  //方法需要返回一个string
}

func main() {
        coffeePot := CoffeePot(&amp;#34;LuxBrew&amp;#34;)
        fmt.Println(coffeePot.String())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;许多在fmt包中的函数都会判断传入的参数是否满足stringer接口，若满足就调用String方法，这些函数包括Print、Println和Printf等，CoffeePot满足了Stringer，可以把CoffeePot值直接传入这些函数，并且CoffeePot的String方法的返回值会在输出时使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;coffeePot ：= CoffeePot(&amp;#34;LuxBrew&amp;#34;)  //创建一个CoffeePot值
fmt.Print(coffeePot, &amp;#34;\n&amp;#34;)
fmt.Println(coffeePot)
fmt.Printf(&amp;#34;%s&amp;#34;, coffeePot)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;LuxBrew coffee pot  //String方法的返回值在输出中使用
LuxBrew coffee pot
LuxBrew coffee pot
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;空接口&#34;&gt;空接口&lt;/h1&gt;
&lt;p&gt;我们接触的大多数函数，只能使用指定的类型来调用，但是fmt.Println这样的fmt函数却能接受任何类型，这是怎么做到的？&lt;/p&gt;
&lt;p&gt;来看下go doc： &lt;code&gt;go doc fmt Println&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是一个可变参数的函数，意味着它可以接受任何个数的参数；接口声明定义了方法，类型必须实现这个方法才能满足接口。若定义一个不需要任何方法的接口，它会被任何类型满足。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Interface{}&lt;/code&gt;类型称为空接口，用来接受任何类型的值，不需要实现任何方法来满足空接口，所有的类型都满足空接口。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Anything interface {}

func AcceptAnything(thing interface{}) {
}

func main() {
        AcceptAnything(123.123)
        AcceptAnything(&amp;#34;A string&amp;#34;)
        AcceptAnything(true)
        AcceptAnything(Whistle(&amp;#34;xxxxxx&amp;#34;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先不要对所有的函数使用空接口，若有一个空接口类型的值，无法做任何操作。&lt;/p&gt;
&lt;p&gt;不要尝试在空接口值上调用任何函数，如果有一个接口类型的值，只能调用接口上的方法。空接口没有任何方法，意味着没法调用空接口类型值的任何方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func AcceptAnything(thing interface{}) {
        fmt.Println(thing)
        thing.MakeSound()  //尝试在空接口值上调用方法
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;thing.MakeSound undefined (type interface {} is interface with no mehtods)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了在空接口类型的值上调用方法，需要使用类型断言来获得具体类型的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func AcceptAnything(thing interface{}) {
        fmt.Println(thing)
        whistle, ok := thing.(Whistle)  //使用类型断言来获得Whistle
	if ok {
                whistle.MakeSound()  //调用Whistle上的方法
	}
}

func main() {
        AcceptAnything(3.1415)
        AcceptAnything(Whistle(&amp;#34;Toyco Canary&amp;#34;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最好写一个接收特定具体类型的函数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func AcceptWhistle(whistle Whistle) {  //接收Whistle
        fmt.Println(whistle)
        whistle.MakeSound()  //调用方法，不需要类型转换
}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>10.保密：封装和嵌入</title>
      <link>https://tinklespring.com/posts/10.%E4%BF%9D%E5%AF%86%E5%B0%81%E8%A3%85%E5%92%8C%E5%B5%8C%E5%85%A5/</link>
      <pubDate>Mon, 07 Aug 2023 16:27:10 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/10.%E4%BF%9D%E5%AF%86%E5%B0%81%E8%A3%85%E5%92%8C%E5%B5%8C%E5%85%A5/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;有时，程序会接收到无效的数据，从用户输入、文件读取或其他方式。&lt;code&gt;封装&lt;/code&gt;：一个保护string字段免受无效数据的方法。这样，数据字段能够安全使用。&lt;br&gt;
也会在类型内部嵌入其他的类型，若struct类型需要已经存在于其他类型的方法，不需要赋值方法代码，可以将其嵌入struct类型中，然后像使用自己的类型的定义方法一样使用嵌入的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;创建一个日期struct类型&#34;&gt;创建一个日期struct类型&lt;/h1&gt;
&lt;p&gt;在struct中增加Year、Month、Day字段，每个都是int类型，在main函数中，将执行一个快速的测试来测试新类型，使用struct字面量来创建一个Date值，并填充所有字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Date struct {
        Year  int
        Month int
        Day   int
}

func main() {
        date := Date{Year: 2023, Month: 8, Day: 10}
        fmt.Println(date)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;将date-struct字段设置为无效值&#34;&gt;将Date struct字段设置为无效值&lt;/h1&gt;
&lt;p&gt;用户将日期格式设置的很奇怪，比如：&amp;ldquo;2023 14 50&amp;rdquo; 或 &amp;ldquo;0 0 -2&amp;rdquo; 等，我们知道只有1以上的年的数字才合法，但程序没做任何措施预防用户把日志以外设置为0或-999，月份也只有1-12合法，日只有1-31合法。&lt;/p&gt;
&lt;p&gt;需要一种方法，让用户数据在被赋值之前是合法的，在CS领域中，被称为&lt;code&gt;数据校验&lt;/code&gt;，需要测试Year被设置为大于或等于1，Month被设置为1-12，Day被设置为1-31。&lt;/p&gt;
&lt;h1 id=&#34;setter方法&#34;&gt;setter方法&lt;/h1&gt;
&lt;p&gt;一个struct类型就是另一个定义的类型，可以像对其他类型一样定义它的方法。可以在Date类型上创建 SetYear、SetMonth、SetDay方法来接收值，判断是否有效，若有效则设置到struct字段。&lt;/p&gt;
&lt;p&gt;这类方法被称为 &lt;code&gt;setter方法&lt;/code&gt; , Go的setter方法名为&lt;code&gt;SetX&lt;/code&gt;的形式，X 是想要设置的名称。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setter 方法 是用来设置字段或基础类型中的其他值的方法。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在SetYear方法上进行第一次尝试，接收器参数是Date struct，SetYear接受想要设置的年份作为参数，并设置接收器Date struct上的Year字段，此时并不校验值有效性。在main方法中创建Date并调用SetYear，然后输出struct的Year字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Date struct {
        Year  int
        Month int
        Day   int
}

func (d Date) SetYear(year int) {
        d.Year = year    //设置struct字段
}

func main() {
        date := Date{}  //创建一个Date
        date.SetYear(2023)  //通过方法设置Year字段
        fmt.Println(date.Year)  //打印Year字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当执行时，并没有正常工作，创建了一个Date并使用新值调用了它的setYear方法，Year字段仍被设置为零值。&lt;/p&gt;
&lt;h1 id=&#34;setter方法需要指针接收器&#34;&gt;setter方法需要指针接收器&lt;/h1&gt;
&lt;p&gt;之前Number类型上的Double方法，使用了一个普通的值接收器类型Number，像其他参数一样，接收器参数接受了一个原值的拷贝，Double方法只是更新了拷贝，在方法退出时更新就丢失了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (n *Number) Double() {   //接收器类型为一个指针类型
        *n *= 2  //修改指针指向的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要更新Double来接受指针的接收器类型 &lt;code&gt;*Number&lt;/code&gt; ，当更新指针指向的值的时候，在Double退出后更新会保留。&lt;/p&gt;
&lt;p&gt;同样，SetYear也适用，Date接收器从原struct获取了一个拷贝，任何字段更新都在setYear退出后消失。&lt;/p&gt;
&lt;p&gt;通过将接收器的值修改为指针来修正，不需要更新SetYear方法块，因为 d.Year 会自动获取指针指向的值（与&lt;code&gt;(*d).Year&lt;/code&gt; 一样），main函数中的date.SetYear也不需要修改，因为当Date值传递给方法的时候，会自动转换为 &lt;code&gt;*Date&lt;/code&gt; 。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Date struct {
        Year  int
        Month int
        Day   int
}

func (d *Date) SetYear(year int) {
        d.Year = year
}

func main() {
        date := Date{}
        date.SetYear(2023)  //自动转换为指针
        fmt.Println(date.Year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;添加其余的setter方法&#34;&gt;添加其余的setter方法&lt;/h1&gt;
&lt;p&gt;按照这个模式在Date类型上定义SetMonth和SetDay方法，只需要在方法中使用指针接收器即可，在调用方法时，Go会自动把接收器转换为指针，并在修改struct字段时能够把指针转换回struct值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Date struct {
	Year  int
	Month int
	Day   int
}

func (d *Date) SetYear(year int) {
	d.Year = year
}

func (d *Date) SetMonth(month int) {
	d.Month = month
}

func (d *Date) SetDay(day int) {
	d.Day = day
}

func main() {
	date := Date{}
	date.SetYear(2023)
	date.SetMonth(5)
	date.SetDay(27)
	fmt.Println(date)  //输出所有字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在main函数中，创建了一个Date struct的值，通过新的方法设置了它的Year、Month和Day字段，并输出了整个struct查看结果。&lt;/p&gt;
&lt;h1 id=&#34;在setter方法中添加校验&#34;&gt;在setter方法中添加校验&lt;/h1&gt;
&lt;p&gt;在每个setter方法中，将测试值是否在正确合法范围内，若非法，返回error值，若合法，将正常设置 Date struct字段，并返回nil作为错误值。&lt;/p&gt;
&lt;p&gt;首先对SetYear方法增加校验，修改方法的声明，增加一个error类型的返回值，在方法块的开始处，测试调用者传入的year参数是否小于1，若小于1，返回一个error信息，若大于等于1，将其设置为struct的Year字段并返回nil，表示没有错误。&lt;/p&gt;
&lt;p&gt;在main函数中，调用SetYear并把返回值保存到名为err的变量中，若err不为nil，意味着赋值无效，所以记录错误并退出，否则继续输出Date struct的Year字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;errors&amp;#34; //允许创建error值
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34; //允许记录error并退出
)

type Date struct {
	Year  int
	Month int
	Day   int
}

func (d *Date) SetYear(year int) error { //增加一个error类型的返回值
	if year &amp;lt; 1 {
		return errors.New(&amp;#34;invalid year&amp;#34;) //若year是非法的，返回错误
	}
	d.Year = year
	return nil
}

func main() {
	date := Date{}
	err := date.SetYear(0) //抓捕任何错误
	if err != nil {
		log.Fatal(err)  //若值无效记录错误并退出
	}
	fmt.Println(date.Year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023/08/10 16:56:33 invalid year
exit status 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;传入一个无效的值给SetYear导致程序报错并退出，但若传入有效值，程序会继续输出，SetYear方法工作正常。&lt;/p&gt;
&lt;p&gt;SetMonth 与 SetDay 方法中的校验代码与SetYear类似：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (d *Date) SetYear(year int) error { //增加一个error类型的返回值
	if year &amp;lt; 1 {
		return errors.New(&amp;#34;invalid year&amp;#34;) //若year是非法的，返回错误
	}
	d.Year = year
	return nil
}

func (d *Date) SetMonth(month int) error {
	if month &amp;lt; 1 || month &amp;gt; 12 {
		return errors.New(&amp;#34;invalid month&amp;#34;)
	}
	d.Month = month
	return nil
}

func (d *Date) SetDay(day int) error {
	if day &amp;lt; 1 || day &amp;gt; 31 {
		return errors.New(&amp;#34;invalid day&amp;#34;)
	}
	d.Day = day
	return nil
}

func main() {
        //try
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在SetMonth中，测试提供的月份值，若小于1或大于12，就返回错误，否则设置字段并返回nil。&lt;/p&gt;
&lt;p&gt;在SetDay中，测试提供的日期小于1或大于31，返回错误，有效值设置字段并返回nil。&lt;/p&gt;
&lt;h1 id=&#34;字段仍可以设置为无效值&#34;&gt;字段仍可以设置为无效值&lt;/h1&gt;
&lt;p&gt;使用setter方法，提供校验很不错，但是用户可以直接设置struct字段，仍然能设置无效值。&lt;/p&gt;
&lt;p&gt;没有任何方法能阻止直接设置Date struct字段，若这么做，就会绕过setter方法中的校验代码。&lt;/p&gt;
&lt;p&gt;需要一个方式来保护这些字段，让Date类型只能使用setter方法来更新字段，Go提供了一个方式：&lt;code&gt;把Date类型移动到另一个包，并将数据字段设置为非导出的&lt;/code&gt;。未导出的变量、函数等在大多数情况下无法导出，即使之前的magazine包中的Subscriber struct类型被导出(字段首字母非大写)，但是它的字段并未被导出，导致在magazine包之外无法访问。&lt;/p&gt;
&lt;h1 id=&#34;将date类型移动到另外的包中&#34;&gt;将Date类型移动到另外的包中&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

import &amp;#34;errors&amp;#34;

type Date struct {
	year  int
	month int
	day   int
}  //将字段名称修改为小写字母让其不可被导出

func (d *Date) SetYear(year int) error {
	if year &amp;lt; 1 {
		return errors.New(&amp;#34;invalid year&amp;#34;)
	}
	d.year = year //更新字段名称匹配声明
	return nil
}

func (d *Date) SetMonth(month int) error {
	if month &amp;lt; 1 || month &amp;gt; 12 {
		return errors.New(&amp;#34;invalid month&amp;#34;)
	}
	d.month = month //更新字段名称匹配声明
	return nil
}

func (d *Date) SetDay(day int) error {
	if day &amp;lt; 1 || day &amp;gt; 31 {
		return errors.New(&amp;#34;invalid day&amp;#34;)
	}
	d.day = day  //更新字段名称匹配声明
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改main包：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/calendar&amp;#34;
)

func main() {
        date := calendar.Date{}
        date.year = 2023
        date.month = 14
        date.day = 50
        fmt.Println(date)

        date = calendar.Date{year: 0, month: 0, day: -2}
        fmt.Println(date)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Date的字段未导出，从main包中访问，会导致编译错误。&lt;/p&gt;
&lt;h1 id=&#34;通过导出的方法访问未导出的字段&#34;&gt;通过导出的方法访问未导出的字段&lt;/h1&gt;
&lt;p&gt;可以间接访问字段。未导出的变量、struct字段、函数、方法等仍然能被相同包的导出的函数或者方法访问。所以当mian包中的代码在Date值上调用导出方法SetYear时，SetYear可以修改Date的year字段，即使year是未导出的。导出方法SetYear可以更新未导出的month字段等。&lt;/p&gt;
&lt;p&gt;修改main包来使用setter方法，可以更新Date值的字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/calendar&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        date := calendar.Date{}
        err := date.SetYear(2023)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetMonth(5)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetDay(27)
        if err != nil {
                log.Fatal(err)
        }
        fmt.Println(date)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{2023 5 27}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;未导出的变量、struct字段、函数、方法等仍然能够被相同包的导出的函数或方法访问。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时若传入无效值，执行时会得到错误。&lt;/p&gt;
&lt;p&gt;现在的Date值的字段只能通过setter方法更新，程序被保护，避免意外输出无效数据。&lt;/p&gt;
&lt;h1 id=&#34;getter方法&#34;&gt;getter方法&lt;/h1&gt;
&lt;p&gt;将值设置给struct字段或者变量的方法称为 &lt;code&gt;setter&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;获取struct字段或者变量的值的方法称为 &lt;code&gt;getter&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;按照惯例，getter方法的名称应该与访问的字段或者变量的名字相同。（若希望方法被导出，首字母应该大写。）所以Date需要一个Year方法来访问year字段，Month方法来访问month字段，Day方法来访问day字段。&lt;/p&gt;
&lt;p&gt;getter方法不需要修改接收器，直接使用Date的值作为接收器。若类型的任何方法接受接收器指针类型，为了一致性，通常所有的方法都应该这样做。由于必须对所有的setter方法使用接收器指针，也应对所有的getter方法使用指针。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

import &amp;#34;errors&amp;#34;

type Date struct {
	year  int
	month int
	day   int
}

func (d *Date) Year() int {  //与setter方法一致，使用一个接收器指针类型；Year与字段名称相同，为了导出首字母大写。
	return d.year   //返回字段值
}

func (d *Date) Month() int {
	return d.month
}

func (d *Date) Day() int {
	return d.day
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改main：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        date := calendar.Date{}
        err := date.SetYear(2023)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetMonth(5)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetDay(27)
        if err != nil {
                log.Fatal(err)
        }
        fmt.Println(date.Year())
        fmt.Println(date.Month())
        fmt.Println(date.Day())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出(getter方法返回的值)：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023
5
27
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;封装&#34;&gt;封装&lt;/h1&gt;
&lt;p&gt;将程序中的数据隐藏在一部分代码中而对另一部分不可见的方法称为&lt;code&gt;封装&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;封装可以用来防止无效数据，同样也可以修改程序代码的封装部分，而不用担心其他代码的访问，因为它们不可直接访问。&lt;/p&gt;
&lt;p&gt;许多其他编程语言用类进行封装，类与Go的类型概念类似，但不完全相同，在Go中使用未导出的变量、struct字段、函数或者方法，把数据封装在包中。&lt;/p&gt;
&lt;p&gt;Go通常在需要的时候才使用封装，不需要封装一个字段，通常导出并且允许直接访问。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;问：其他语言不允许在定义封装的值的类之外访问该值，Go允许包内其他代码访问未导出代码是否安全？&lt;br&gt;
答：通常一个包内的所有代码是一个开发者（或一组开发者）开发，包里所有的代码通常有相似的目的，相同包的代码的作者有可能需要访问未导出数据，并且有可能只用合理的方式来使用数据，所以在包内共享未导出数据是安全的。包外的代码有可能是其他开发者编写，但未导出代码是隐藏的，不会意外将其值改为无效数据。&lt;/p&gt;
&lt;p&gt;问：其他语言所有getter方法的名字都以“Get”开头，比如GetName、GetCity等，在go中是否可以这样做？&lt;br&gt;
答：Go允许这样做，但不推荐。Go社区大会讨论后决定在getter方法前面去掉Get前缀，保留它只会让后继者感到困惑。Go仍然对setter方法使用Set前缀，因为需要区分同一个字段的setter方法和getter方法。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;练习：&lt;/p&gt;
&lt;p&gt;要求：
1.字段未导出&lt;br&gt;
2.为每个字段增加一个getter方法（遵守约定：一个getter方法应该与它访问的字段名称相同，若需要导出，首字母大写）&lt;br&gt;
3.为setter方法增加校验，SetLatitude若接收到小于-90或大于90的值返回错误，Setlongitude若接收到小于-180大于180的值返回错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package geo

import &amp;#34;errors&amp;#34;

type Coordinates struct {
	latitude  float64
	longitude float64 //字段需要未导出的
}

func (c *Coordinates) Latitude() float64 { //getter方法名应该与字段名相同，但是首字母需要大写；返回与字段类型相同
	return c.latitude
}

func (c *Coordinates) Longitude() float64 {
	return c.longitude
}

func (c *Coordinates) SetLatitude(latitude float64) error { //需要返回错误类型
	if latitude &amp;lt; -90 || latitude &amp;gt; 90 {
		return errors.New(&amp;#34;invalid latitude&amp;#34;) //返回一个新的错误值
	}
	c.latitude = latitude
	return nil //如果没有错误返回nil
}

func (c *Coordinates) SetLongitude(longitude float64) error {
	if longitude &amp;lt; -180 || longitude &amp;gt; 180 {
		return errors.New(&amp;#34;invalid longitude&amp;#34;)
	}
	c.longitude = longitude
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;main 包代码要求：
1.遍历每个settter方法，保存error返回值&lt;br&gt;
2.若error不为nil，使用log.Fatal函数记录错误并退出&lt;br&gt;
3.若设置字段没有错误，调用所有getter方法输出字段值&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;geo&amp;#34;
	&amp;#34;log&amp;#34;
)

func main() {
	coordinates := geo.Coordinates{}
	err := coordinates.SetLatitude(37.42) //保存返回的错误值
	if err != nil {                       //若有错误，记录并返回
		log.Fatal(err)
	}
	err = coordinates.SetLongitude(-1122.08) //一个无效值
	if err != nil {                          //若有错误记录并返回
		log.Fatal(err)
	}
	fmt.Println(coordinates.Latitude())
	fmt.Println(coordinates.Longitude()) //getter方法
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在event类型中嵌入date类型&#34;&gt;在Event类型中嵌入Date类型&lt;/h1&gt;
&lt;p&gt;Date类型很棒，setter方法确保了只有合法的数据才能设置字段，getter方法让我们能取回这些值，现在只需给事件分配标题。&lt;/p&gt;
&lt;p&gt;定义一个Event类型，并内嵌一个Date作为匿名字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

type Event struct {
        Title string
        Date   //使用一个匿名字段嵌入Date
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在calendar包中创建另外一个文件，名为event.go（将把它放到已存在的date.go），在那个文件中，定义一个含有两个字段的类型：一个string类型的Title字段和一个匿名的Date字段。&lt;/p&gt;
&lt;h1 id=&#34;未导出的字段不会被提升&#34;&gt;未导出的字段不会被提升&lt;/h1&gt;
&lt;p&gt;将Date嵌入到Event类型中并不会导致Date的字段被提升到Event，Date字段是未导出的，并且Go不会将未导出的字段提升到封闭类型。确认字段被封装，就只能够被setter 方法和getter方法访问，不希望封装被字段提升绕开。&lt;/p&gt;
&lt;p&gt;在main包中，若尝试通过包裹它的Event设置Date中的month字段，会得到错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;xxx/xxx/calendar&amp;#34;

func main() {
        event := calendar.Event{}
        event.month = 5  //未导出的Date字段并没有提升到Event
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        event := calendar.Event{}
        event.Date.year = 2023
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用点运算符链来返回Date字段并且直接访问其中的字段也无法工作，不能单独访问一个Date的未导出字段，当Date是Event的一部分的时，也不能访问Event中Date未导出的字段。&lt;/p&gt;
&lt;h1 id=&#34;导出的方法像字段一样被提升&#34;&gt;导出的方法像字段一样被提升&lt;/h1&gt;
&lt;p&gt;若嵌入了一个具有导出方法的struct类型，它的方法会被提升到外部类型，意味着可以调用这个方法，就像在外部类型上定义了该方法一样。&lt;/p&gt;
&lt;p&gt;有一个定义了两种类型的包，MyType是一个struct类型，其中嵌入了第二个类型EmbeddedType，是一个匿名字段：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package mypackage  //类型在它们自己的包中

import &amp;#34;fmt&amp;#34;

type MyType struct {  //声明MyType是一个struct类型
        EmbeddedType  //EmbeddedType是一个嵌入MyType的类型
}

type EmbeddedType string  //声明一个被嵌入的类型（并不在意它是否是个struct）

func (e EmbeddedType) ExportedMethod() {  //这个方法会被提升至MyType
        fmt.Println(&amp;#34;Hi from ExportedMethod on EmbeddedType&amp;#34;)
}

func (e EmbeddedType) unexportedMethod() {  //这个方法不会被提升

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为EmbeddedType定义了一个导出的方法（名为ExportedMethod），这个类型被提升到MyType，并可以被MyType值所调用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;mypackage&amp;#34;

func main() {
        value := mypackage.MyType{}
        value.ExportedMethod()  //调用从EmbeddedType提升的方法
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于未导出的字段，未导出的方法没有被提升，若尝试调用，会得到一个错误。&lt;/p&gt;
&lt;p&gt;Date字段不会被提升到Event类型，因为它们未导出，但是Date上的getter和setter方法被导出了，它们提升到了Event类型。&lt;/p&gt;
&lt;p&gt;意味着我们可以创建一个Event值，并在Event值上直接调用Date的getter和setter方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/calendar&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        event := calendar.Event{}
        err := event.SetYear(2023)
        if err != nil {
                log.Faltal(err)
        }
        err = event.SetMonth(5)
        if err != nil {
                log.Faltal(err)
        }
        err = event.SetDay(27)
        if err != nil {
                log.Faltal(err)
        }
        fmt.Println(event.Year())
        fmt.Println(event.Month())
        fmt.Println(event.Day())  //这个Date的getter方法被提升到了Event
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当然，也可以使用运算符链来调用Date值上的方式：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(event.Date.Year())
fmt.Println(event.Date.Month())
fmt.Println(event.Date.Day())   //获取Event的Date字段，然后调用其getter方法
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;封装event的title字段&#34;&gt;封装Event的Title字段&lt;/h1&gt;
&lt;p&gt;由于Event struct的Title字段被导出，仍然可以直接访问它。&lt;/p&gt;
&lt;p&gt;这会面临与之前Date字段相同的问题，例如，Title字符串没有长度限制：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        event := calendar.Event{}
        event.Title = &amp;#34;An extremely long title that is impractical to print&amp;#34;
        fmt.Println(event.Title)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将Title字段封装起来，这样就能校验新的值，将其命名为title，然后增加setter和getter方法，来自 unicode/utf8 包中的RuneCountInString函数被用来确保string中没有过多的字符。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

import (
        &amp;#34;errors&amp;#34;
        &amp;#34;unicode/utf8&amp;#34;
)

type Event struct {
        title string  //修改为非导出
        Date
}

func (e *Event) Title() string {   //getter方法
        return e.title
}

func (e *Event) SetTitle(title string) error {  //setter方法
	if utf.RuneCountInString(title) &amp;gt; 30 {
                return errors.New(&amp;#34;invalid title&amp;#34;)
	}
        e.title = title
        return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;提升的方法与外部类型的方法共存&#34;&gt;提升的方法与外部类型的方法共存&lt;/h1&gt;
&lt;p&gt;现在已经为title字段添加了getter和setter方法，若title长度超过30个字符，会返回错误。&lt;/p&gt;
&lt;p&gt;Event类型的Title和SetTitle方法与从嵌入的Date类型提升的方法一同存在，导入calendar包的代码可以让所有的方法被视为属于Event类型，而不用考虑它们真正定义在哪个类型上。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        event := calendar.Event{}
        err := event.SetTitle(&amp;#34;Mom&amp;#39;s birthday&amp;#34;)  //定义在Event上
        if err != nil {
                log.Fatal(err)
        }
        err = event.SetYear(2023)  //从Date提升
        if err != nil {
                log.Fatal(err)
        }
        err = event.SetMonth(5)  //从Date提升
        if err != nil {
                log.Fatal(err)
        }
        err = event.SetDay(27)  //从Date提升
        if err != nil {
                log.Fatal(err)
        }
        fmt.Println(event.Title())  //Event自己定义的
        fmt.Println(event.Year())   //从Date提升
        fmt.Println(event.Month())  //从Date提升
        fmt.Println(event.Day())    //从Date提升
}
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;现在能在Event上直接调用Title和SetTitle方法，并调用方法设置年月日就像它们是属于Event一样，它们实际上是在Date上定义的，但我们不需要关心。&lt;/p&gt;
&lt;p&gt;方法提升允许使用其他类型的方法就像使用自己的一样，可以用这个来组合类型，该类型组合了多种其他类型的方法，这可以帮助保持代码整洁，且不牺牲便利性。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>9.定义类型</title>
      <link>https://tinklespring.com/posts/9.%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 05 Aug 2023 12:28:25 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/9.%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本篇展示使用任意类型作为基础类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;具有底层基础类型的定义类型&#34;&gt;具有底层基础类型的定义类型&lt;/h1&gt;
&lt;p&gt;Go经常使用 struct 作为基础类型来定义类型，但也能基于 int、string、bool或其他任何类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Liters float64
type Gallons float64  //定义两个新类型，基础类型都是float64

func main() {
        var carFuel Gallons
        var busFuel Liters
        carFuel = Gallons(10.0)   //把float64转换为Gallons
        busFuel = Liters(240.0)   //把float64转换为Liters
        fmt.Println(carFuel, busFuel)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一旦定义一个类型，可以把任何基础类型的值转换为定义的类型，像其他类型转换一样，写下需要转换到的类型，后面跟着小括号中的希望转换的值。&lt;/p&gt;
&lt;p&gt;若需要，上面代码中可以使用短变量声明:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;carFuel := Gallons(10.0)
busFuel := Liters(240.0)  //与类型转换同时使用短变量声明
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若变量使用了已定义的类型，不能把另一个类型的值赋给它，即使另一个类型也具有相同的基础类型。&lt;/p&gt;
&lt;p&gt;但是可以在具有相同基础类型的类型之间转换，Liters可以与Gallons互相转换，因为其基础类型都是float64，但是Go只在转换时考虑基础类型的值，Gallons(Liters(240.0)) 与 Liters(Gallons(240.0)) 没有区别，简单地把值从一个类型转换到另一个类型使针对这个类型应该出现的错误保护机制失效。&lt;/p&gt;
&lt;p&gt;升与加仑转换：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;carFuel = Gallons(Liters(40.0) * 0.264)
busFuel = Liters(Gallons(63.0) * 3.785)
fmt.Printf(&amp;#34;Gallons: %0.1f Liters: %0.1f\n&amp;#34;, carFuel, busFuel)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;定义类型和运算符&#34;&gt;定义类型和运算符&lt;/h1&gt;
&lt;p&gt;一个定义类型提供与所有基础类型相同的运算，基于float64类型，提供算数运算符&lt;code&gt;+、-、*、/&lt;/code&gt;，也提供比较运算&lt;code&gt;==、&amp;gt;、&amp;lt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;并且基于基础类型string的类型，支持&lt;code&gt;+、==、&amp;gt;、&amp;lt;&lt;/code&gt;，但是不支持&lt;code&gt;-&lt;/code&gt;，因为 - 对于string不是合法的运算符。&lt;/p&gt;
&lt;p&gt;一个定义类型可以被用来与字面值一起运算：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(Liters(1.2) + 3.4)
fmt.Println(Gallons(5.5) - 2.2)
fmt.Println(Gallons(1.2) == 1.2)
fmt.Println(Liters(1.2) &amp;lt; 3.4)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;4.6
3.3
true
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义类型不能用来与不同类型的值一起运算，即使它们来自相同的基础类型。若想要将一个Liters中的值与Gallons中的值作运算，需要将其中一个类型转换为另一个类型。&lt;/p&gt;
&lt;h1 id=&#34;使用函数进行类型转换&#34;&gt;使用函数进行类型转换&lt;/h1&gt;
&lt;p&gt;让不同类型的值一起运算，需要进行类型转换：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;carFuel = Gallons(Liters(40.0) * 0.264)
busFuel = Liters(Gallons(63.0) * 3.785)

	func ToGallons(l Liters) Gallons {
                return Gallons(l * 0.364)
	}

        func ToLiters(g Gallons) Liters {
                return Liters(g * 3.785)
        }

        func main() {
                carFuel := Gallons(1.2)
                busFuel := Liters(4.5)
                carFuel += ToGallons(Liters(40.0))   //先将Liters转换为Gallons
                busFuel += ToLiters(Gallons(30.0))   //先将Gallons转换为Liters
                fmt.Printf(&amp;#34;Car fuel: %0.1f gallons\n&amp;#34;, carFuel)
                fmt.Printf(&amp;#34;Bus fuel: %0.1f liters\n&amp;#34;, busFuel)
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Car fuel: 11.8 gallons
Bus fuel: 118.1 litters
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;增加一个新类型，Milliliters：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Liters float64
type Milliliters float64
type Gallons float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也需要将Milliliters类型进行转换，但如果增加一个Milliliters转换为Gallons的函数，会产生错误，不能在同一个包中出现两个ToGallons函数！&lt;/p&gt;
&lt;p&gt;可以分别修改两个ToGallons函数的名字：LitersToGallons和MillilitersToGallons：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func LitersToGallons(l Liters) Gallons {
        return Gallons(l * 0.264)
}
func MillilitersToGallons(m Milliliters) Gallons {
        return Gallons(m * 0.000264)
}
func GallonsToLiters(g Gallons) Liters {
        return Liters(g * 3.785)
}
func GallonsToMilliliters(g Gallons) Milliliters {
        return Milliliters(g * 3785.41)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然这样消除了冲突，但是名字很长，不方便。&lt;/p&gt;
&lt;p&gt;其他语言的重载，允许存在多个同名函数，只要其参数不同即可，但go不支持重载，有其他方式能达到类似的效果。&lt;/p&gt;
&lt;h1 id=&#34;使用方法修复函数名冲突&#34;&gt;使用方法修复函数名冲突&lt;/h1&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var now time.Time = time.Now()  //time.Now返回一个time.Time值代表当前日期和时间
        var year int = now.Year()  //time.Time值有一个Year方法来返回当前年
        fmt.Printlnt(year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        broken := &amp;#34;G# r#cks&amp;#34;
        replacer := strings.NewReplacer(&amp;#34;#&amp;#34;, &amp;#34;o&amp;#34;)  //返回一个strings.Replacer值，被设置为&amp;#34;#&amp;#34;到&amp;#34;o&amp;#34;的转换
        fixed := replacer.Replace(broken)  //调用strings.Replacer的Replace方法，并传入一个字符串来作转换
        fmt.Println(fixed)  //输出Replace方法返回的字符串
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以用自定义方法来帮助解决类型转换的问题。&lt;/p&gt;
&lt;p&gt;不允许有多个ToGallons函数，所以不得不写很长的函数名称；但是可以有多个名为ToGallons的方法，只要它们被定义在单独的类型中，不用担心名称冲突，让方法名称更短小。&lt;/p&gt;
&lt;h1 id=&#34;定义方法&#34;&gt;定义方法&lt;/h1&gt;
&lt;p&gt;方法定义与函数定义类似，只有一点不同：需要增加一个额外的参数，一个接收器参数，在函数名称之前的括号中；需要提供一个接收器参数的名称，后面跟着类型。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/9-type/%e5%ae%9a%e4%b9%89%e6%96%b9%e6%b3%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;为了调用定义的方法，键入要在其上调用方法的值，一个点和要调用的方法的名称，跟着一对括号；这里调用的方法被称为&lt;code&gt;方法接收器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当调用一个方法时，接收器要被列为第一个，并当定义一个方法的时候，接收器参数也被列为第一个。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;value := MyType(&amp;#34;a MyType value&amp;#34;)
value.sayHi()  //value为方法接收器，sayHi为方法名称
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法定义中的接收器参数的名称不重要，重要的是它的类型，定义的方法与此类型的值都关联。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type MyType string   //定义一个类型

func (m MyType) sayHi() {  //定义一个接收器，函数被定义在MyType上
        fmt.Println(&amp;#34;Hi&amp;#34;)
}

func main() {
        value := MyType(&amp;#34;a MyType value&amp;#34;)  //创建一个MyType值
        value.sayHi()  //在这个值上调用sayHi
        anotherValue := MyType(&amp;#34;another value&amp;#34;)  //创建另一个MyType值
        anotherValue.sayHi()  //在另一个值上调用sayHi
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hi
Hi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先定义了一个名为MyType的类型，使用string作为基础类型，然后定义一个名为sayHi的方法，由于sayHi有一个MyType类型的接收器参数，可以使用任何MyType的值来调用sayHi方法。&lt;/p&gt;
&lt;p&gt;一旦方法被定义在了某个类型，它就能被该类型的任何值调用。&lt;/p&gt;
&lt;h1 id=&#34;接收器参数几乎就是另一个参数&#34;&gt;接收器参数（几乎）就是另一个参数&lt;/h1&gt;
&lt;p&gt;接收器参数的类型是与之联系的方法的类型，除此以外，接收器在Go中没有什么特殊，可以在方法块中访问它们的内容，就像其他的函数参数一样。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type MyType string

func (m MyType) sayHi() {  //输出接收器参数的值
        fmt.Println(&amp;#34;Hi from&amp;#34;, m)
}

func main() {
        value := MyType(&amp;#34;a MyType value&amp;#34;)  //调用方法所需的值
        value.sayHi()  //传递给接收器参数的接收器
        anotherValue := MyType(&amp;#34;another value&amp;#34;)  //调用方法所需的值
        anotherValue.sayHi()  //传递给接收器参数的接收器
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hi from a MyType value
Hi from another value    //获取了输出中的接收器的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go可以命名接收器的名称，但是若类型定义的所有方法的接收器参数名称一致，则更易读。&lt;/p&gt;
&lt;p&gt;Go开发者通常使用一个字母作为名称：小写的接受器类型名称的首字母（使用m作为MyType接收器的参数名称）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1.能否为任何类型定义新的方法？&lt;br&gt;
方法和类型必须定义在同一包中；意味着不会在hacking包中定义security包中的类型的方法，并且不会为像int或string一类的普通类型定义新的方法。&lt;/p&gt;
&lt;p&gt;2.需要在别人的类型上使用自己的方法&lt;br&gt;
首先考虑是否需要一个函数就足够，函数可以接受需要的任何类型作为参数，但若真的需要一个值具有自定义的方法，在不同的包中给类型增加一些方法，可以创建一个新的类型并将其他包的类型作为匿名字段嵌入，后边会演示如何操作。&lt;/p&gt;
&lt;h1 id=&#34;方法几乎就像一个函数&#34;&gt;方法（几乎）就像一个函数&lt;/h1&gt;
&lt;p&gt;除了在接收器上被调用外，方法与函数完全相同，与其他函数一样，可以在方法名称后面的括号中定义额外的参数，参数变量与接收器参数一样，可以被方法块所访问。当调用方法时，将需要为每个参数提供值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (m MyType) MethodWithParameters(number int, flag bool) {
        fmt.Println(m)
        fmt.Println(number)
        fmt.Println(flag)
}

func main() {
        value := MyType(&amp;#34;MyType value&amp;#34;)
        value.MethodWithParameters(4, true)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MyType value
4
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与函数一样，可以为方法声明一个或多个返回值，返回值将在函数被调用时返回：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (m MyType) WithReturn() int {
        return len(m)
}

func main() {
        value := MyType(&amp;#34;MyType value&amp;#34;)
        fmt.Println(value.WithReturn())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与函数一样，方法名称以大写字母开头，则认为是可导出的，若以小写字母开头，认为是不可导出的。想要在当前包之外使用定义的方法，要确保名字以大写字母开头。&lt;/p&gt;
&lt;h1 id=&#34;指针类型的接收器参数&#34;&gt;指针类型的接收器参数&lt;/h1&gt;
&lt;p&gt;定义了一个新的以int为基础类型的Number类型，为Number类型提供一个名为double的方法，它将接收器的基础类型值乘以2并且重新赋值给接收器，从输出上看方法的接收器并未更新。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Number int  //定义一个基础类型为int的类型

func (n Number) Double() {   //定义一个Number类型
        n *= 2  //接收器的值乘以2，尝试更新接收器
}

func main() {
        number := Number(4)  //创建一个Number的值
        fmt.Println(&amp;#34;Original value of number:&amp;#34;, number)
        number.Double()  //尝试加倍Number
        fmt.Println(&amp;#34;number after calling Double:&amp;#34;, number)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Original value of number: 4
number after calling Double: 4  //Number并未加倍
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之前的double函数也有同样的问题，函数参数接收的是函数调用时的拷贝，不是原始值，当函数退出后任何更新都会失效，为了能让double函数正常，传递一个要更新的值的指针，然后更新该指针指向的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        amount := 6
        double(&amp;amp;amount)  //传递一个指针而不是值
        fmt.Println(amount)
}

func double(number *int) {  //接收指针而不是int值
        *number *= 2  //更新指针指向的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要修改Double方法以使用指针来作其接收器参数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (n *Number) Double() {  //接收器参数接收指针类型
        *n *= 2  //修改指针指向的值
}

func main() {
        number := Number(4)
        fmt.Println(&amp;#34;Original value of number:&amp;#34;, number)
        number.Double()  //不需要修改方法的调用
        fmt.Println(&amp;#34;number after calling Double:&amp;#34;, number)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Original value of number: 4
number after calling Double: 8  //指针指向的值被更新
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不需要修改方法的调用，当用一个非指针的变量调用一个需要指针的接收器的方法时，Go会自动将非指针类型转换为指针类型，同样指针类型也会自动转换为非指针类型，若调用一个要求值类型的接收器，Go会自动获取指针指向的值，然后传递给方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyType string

func (m MyType) method() {
        fmt.Println(&amp;#34;Method with value receiver&amp;#34;)
}
func (m *MyType) pointerMethod() {
        fmt.Println(&amp;#34;Method with pointer receiver&amp;#34;)
}

func main() {
        value := MyType(&amp;#34;a value&amp;#34;)
        pointer := &amp;amp;value
        value.method()
        value.pointerMethod()   //值类型自动转换为指针
        pointer.method()   //指针类型自动转换为值
        pointer.pointerMethod()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Method with value receiver
Method with pointer receiver
Method with value receiver
Method with pointer receiver
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;名为method的方法接受一个值类型的接收器，但我们同时使用了值类型和指针类型，如果需要，Go会自动转换；名为pointerMethod的方法接受一个指针类型的接收器，但是使用了值类型和指针类型调用，如果需要，Go会自动转换。&lt;/p&gt;
&lt;p&gt;为了一致性，所有的类型函数接受值类型或者都接受指针类型，避免混用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为了调用需要接收器指针的方法，需要或者这个值类型的指针！&lt;/p&gt;
&lt;p&gt;只能获取保存在变量中的指针，若尝试获取没有保存在变量中的值的地址，会得到错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;amp;MyType(&amp;#34;a value&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;错误输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cannot take the address of MyType(&amp;#34;a value&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相同的限制也存在于使用接收器指针调用方法时，Go无法将值类型转换为指针类型，除非将接收器的值保存在变量中，若尝试在值类型上调用方法，Go也不会转换为指针，会得到相同的错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MyType(&amp;#34;a value&amp;#34;).pointerMethod()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;错误输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cannot call pointer method on MyType(&amp;#34;a value&amp;#34;)
cannot take the address of MyType(&amp;#34;a value&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要将值保存在变量中，允许Go能得到一个指向它的指针：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;value := MyType(&amp;#34;a value&amp;#34;)
value.pointerMethod()   //将其转化为指针
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;这是一个Number类型，定义了两个方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import &amp;#34;fmt&amp;#34;
type Number int
func (n *Number) Display() {
        fmt.Println(*n)
}
func (n *Number) Double() {
        *n *= 2
}
func main() {
        number := Number(4)
        number.Double()
        number.Display()
}
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;若如此&amp;hellip;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代码会失败，因为：&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func (n &lt;del&gt;*Number&lt;/del&gt;int) Double() {&lt;br&gt;        *n *= 2&lt;br&gt;}&lt;br&gt;&lt;pre&gt;将接收器参数类型改为一个未在当前包中定义的类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能为定义在当前包中的类型定义方法。为一个像int一样全局定义的类型定义方法会导致编译错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func (n &lt;del&gt;*&lt;/del&gt;Number) Double() {&lt;br&gt;        &lt;del&gt;*&lt;/del&gt;n *= 2&lt;br&gt;}&lt;br&gt;&lt;pre&gt;将Double方法的接收器参数改为一个非指针类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收器参数接受了一个接收器的拷贝，若Double函数仅修改这个拷贝，当Double返回的时候，原值不会改变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;Number(4).Double()&lt;pre&gt;在一个没有保存到变量的值上直接调用一个需求接收器的指针的方法&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;当调用一个指针类型的接收器时，如果接收器保存在变量中，Go会自动将值转换为指针类型，若没有保存，会得到一个错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func (n &lt;del&gt;*&lt;/del&gt;Number) Display() {&lt;br&gt;        fmt.Println(&lt;del&gt;*&lt;/del&gt;n)&lt;br&gt;}&lt;br&gt;&lt;pre&gt;将Display方法的接收器参数改为一个非指针类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在修改之后，代码仍能正常运行，但破坏了惯例，方法中的接收器参数可以都是指针，或者都是值类型，避免混用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;使用方法将liters和milliliters转换为gallons&#34;&gt;使用方法将Liters和Milliliters转换为Gallons&lt;/h1&gt;
&lt;p&gt;不同于函数，只要方法定义在不同的类型中，就可以重名。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Liters float64
type Milliliters float64
type Gallons float64

func (l Liters) ToGallons() Gallons {
	return Gallons(l * 0.264)
}
func (m Milliliters) ToGallons() Gallons {
	return Gallons(m * 0.000264)
}

func main() {
	soda := Liters(2)
	fmt.Printf(&amp;#34;%0.3f liters equals %0.3f gallons\n&amp;#34;, soda, soda.ToGallons())
	water := Milliliters(500)
	fmt.Printf(&amp;#34;%0.3f milliliters equals %0.3f gallons\n&amp;#34;, water, water.ToGallons())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2.000 liters equals 0.528 gallons
500.000 milliliters equals 0.132 gallons
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没有使用指针类型作为接收器参数，不需要修改接收器，值类型没有消耗很多内存，参数接受一个拷贝也是合适的。&lt;/p&gt;
&lt;h1 id=&#34;使用方法将gallons转换为liters和milliliters&#34;&gt;使用方法将Gallons转换为Liters和Milliliters&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (g Gallons) ToLiters() Liters {
	return Liters(g * 3.785)
}
func (g Gallons) ToMilliliters() Milliliters {
	return Milliliters(g * 3785.41)
}

func main() {
	milk := Gallons(2)
	fmt.Printf(&amp;#34;%0.3f gallons equals %0.3f liters\n&amp;#34;, milk, milk.Toliters())
	fmt.Printf(&amp;#34;%0.3f gallons equals %0.3f milliliters\n&amp;#34;, milk, milk.ToMilliliters())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;练习：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Liters float64
type Milliliters float64
type Gallons float64

func (l Liters) ToMilliliters() Milliliters {
	return Milliliters(l * 1000)
}
func (m Milliliters) ToLiters() Liters {
	return Liters(m / 1000)
}

func main() {
	l := Liters(3)
	fmt.Printf(&amp;#34;%0.1f liters is %0.1f milliliters\n&amp;#34;, l, l.ToMilliliters())
	ml := Milliliters(500)
	fmt.Printf(&amp;#34;%0.1f milliliters is %0.1f liters\n&amp;#34;, ml, ml.ToLiters())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3.0 liters is 3000.0 milliliters
500.0 milliliters is 0.5 liters
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>8.结构体：struct</title>
      <link>https://tinklespring.com/posts/8.%E7%BB%93%E6%9E%84%E4%BD%93struct/</link>
      <pubDate>Sat, 29 Jul 2023 18:29:46 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/8.%E7%BB%93%E6%9E%84%E4%BD%93struct/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;有时需要保存超过一种类型的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;切片可以保存一组数据，映射能保存一组键和一组值，这两种数据结构都只能保存一种类型。有时需要一组不同类型的数据，例如邮件地址，其中包含了街道名、邮编等，无法使用切片或者映射来保存，但是可以使用 &lt;code&gt;struct&lt;/code&gt; 类型来保存。&lt;/p&gt;
&lt;h1 id=&#34;struct是由多种类型的值构成&#34;&gt;struct是由多种类型的值构成&lt;/h1&gt;
&lt;p&gt;使用struct关键字来声明一个 struct 类型，后面跟花括号，在括号中，可以定义一个或多个字段：struct 组合的值。每一个字段定义在一个单独的行，由字段名称、后面跟着的字段需要保存的值类型组成。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/8-struct/struct%e8%af%ad%e6%b3%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;可以使用一个struct类型来作为定义的变量的类型，例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myStruct struct {
       number float64
       word   string
       toggle bool
}
fmt.Printf(&amp;#34;%#v\n&amp;#34;, myStruct)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct { number float64; word string; toggle bool }
{number:0, word:&amp;#34;&amp;#34;, toggle:false}   //struct中每个字段都被设置成其类型的零值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当调用Printf中的 %#v 时，将myStruct中的值作为struct字面量打印。&lt;/p&gt;
&lt;p&gt;写struct字段时，仅仅在字段名称和类型之间插入一个空格即可，go fmt 会自动格式化。&lt;/p&gt;
&lt;h1 id=&#34;使用点运算符访问struct字段&#34;&gt;使用点运算符访问struct字段&lt;/h1&gt;
&lt;p&gt;我们使用点运算符来表示函数属于另一个包，或方法属于一个值。&lt;/p&gt;
&lt;p&gt;与此类似，可以使用点运算符来标识属于struct的字段，这也可以用于它们的赋值和检索。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myStruct struct {
        number float64
        word   string
        toggle bool
}
myStruct.number = 3.14
myStruct.word = &amp;#34;pie&amp;#34;
myStruct.toggle = &amp;#34;true&amp;#34;   //给struct字段赋值
fmt.Println(myStruct.number)  
fmt.Println(myStruct.word)
fmt.Println(myStruct.toggle)  //从struct字段取值
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在struct中保存订阅者的数据&#34;&gt;在struct中保存订阅者的数据&lt;/h1&gt;
&lt;p&gt;我们知道了如何声明一个保存了struct的变量和如何给字段赋值，可以创建一个来保存杂志订阅者的数据。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var subscriber struct {
        name   string
        rate   float64
        active bool
}
subscriber.name = &amp;#34;Aman Singh&amp;#34;
subscriber.rate = 4.99
subscriber.active = true
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber.name)
fmt.Println(&amp;#34;Monthly rate:&amp;#34;, subscriber.rate)
fmt.Println(&amp;#34;Active?&amp;#34;, subscriber.active)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;尽管订阅者的数据使用了多种方式存储，struct让我们把这些都集中在一个方便的包里。&lt;/p&gt;
&lt;h1 id=&#34;定义类型和struct&#34;&gt;定义类型和struct&lt;/h1&gt;
&lt;p&gt;定义struct变量很麻烦，定义每一个变量时需要重复整个struct类型声明。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var subscriber1 struct {
        name   string
        rate   float64
        active bool
}      //为subscriber1变量定义struct类型
subscriber1.name = &amp;#34;Aman Singh&amp;#34;
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber1.name)
var subscriber2 struct {
        name   string
        rate   float64
        active bool
}     //为subscriber2变量定义struct类型
subscriber2.name = &amp;#34;Beth Ryan&amp;#34;
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber2.name)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们已经使用了多种类型，像int、string、bool、切片、映射和struct，但是无法创建全新类型。&lt;/p&gt;
&lt;p&gt;类型定义允许自己创建新的类型，可以基于基础类型来创建新的定义类型。&lt;/p&gt;
&lt;p&gt;定义一个类型，需要使用&lt;code&gt;type&lt;/code&gt;关键字，后跟新类型的名字，然后是希望基于的基础类型，若使用struct类型作为基础类型，需要使用struct关键字，后跟以花括号包裹的一组字段定义，就像声明struct变量时一样。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/8-struct/type%e7%b1%bb%e5%9e%8b.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;与变量一样，类型定义可以被放在一个函数中，但把它的作用域限定在该函数块中，意味着不能在函数外面使用，所以类型经常定义在函数外的包级别。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type part struct {    //定义一个名为part的类型，part基础类型有下面这俩字段的结构体
	description string
	count       int
}   

type car struct {    //定义一个名为car的类型，car的基础类型是有下面这些字段的struct
	name     string
	topSpeed float64
}

func main() {
	var porsche car    //定义一个car类型的变量
	porsche.name = &amp;#34;Porsche 911 R&amp;#34;   //访问struct的字段
	porsche.topSpeed = 323
	fmt.Println(&amp;#34;Name:&amp;#34;, porsche.name)
	fmt.Println(&amp;#34;Top speed:&amp;#34;, porsche.topSpeed)

	var bolts part
	bolts.description = &amp;#34;Hex bolts&amp;#34;
	bolts.count = 24
	fmt.Println(&amp;#34;Description:&amp;#34;, bolts.description)
	fmt.Println(&amp;#34;Count:&amp;#34;, bolts.count)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当这些变量被声明后，可以设置这些字段的值和取回这些值。&lt;/p&gt;
&lt;h1 id=&#34;定义一个类型&#34;&gt;定义一个类型&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
        name    string
        rate    float64
        active  bool
}

func main() {
        var sub subscriber   //定义一个subscriber类型的变量
        sub.name = &amp;#34;Aman Singh&amp;#34;
        fmt.Println(&amp;#34;Name:&amp;#34;, sub.name)
        var sub2 subscriber  //使用subscriber类型定义第二个变量
        sub2.name = &amp;#34;Beth Ryan&amp;#34;
        fmt.Println(&amp;#34;Name:&amp;#34;, sub2.name)
        
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;与函数一起使用已定义类型&#34;&gt;与函数一起使用已定义类型&lt;/h1&gt;
&lt;p&gt;已定义类型可以用于变量类型以外的地方，也可以用于函数参数和返回值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type part struct {
	description string
	count       int
}

func showInfo(p part) { //声明一个以part作为类型的参数
	fmt.Println(&amp;#34;Description:&amp;#34;, p.description)
	fmt.Println(&amp;#34;Count:&amp;#34;, p.count)
}

func main() {
	var bolts part
	bolts.description = &amp;#34;Hex bolts&amp;#34;
	bolts.count = 24
	showInfo(bolts) //将part传递给函数
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数接受一个单独的参数，使用part作为参数的类型，在showInfo内部，可以像其他struct变量一样通过参数变量访问字段。&lt;/p&gt;
&lt;p&gt;还有一个minimumOrder函数来根据特定的描述创建part和预赋值其中的count字段，将minimumOrder的返回值类型定义为part，这样就能返回一个新的struct：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func minimumOrder(description string) part {  //声明一个part类型的返回值
        var p part    //创建一个part值
        p.description = description
        p.count = 100
        return p   //返回part
}

func main() {
        p := minimumOrder(&amp;#34;Hex bolts&amp;#34;)     //调用minimumOrder，使用一个变量的短声明来保存返回的part
        fmt.Println(p.description, p.count)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面例子，printInfo函数接受subscriber作为参数，并输出它的字段值，defaultSubscriber函数来建立一个新的subscriber struct并赋一些初始的值，它们接受一个名为name的字符串参数并用它来设置新的subscriber的name字段，然后把rate和active字段设置为默认值，最后将整个subscriber struce返回给调用者。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func printInfo(s subscriber) { //声明一个参数，使用subscriber类型
	fmt.Println(&amp;#34;Name:&amp;#34;, s.name)
	fmt.Println(&amp;#34;Monthly rate:&amp;#34;, s.rate)
	fmt.Println(&amp;#34;Active:&amp;#34;, s.active)
}

func defaultSubscriber(name string) subscriber { //返回一个subscriber值
	var s subscriber //创建一个新的subscriber
	s.name = name
	s.rate = 5.99
	s.active = true //设置struct字段
	return s        //返回subscriber
}

func main() {
	subscriber1 := defaultSubscriber(&amp;#34;Aman Singh&amp;#34;) //使用名字来建立一个subscriber
	subscriber1.rate = 4.99                        //使用一个特定的费率
	printInfo(subscriber1)                         //打印字段值
	subscriber2 := defaultSubscriber(&amp;#34;Beth Ryan&amp;#34;)  //使用名字来建立一个subscriber
	printInfo(subscriber2)                         //打印字段值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Name: Aman Singh
Monthly rate: 4.99
Active: true
Name: Beth Ryan
Monthly rate: 5.99
Active: true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在主函数中，可以将subscriber的名称传递给defaultSubscriber来创建一个新的subscriber struct，一个subscriber获取一个打折的费率，所以直接重设struct的字段，传递给一个已经填充完全的subscriber struct给printInfo函数来打印它的内容。&lt;/p&gt;
&lt;p&gt;不要使用一个已经存在的类型名称作为变量的名称！&lt;/p&gt;
&lt;h1 id=&#34;使用函数修改struct&#34;&gt;使用函数修改struct&lt;/h1&gt;
&lt;p&gt;go 是一个按值传递的语言，函数调用时接收的是一个参数的拷贝，若函数修改了参数值，其修改的只是拷贝，而不是原始值。&lt;/p&gt;
&lt;p&gt;对于 struct 也是一样。&lt;/p&gt;
&lt;p&gt;函数能够接收指针来代替直接接收值，当调用这个函数时，使用取址运算符&lt;code&gt;&amp;amp;&lt;/code&gt;来传送需要更新的值的指针，然后在函数内部，使用&lt;code&gt;*&lt;/code&gt;来更新指针指向的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        amount := 6
        double(&amp;amp;amount)   //传递一个指针来取代变量的值
        fmt.Println(amount)
}
func double(number *int) {  //接受一个指针来代替int值
        *number *= 2  //使用指针更新值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用指针来让函数也能更新struct：更新 s 参数类型来接受一个 subscriber struct 的指针，而不是直接使用struct，然后更新 struct 中的rate字段，在main中，调用applyDiscount并传入 subscriber struct 的指针，在输出rate字段时，能看到被更新成功。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func applyDiscount(s *subscriber) { //获取struct的指针，而不是struct
	s.rate = 4.99 //更新struct字段
}

func main() {
	var s subscriber
	applyDiscount(&amp;amp;s) //传入一个指针，而不是struct
	fmt.Println(s.rate)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在double函数中，需要使用 * 运算符来获取指针指向的值，当在applyDiscount函数中设置rate字段时不需要 * 吗？&lt;br&gt;
使用点运算符在struct指针和struct上都可以访问字段。&lt;/p&gt;
&lt;h1 id=&#34;通过指针访问struct的字段&#34;&gt;通过指针访问struct的字段&lt;/h1&gt;
&lt;p&gt;若尝试打印一个变量的指针，会看到其指向的内存地址：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var value int = 2
        var pointer *int = &amp;amp;value
        fmt.Println(pointer)  //输出的是指针不是值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;应该使用 &lt;code&gt;*&lt;/code&gt; 运算符，就像调用取值运算符一样，来获取指针指向的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var value int = 2
        var pointer *int = &amp;amp;value
        fmt.Println(*pointer)  //输出指针指向的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以也需要对指向 struct 的指针使用 &lt;code&gt;*&lt;/code&gt; 运算符，但是直接把 &lt;code&gt;*&lt;/code&gt; 放到指针前是无法工作的，需要使用括号包裹。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type myStruct struct {
        myField int
}

func main() {
        var value myStruct
        value.myField = 3
        var pointer *myStruct = &amp;amp;value
        fmt.Println((*pointer).myField)   //获取指针指向的的struct值，然后访问struct的字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;点运算符允许通过struct的指针来访问字段，就像可以通过struct值直接访问一样，可以不需要括号和&lt;code&gt;*&lt;/code&gt;运算符。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var value myStruct
        value.myField = 3
        var pointer *myStruct = &amp;amp;value
        fmt.Println(pointer.myField)   //通过指针访问struct字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以通过指针来赋值给struct字段：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var vaule myStruct
        var pointer *myStruct = &amp;amp;value
        pointer.myField = 9     //通过指针来赋值给struct字段
        fmt.Println(pointer.myField)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是上边 applyDiscount 函数可以更新struct字段而不用&lt;code&gt;*&lt;/code&gt;运算符，它通过struct指针赋值给rate字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func applyDiscount(s *subscriber) { //获取struct的指针，而不是struct
	s.rate = 4.99 //通过指针赋值给struct字段
}

func main() {
	var s subscriber
	applyDiscount(&amp;amp;s) //传入一个指针，而不是struct
	fmt.Println(s.rate)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在设置struct字段前展示了defaultSubscriber函数，但是它不需要任何指针，这是为什么？&lt;br&gt;
答：defaultSubscriber函数返回了一个struct值，若调用者保存了返回的值，那么struct值中的字段同时会被保存。只有函数修改已经存在的struct而没有返回它们的时候需要使用指针来保存修改项。&lt;br&gt;
若需要时，defaultSubscriber可以返回一个struct的指针。&lt;/p&gt;
&lt;h1 id=&#34;使用指针传递大型struct&#34;&gt;使用指针传递大型struct&lt;/h1&gt;
&lt;p&gt;函数行参接收一个函数调用的实参的拷贝，即使是struct也是这样，若传递一个有很多字段的比较大的struct，会占用很多内存，会为原始的struct和被拷贝的struct都划分空间。&lt;/p&gt;
&lt;p&gt;除非struct字段少，否则要向函数传入struct的指针，即使函数并不修改struct也是如此。当传递一个struct指针时，内存中只有一个原始的struct，并可以读取、修改等操作，都不会产生一个额外的拷贝。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func printInfo(s *subscriber) { //获取指针
	fmt.Println(&amp;#34;Name:&amp;#34;, s.name)
	fmt.Println(&amp;#34;Monthly rate:&amp;#34;, s.rate)
	fmt.Println(&amp;#34;Active:&amp;#34;, s.active)
}

func defaultSubscriber(name string) *subscriber { //返回指针
	var s subscriber
	s.name = name
	s.rate = 5.99
	s.active = true
	return &amp;amp;s //返回一个指向struct的指针，而不是struct自己
}

func applyDiscount(s *subscriber) {
	s.rate = 4.99
}

func main() {
	subscriber1 := defaultSubscriber(&amp;#34;Aman Singh&amp;#34;) //一个struct指针
	applyDiscount(subscriber1)                     //由于这里已经是struct的指针，去掉取址运算符
	printInfo(subscriber1)
	subscriber2 := defaultSubscriber(&amp;#34;Beth Ryan&amp;#34;)
	printInfo(subscriber2)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里defaultSubscriber函数，更改为返回一个指针，且printInfo函数也改成接受一个指针，这些函数不需要像applyDiscount一样修改struct，使用指针确保对于每个struct值，只有一个拷贝在内存中，也能保证程序正常工作。&lt;/p&gt;
&lt;h1 id=&#34;将struct类型移动到另一个包&#34;&gt;将struct类型移动到另一个包&lt;/h1&gt;
&lt;p&gt;将type类型保存在magazine包中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package magazine

type Subscriber struct {
        name   string
        Rate   float64
        active bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        var s magazine.Subscriber
        s.Rate = 4.99
        fmt.Println(s.Rate)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go类型名称与变量和函数名称规则一样，首字母大写被认为可导出，可以从外部包来访问。&lt;/p&gt;
&lt;p&gt;从包中导出struct字段，字段名称的首字母也必须大写。&lt;/p&gt;
&lt;h1 id=&#34;struct字面量&#34;&gt;struct字面量&lt;/h1&gt;
&lt;p&gt;代码定义一个struct并且一个一个的赋值，很不友好，跟切片、映射一样，Go提供了struct字面量来让你创建一个struct并同时为其字段赋值。&lt;/p&gt;
&lt;p&gt;类型列在前，跟着一对花括号，在花括号内部，可以给一些或所有的struct字段赋值，使用字段名称、冒号和值，若定义多个字段，使用逗号分隔。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/8-struct/type%e5%ad%97%e9%9d%a2%e9%87%8f.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;使用struct字面量，创建Subscriber并设置值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;, Rate: 4.99, Active: true}
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber.Name)
fmt.Println(&amp;#34;Rate:&amp;#34;, subscriber.Rate)
fmt.Println(&amp;#34;Active:&amp;#34;, subscriber.Active)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不得不对struct变量使用长声明的方式（除非struct从一个函数中返回），struct字面量允许对刚创建的struct使用短变量声明。&lt;/p&gt;
&lt;p&gt;可以在花括号中忽略一些甚至所有的字段，被忽略的字段会被设置为它们的零值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber{Rate: 4.99}
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber.Name)
fmt.Println(&amp;#34;Rate:&amp;#34;, subscriber.Rate)
fmt.Println(&amp;#34;Active:&amp;#34;, subscriber.Active)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Name:           //被忽略的字段获得了零值
Rate: 4.99
Active: false   //被忽略的字段获得了零值
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;创建一个employee-struct类型&#34;&gt;创建一个Employee struct类型&lt;/h1&gt;
&lt;p&gt;这个新的magazine包，在发布前，需要一个Employee strcut类型来追踪营业员的名称和薪水，并需要把邮件地址放到雇员和订阅者的结构中。&lt;/p&gt;
&lt;p&gt;在magazine包中增加一个类型：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pacakge magazine

type Subscriber struct {
        Name    string
        Rate    float64
        Active  bool
}

type Employee struct {
        Name    string
        Salary  float64
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        var emplpoyee magazine.Employee
        emplpoyee.Name = &amp;#34;Joy Carr&amp;#34;
        emplpoyee.Salary = 60000
        fmt.Println(emplpoyee.Name)
        fmt.Println(emplpoyee.Salary)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;创建一个address-struct类型&#34;&gt;创建一个Address struct类型&lt;/h1&gt;
&lt;p&gt;在Subscriber和Employee类型中增加一个地址，街道、城市、州、和邮编。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Subscriber struct {
        Name    string
        Rate    float64
        Active  bool
        Street  string
        City    string
        State   string
        PostalCode string
}

type Employee struct {
        Name    string
        Salary  float64
        Street  string
        City    string
        State   string
        PostalCode string
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是邮政地址都有相同的格式，无论属于哪个类型，将所有字段在多个类型中重复是痛苦的事情。&lt;/p&gt;
&lt;p&gt;struct字段可以保存任何类型，甚至是struct类型，所以我们创建一个Address struct 类型，然后在Subscriber和Employee类型中增加一个Address类型的字段，并且如果想要修改地址格式，可以保证类型之间的一致性。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Address struct {
        Street  string
        City    string
        State   string
        PostalCode string
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        var address magazine.Address
        address.Street = &amp;#34;123 Oak St&amp;#34;
        address.City = &amp;#34;Omaha&amp;#34;
        address.State = &amp;#34;NE&amp;#34;
        address.PostalCode = &amp;#34;12345&amp;#34;
        fmt.Println(address)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;将struct作为字段增加到另一个类型中&#34;&gt;将struct作为字段增加到另一个类型中&lt;/h1&gt;
&lt;p&gt;给 Subscriber 和 Employee 类型增加一个HomeAddress字段，在struct类型中增加一个struct类型字段与增加其他类型字段相同，字段名称和字段类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package magazine

type Address struct {
        Street  string
        City    string
        State   string
        PostalCode string
}

type Subscriber Struct {
        Name    string
        Rate    float64
        Active  bool
        HomeAddress Address
}

type Employee struct {
        Name    string
        Salary  float64
        HomeAddress Address
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在另一个struct中设置struct&#34;&gt;在另一个struct中设置struct&lt;/h1&gt;
&lt;p&gt;在Subscriber struct中设置 Address struct的字段值，这里有两种方式。&lt;/p&gt;
&lt;p&gt;第一种是创建一个独立的Address struct并使用它填充 Subscriber的整个Address字段：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        address := magazine.Address{Street: &amp;#34;123 Oak St&amp;#34;, City: &amp;#34;Omaha&amp;#34;, State: &amp;#34;NE&amp;#34;, PostalCode: &amp;#34;12345&amp;#34;}
        subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}  //创建一个Address所属的Subscriber struct
        subscriber.HomeAddress = address    //设置HomeAddress字段
        fmt.Println(subscriber.HomeAddress)  //打印HomeAddress字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一种方法是通过外部struct来设置内部struct的字段。&lt;br&gt;
当一个Subscriber struct被创建后，其HomeAddress字段也被设置：它是一个Address struct，所有的字段都被设置为零值，若对fmt.Printf使用&amp;quot;%#v&amp;quot;动词来打印HomeAddress，会打印出它在go代码中的样子，也就是说像struct字面量一样，将看到每一个Address字段被设置为空字符串，也就是string类型的零值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber()
fmt.Printf(&amp;#34;%#v\n&amp;#34;, subscriber.HomeAddress)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;magazine.Address{Street:&amp;#34;&amp;#34;, City:&amp;#34;&amp;#34;, State:&amp;#34;&amp;#34;, PostalCode:&amp;#34;&amp;#34;}  //字段已经像Address struct一样被设置了，每一个字段都被设置为空字符串（字符串的零值）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若subscriber是一个包含Subscriber struct的变量，当输入subscriber.HomeAddress时，会获得一个Address struct，即使没有明确设置HomeAddress。&lt;/p&gt;
&lt;p&gt;可以使用点运算符“链”的方式来访问Address struct中的字段，简单使用subscriber.HomeAddress来访问Address struct，后面跟另一个点运算符和想要访问的Address struct中的字段名称：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber.HomeAddress.City    //subscriber.HomeAddress 这部分返回一个Address struct，City 部分访问Address struct中的City部分
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在subscriber变量中保存一个Subscriber struct，在subscriber的HomeAddress字段中自动创建一个Address struct，设置subscriber.HomeAddress.Street、subscriber.HomeAddress.City和其他的值，然后输出这些值。然后在employee变量中保存Employee struct，并在HomeAddress struct中做相同操作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
	subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}
	subscriber.HomeAddress.Street = &amp;#34;123 Oak St&amp;#34;
	subscriber.HomeAddress.City = &amp;#34;Omaha&amp;#34;
	subscriber.HomeAddress.State = &amp;#34;NE&amp;#34;
	subscriber.HomeAddress.PostalCode = &amp;#34;12345&amp;#34;
	fmt.Println(&amp;#34;Subscriber Name:&amp;#34;, subscriber.Name)
	fmt.Println(&amp;#34;Street:&amp;#34;, subscriber.HomeAddress.Street)
	fmt.Println(&amp;#34;City:&amp;#34;, subscriber.HomeAddress.City)
	fmt.Println(&amp;#34;State&amp;#34;, subscriber.HomeAddress.State)
	fmt.Println(&amp;#34;Postal Code:&amp;#34;, subscriber.HomeAddress.PostalCode)

	// ...  //employee 省略
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;匿名struct字段&#34;&gt;匿名struct字段&lt;/h1&gt;
&lt;p&gt;通过外部struct访问内部struct的字段有点繁琐，想要访问内部struct字段的时候，不得不每次输入代表struct字段的名称。go允许定义一个匿名字段：struct字段没有名字，仅仅只有类型，可以使用匿名字段来让内部struct访问更简单。&lt;/p&gt;
&lt;p&gt;更新 Subscriber 和 Employee 类型，让HomeAddress字段作为一个匿名字段，只需移除字段名称，仅保留字段类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package magazine

type Subscriber struct {
        Name string
        Rate float64
        Active bool
        Address
}

type Employee struct {
        Name  string
        Salary float64
        Address   //删除字段名称（HomeAddress），仅保留类型
}

type Address struct {
        // Fields omitted
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当声明一个匿名字段时，可以使用字段类型名称作为字段名称，所以 subscriber.Address和 employee.Address在下面的代码中仍然访问Address struct：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}
subscriber.Address.Street = &amp;#34;123 Oak St&amp;#34;
subscriber.Address.City = &amp;#34;Omaha&amp;#34;
fmt.Println(&amp;#34;Street:&amp;#34;, subscriber.Address.Street)
fmt.Println(&amp;#34;City:&amp;#34;, subscriber.Address.City)
//...
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;嵌入struct&#34;&gt;嵌入struct&lt;/h1&gt;
&lt;p&gt;匿名字段不只是使struct定义中省略了字段名称。&lt;/p&gt;
&lt;p&gt;一个内部struct使用匿名字段的方式存储在了外部的struct中，这被称为嵌入了外部struct，嵌入struct的字段被提升到了外部struct，可以像访问外部struct的字段一样访问它们。&lt;/p&gt;
&lt;p&gt;所以Address struct类型被嵌入了Subscriber struct和Employee struct类型，不需要写下subscriber.Address.City来获取City字段，可以只写subscriber.City，不需要写下 employee.Address.State，可以只写employee.State。&lt;/p&gt;
&lt;p&gt;修改为将Address当作一个内嵌类型，可以将代码写成完全没有Address类型，就像Address的字段属于它嵌入的struct类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
	subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}
	subscriber.Street = &amp;#34;123 Oak St&amp;#34;
	subscriber.City = &amp;#34;Omaha&amp;#34;
	subscriber.State = &amp;#34;NE&amp;#34;
	subscriber.PostalCode = &amp;#34;12345&amp;#34;  //设置Address的字段就像它们在Subscriber上被定义过一样
	fmt.Println(&amp;#34;Subscriber Name:&amp;#34;, subscriber.Name)
	fmt.Println(&amp;#34;Street:&amp;#34;, subscriber.Street)
	fmt.Println(&amp;#34;City:&amp;#34;, subscriber.City)
	fmt.Println(&amp;#34;State&amp;#34;, subscriber.State)
	fmt.Println(&amp;#34;Postal Code:&amp;#34;, subscriber.PostalCode)

	...  //employee 省略

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不是必须内嵌内部struct，也不是必须使用内部struct，有时给外部struct增加新字段会使代码更干净。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.数据标签：映射</title>
      <link>https://tinklespring.com/posts/7.%E6%95%B0%E6%8D%AE%E6%A0%87%E7%AD%BE%E6%98%A0%E5%B0%84/</link>
      <pubDate>Sat, 22 Jul 2023 11:37:02 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/7.%E6%95%B0%E6%8D%AE%E6%A0%87%E7%AD%BE%E6%98%A0%E5%B0%84/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;当需要使用一个特定的值，为了找到它，需要从数组或切片中查看每一个元素，有一种集合，其中的每个值都有一个标签，那么就可以快速找到需要的值，&lt;code&gt;映射&lt;/code&gt;就是做这个工作的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;从文件中读取名字&#34;&gt;从文件中读取名字&lt;/h1&gt;
&lt;p&gt;有一个文件 votes.txt ：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Amber Graham
Brian Martin
Amber Graham
Brian Martin
Amber Graham
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每一行代表一次投票，需要处理文件的每一行并统计每个名称出现的总次数，获得多票的胜出。&lt;/p&gt;
&lt;p&gt;首先需要读取votes.txt文件的内容，之前有GetFloats函数来读取文件中的每一行，并转换为一个切片，但只能读取float64值，所以需要增加一个GetStrings函数，把每行作为string值添加到返回的切片中。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package datafile

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;os&amp;#34;
)

func GetStrings(fileName string) ([]string, error) {
	var lines []string
	file, err := os.Open(fileName)
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		lines = append(lines, line)
	}
	err = file.Close()
	if err != nil {
		return nil, err
	}
	if scanner.Err() != nil {
		return nil, scanner.Err()
	}
	return lines, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;xxx/xxx/datafile&amp;#34;
	&amp;#34;log&amp;#34;
)

func main() {
	lines, err: = datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(lines)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用困难的切片方法对名字计数&#34;&gt;使用困难的切片方法对名字计数&lt;/h1&gt;
&lt;p&gt;上述代码从文件中读取名字，如何计算名字出现了多少次？有两种方式，一种是切片，另一种是数据结构映射。&lt;/p&gt;
&lt;p&gt;关于使用切片的方式：创建两个切片，每个的长度都是元素的总个数，并是指定的顺序，第一个切片用来保存在文件中找到的名字，每个名字只出现一次，命名为 names；第二个切片命名为counts，保存文件中的名字出现的次数，元素 counts[0] 保存 names[0] 出现的次数，以次类推。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	lines, err := datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
	if err != nil {
		log.Fatal(err)
	}
	var names []string   //这个变量保存人名
	var counts []int     //这个变量保存每个人名出现的次数
	for _, line := range lines {
		matched := false
		for i, name := range names {   //循环处理names切片中的每一个值
			if name == line {      //若line与当前名称匹配
				counts[i]++    //增加对应的count值
				matched = true  //标识找到了匹配的名字
			}
		}
		if matched == false {       //若没有找到匹配名字
			names = append(names, line)  //添加它作为一个新名字
			counts = append(counts, 1)   //并增加一个新的计数（这行是第一次出现）
		}
	}
	for i, name := range names {
		fmt.Printf(&amp;#34;%s: %d\n&amp;#34;, name, counts[i])   //输出names切片中的每一个元素，和对应的counts切片中的元素
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序使用一个循环嵌套在另一个循环中的方式来统计名字的次数，外面的循环把文件中的每行以每次一行的方式赋值给line变量。内部循环通过遍历names切片中的每个元素来查找与文件中的当前行匹配的名称。&lt;/p&gt;
&lt;p&gt;若某人在选票上写一个名字，会导致文件中加载一个字符串，程序会一个一个确认names的元素中是否有等于这个名字。若没有找到匹配项，程序会在names切片末尾追加这个名字，并在counts切片中相应的位置增加1。假如下一行的这个名字已经存在于names切片中，程序会找到位置，在对应位置增加1。&lt;/p&gt;
&lt;h1 id=&#34;映射&#34;&gt;映射&lt;/h1&gt;
&lt;p&gt;保存名字使用的是切片，对于文件中的每一行，必须在许多names切片的值中寻找来进行比较，这样会导致性能差。&lt;/p&gt;
&lt;p&gt;go有一种方法保存数据集合： &lt;code&gt;映射&lt;/code&gt; 。 一个映射是通过&lt;code&gt;键&lt;/code&gt;来访问每一个值的集合，键是一个简单的方式从映射中找出数据。&lt;/p&gt;
&lt;p&gt;相对于数组和切片只能使用整型数字作为索引，映射可以使用任意类型的键（只要这个类型可以使用 == 来比较），包括数字、字符串和其他。所有的值只能是相同的类型，所有的健也需要是相同的类型，但是键和值的类型不必相同。&lt;/p&gt;
&lt;p&gt;声明一个保存映射的变量，需要 &lt;code&gt;map&lt;/code&gt; 关键字，后跟一对包含键类型的方括号&lt;code&gt;[]&lt;/code&gt;，然后在方括号后跟提供值的类型。&lt;br&gt;
&lt;code&gt;var myMap map[string]float64 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/7-%e6%98%a0%e5%b0%84/map%e8%af%ad%e6%b3%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;与切片一样，声明一个映射变量并不会自动创建一个映射，需要调用make函数（与创建切片相同的函数），可以传递给make想要创建的映射类型（与需要赋值到的类型相同）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var ranks map[string]int    //声明一个映射变量
ranks = make(map[string]int) //真正创建一个映射
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;短变量声明方式：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ranks := make(map[string]int)   //创建一个映射并声明一个用于保存它的变量
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;映射的赋值与取值语法跟数组和切片类似，但数组和切片仅允许使用整型作为元素索引，映射可以选择几乎所有的类型来作为键。&lt;/p&gt;
&lt;p&gt;这是一个名为ranks的映射：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ranks[&amp;#34;gold&amp;#34;] = 1
ranks[&amp;#34;silver&amp;#34;] = 2
ranks[&amp;#34;bronze&amp;#34;] = 3
fmt.Println(ranks[&amp;#34;bronze&amp;#34;])
fmt.Println(ranks[&amp;#34;gole&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个键和值都使用string的映射：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;elements := make(map[string]string)
elements[&amp;#34;H&amp;#34;] = &amp;#34;Hydrogen&amp;#34;
elements[&amp;#34;Li&amp;#34;] = &amp;#34;Lithium&amp;#34;
fmt.Println(elements[&amp;#34;Li&amp;#34;])
fmt.Println(elements[&amp;#34;H&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用整型作为键，bool类型作为值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;isPrime := make(map[int]bool)
isPrime[4] = false
isPrime[7] = true
fmt.Println(isPrime[4])
fmt.Println(isPrime[7])
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;映射字面量&#34;&gt;映射字面量&lt;/h1&gt;
&lt;p&gt;若预先知道映射的键和值，可以使用字面量来创建映射，映射字面量是以映射类型（以“映射[键类型]值类型”的形式）开始，后面跟花括号，内含想要映射初始就包含的 键/值 对。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;myMap := map[string]float64{&amp;#34;a&amp;#34;: 1.2, &amp;#34;b&amp;#34;: 5.6}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ranks := map[string]int{&amp;#34;bronze&amp;#34;: 3, &amp;#34;silver&amp;#34;: 2, &amp;#34;gold&amp;#34;: 1}
fmt.Println(ranks[&amp;#34;gold&amp;#34;])
fmt.Println(ranks[&amp;#34;bronze&amp;#34;])
elements := map[string]string{
        &amp;#34;H&amp;#34;: &amp;#34;Hydrogen&amp;#34;,
        &amp;#34;Li&amp;#34;: &amp;#34;Lithium&amp;#34;,
}   //多行映射字面量
fmt.Println(elements[&amp;#34;H&amp;#34;])
fmt.Println(elements[&amp;#34;Li&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与切片字面量一样，花括号为空创建一个空的映射：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;emptyMap := map[string]float64{}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;映射中的零值&#34;&gt;映射中的零值&lt;/h1&gt;
&lt;p&gt;对于数组和切片，若访问一个没有赋值过的键，会得到一个零值，根据值类型 不行，零值不一定是0。比如映射的值类型是string，零值就是空字符串。&lt;/p&gt;
&lt;p&gt;与数组和切片一样，零值可以更安全地修改映射的值，即使在没有给它赋值的情况下。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;counters := make(map[string]int)
counters[&amp;#34;a&amp;#34;]++
counters[&amp;#34;a&amp;#34;]++
counters[&amp;#34;c&amp;#34;]++
fmt.Println(counters[&amp;#34;a&amp;#34;], counters[&amp;#34;b&amp;#34;], counters[&amp;#34;c&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;映射变量的零值是nil&#34;&gt;映射变量的零值是nil&lt;/h1&gt;
&lt;p&gt;与切片一样，映射变量的零值是nil，若声明了一个映射变量但未赋值，是nil，意味着没有映射存在来增加键或值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var nilMap map[int]string
fmt.Printf(&amp;#34;%#v\n&amp;#34;, nilMap)
nilMap[3] = &amp;#34;three&amp;#34;   //映射是nil，无法添加新值，会导致panic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在增加一个新的键值对前，需要使用make或映射字面量来创建一个映射，并赋值给映射变量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myMap map[int]string = make(map[int]string)
myMap[3] = &amp;#34;three&amp;#34;
fmt.Printf(&amp;#34;%#v\n&amp;#34;, myMap)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;如何区分已经赋值的值和零值&#34;&gt;如何区分已经赋值的值和零值&lt;/h1&gt;
&lt;p&gt;虽然零值很有用，但无法判断一个键是被赋值成了零值还是未赋值。&lt;/p&gt;
&lt;p&gt;有一个例子：错误输出了名为 Carl 的人没有通过，实际上并没有记录他的成绩。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func status(name string) {
        grades := map[string]float64{&amp;#34;Alma&amp;#34;: 0, &amp;#34;Rohit&amp;#34;: 86.5}
        grade := grades[name]
        if grade &amp;lt; 60 {
                fmt.Printf(&amp;#34;%s is failing!\n&amp;#34;, name)
        }
}
func main() {
        status(&amp;#34;Alma&amp;#34;)   //一个映射中已经被赋值为0的键
        status(&amp;#34;Carl&amp;#34;)   //一个映射中未被赋值的键
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Alma is failing!
Carl is failing!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为解决此问题，访问映射键的时候可选地获取第2个布尔类型的值，若这个键已经被赋过值，返回true，否则返回false。通常情况下，开发者会将这个布尔值赋给一个名为&lt;code&gt;ok&lt;/code&gt;的变量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;counters := map[string]int{&amp;#34;a&amp;#34;: 3, &amp;#34;b&amp;#34;, 0}
var value int
var ok bool
value, ok = counters[&amp;#34;a&amp;#34;]   //访问一个已经被赋值过的值
fmt.Println(value, ok)      //ok会返回true
value, ok = counters[&amp;#34;b&amp;#34;]   //访问一个已经被赋值过的值
fmt.Println(value, ok)      //ok会返回true
value, ok = counters[&amp;#34;c&amp;#34;]   //访问一个未赋值过的值
fmt.Println(value, ok)      //ok会返回false
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若仅仅要测试值是否存在，可以通过将其赋值给 &lt;code&gt;_&lt;/code&gt; 空白标识符来忽略值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;counters := map[string]int{&amp;#34;a&amp;#34;: 3, &amp;#34;b&amp;#34;: 0}
var ok bool
_, ok = counters[&amp;#34;b&amp;#34;]   //测试值是否存在，但忽略值
fmt.Println(ok)
_, ok = counters[&amp;#34;c&amp;#34;]   //测试值是否存在，但忽略值
fmt.Println(ok)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二个返回值可以用来判断如何处理这个值，是已经赋值了但是正好等于零值，还是从未被赋值过。&lt;/p&gt;
&lt;p&gt;修改后：在输出不及格前测试请求的名字是否已经被赋值过。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func  status(name string) {
       grades := map[string]float64{&amp;#34;Alma&amp;#34;: 0, &amp;#34;Rohit&amp;#34;: 86.4}
       grade, ok := grades[name]
       if !ok {
               fmt.Printf(&amp;#34;No grade recorded for %s.\n&amp;#34;, name)
       } else if grade &amp;lt; 60 {
               fmt.Printf(&amp;#34;%s is failing!\n&amp;#34;, name)
       }
}

func main() {
       status(&amp;#34;Alma&amp;#34;)
       status(&amp;#34;Carl&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;练习：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;data := []string{&amp;#34;a&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;e&amp;#34;}   //需计算在切片中的每个字母的次数
counts := make(map[string]int)    //保存计数的映射
for _, item := range data {
        counts[item]++     //增加当前字母的次数
}    //处理每个字符
letters := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}   //是否这些字符都在映射中存在
for _, letter := range letters {
        count, ok := counts[letters]    //获取当前字符的计数以及是否出现的指示
        if !ok {   //如果字母未找到
                fmt.Printf(&amp;#34;%s: not found\n&amp;#34;, letter)
        } else {   //如果字母找到
                fmt.Printf(&amp;#34;%s: %d\n&amp;#34;, letter, count)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a:2
b:not found
c:1
d:not found
e:2
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用delete函数删除键值对&#34;&gt;使用&amp;quot;delete&amp;quot;函数删除键/值对&lt;/h1&gt;
&lt;p&gt;在分配了值之后，某个时候希望将其从映射中移除，go提供了内建的&lt;code&gt;delete&lt;/code&gt;函数，只需传递给delete两个参数：希望删除数据的映射和希望删除的键，然后键和其关联的值都会被删除。&lt;/p&gt;
&lt;p&gt;如下代码，给两个映射的键分配了值，然后将其删除，之后，尝试访问，获取到零值。（对于ranks映射是0，对于isPrime映射是false）。第二个布尔返回值也是false，说明键已经被删除。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var ok bool
ranks := make(map[string]int)
var rank int
ranks[&amp;#34;bronze&amp;#34;] = 3   //给“bronze”键分配值
rank, ok = ranks[&amp;#34;bronze&amp;#34;]  //由于值存在，ok会返回true
fmt.Printf(&amp;#34;rank: %d, ok: %v\n&amp;#34;, rank, ok)
delete(ranks, &amp;#34;bronze&amp;#34;)   //删除键“bronze”和相关的值
rank, ok = ranks[&amp;#34;bronze&amp;#34;]   //由于值已经被删除了ok返回false
fmt.Printf(&amp;#34;rank: %d, ok: %v\n&amp;#34;, rank, ok)

isPrime := make(map[int]bool)
var prime bool
isPrime[5] = true  //给键5分配值
prime, ok = isPrime[5]  //由于值存在，ok会返回true
fmt.Printf(&amp;#34;prime: %v, ok: %v\n&amp;#34;, prime, ok)
delete(isPrime, 5)   //删除键5和相关的值
prime, ok = isPrime[5]   //由于值被删除，ok会返回false
fmt.Printf(&amp;#34;prime: %v, ok: %v\n&amp;#34;, prime, ok)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rank: 3, ok: true
rank: 0, ok: false
prime: true, ok: true
prime: false, ok: false
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用映射来更新程序&#34;&gt;使用映射来更新程序&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/datafile&amp;#34;
        &amp;#34;log&amp;#34;
)
func main() {
        lines, err := datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
        if err != nil {
                log.Fatal(err)
        }
        counts := make(map[string]int)   //声明一个以人名为键，次数为值的映射
        for _, line := range lines {
                counts[lines]++     //为人名增加计数
        }
        fmt.Println(counts)   //输出填充的映射
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;对映射进行forrange循环&#34;&gt;对映射进行&amp;quot;for&amp;hellip;range&amp;quot;循环&lt;/h1&gt;
&lt;p&gt;为了从映射中格式化每个键和值作为一行，需要使用循环遍历映射中的每一条。&lt;/p&gt;
&lt;p&gt;与数组和切片的 for&amp;hellip;range 循环一样，与将一个整数索引赋值给第一个变量不同，映射将键赋给了第一个变量。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/7-%e6%98%a0%e5%b0%84/%e6%98%a0%e5%b0%84for...range%e5%be%aa%e7%8e%af.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;for&amp;hellip;range 循环让遍历映射中的键和值更方便，仅用一个变量保存键，再用一个变量保存值，并会自动遍历映射中的每一个条目。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import &amp;#34;fmt&amp;#34;
func main() {
        grades := map[string]float64{&amp;#34;Alma&amp;#34;: 74.2, &amp;#34;Rohit&amp;#34;: 86.5, &amp;#34;Carl&amp;#34;: 59.7}
        for name, grade := range grades {
                fmt.Printf(&amp;#34;%s has a grade of %0.1f%%\n&amp;#34;, name, grade)  //打印每一个键和它对应的值
        }  //循环遍历每一个键/值对
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Carl has a grade of 59.7%
Alma has a grade of 74.2%
Rohit has a grade of 86.5%
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若只需要循环所有的键，可以忽略对应的值变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(&amp;#34;Class roster:&amp;#34;)
for name := range grades {
        fmt.Println(name)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Class roster:
Alma
Rohit
Carl
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若只需要值，可以将键赋 _ 空白标识符：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(&amp;#34;Grades:&amp;#34;)
for _, grade := range grades {
        fmt.Println(grade)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Grades:
59.7
74.2
86.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有个问题，如果将之前的结果存入一个文件，并执行，会发现映射的键和值是按照随机顺序打印，若多次执行，每次的结果顺序是不一样的。&lt;/p&gt;
&lt;h1 id=&#34;forrange循环以随机顺序处理映射&#34;&gt;&amp;ldquo;for&amp;hellip;range&amp;quot;循环以随机顺序处理映射&lt;/h1&gt;
&lt;p&gt;for&amp;hellip;range 以随机的顺序遍历映射的键和值，因为映射是一个非有序的键/值对集合。但有时需要按照特定的顺序遍历时，要自己写一些代码了。&lt;/p&gt;
&lt;p&gt;例子：使名字按照字母表的顺序输出，使用了两个for循环，第一个循环遍历映射里边所有的键，忽略值，并把其增加到一个字符串的切片上，然后把切片传递给sort包中的Strings函数来以字母表顺序排序。第二个for循环并不遍历映射，而是遍历变量排序后的名字的切片，输出名字，并从映射中获取与名字对应的值，仍然处理映射中的每一个键和值，但是从已排序好的切片中获取而不是从映射中获取的键。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;sort&amp;#34;
)

func main() {
        grades := map[string]float64{&amp;#34;Alma&amp;#34;: 74.2, &amp;#34;Rohit&amp;#34;: 86.5, &amp;#34;Carl&amp;#34;: 59.7}
        var names []string
        for name := range grades {
                names = append(names, name)
        }
        sort.Strings(names)
        for _, name := range names {
                fmt.Printf(&amp;#34;%s has a grade of %0.1f%%\n&amp;#34;, name, grades[name])
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按照以上代码执行，名字是按照字母表顺序排列，不管执行多少次都是如此。&lt;/p&gt;
&lt;p&gt;若不在乎映射中的数据如何处理，使用for&amp;hellip;range循环就可以，但若是需要顺序，就需要自己写代码处理排序问题。&lt;/p&gt;
&lt;h1 id=&#34;使用forrange更新程序&#34;&gt;使用for&amp;hellip;range更新程序&lt;/h1&gt;
&lt;p&gt;将打印整个映射的行用for&amp;hellip;range替换，把键赋给name变量，把映射的值赋值给count变量，然后用printf输出人命和得票数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/datafile&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        lines, err := datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
        if err != nil {
                log.Fatal(err)       
        }
        counts := make(map[string]int)
        for _, line := range lines {
                counts[line]++
        }
        for name, count := range counts {
                fmt.Printf(&amp;#34;Votes for %s: %d\n&amp;#34;, name, count)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当可用的数据集合是数组和切片时，需要很多额外的代码和处理时间来查找，但使用映射处理起来更简便。&lt;/p&gt;
&lt;p&gt;当需要查找集合中的值的时候，可以考虑映射！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.切片</title>
      <link>https://tinklespring.com/posts/6.%E5%88%87%E7%89%87/</link>
      <pubDate>Tue, 18 Jul 2023 11:42:00 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/6.%E5%88%87%E7%89%87/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;切片是一个可以通过增长来保存额外数据的集合类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;切片&#34;&gt;切片&lt;/h1&gt;
&lt;p&gt;切片实际上是一个go的数据结构，与数组相同的是，切片由多个相同类型的元素构成，不同的是，切片允许在结尾追加更多的元素。&lt;/p&gt;
&lt;p&gt;声明一个保存切片的变量，使用一对空方括号，后面跟着这个切片所保存的元素类型 : &lt;code&gt;var mySlice []string&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;除了不指定大小，与声明一个数组变量的语法完全相同。&lt;/p&gt;
&lt;p&gt;与数组变量不同，声明切片变量并不会自动创建一个切片，可以调用内建的&lt;code&gt;make&lt;/code&gt;函数，传递给&lt;code&gt;make&lt;/code&gt;想要创建的切片类型（这个类型与想要赋值的变量的类型相同）和需要创建的切片的长度。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var notes []string   //声明一个切片变量
notes = make([]string, 7)  //创建7个字符串的切片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当切片被创建后，切片中的元素的赋值和取值操作语法与数组相同。&lt;/p&gt;
&lt;p&gt;无需将变量声明和创建切片分成两步，使用一个短变量声明的make会自动推导出变量类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;primes := make([]int, 5)
primes[0] = 2
primes[1] = 3
fmt.Println(primes[0])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内建的函数&lt;code&gt;len&lt;/code&gt;对切片和数组有相同效果，将一个切片变量传入len，会返回一个整型的长度值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := make([]string, 7)
primes := make([]int, 5)
fmt.Println(len(notes))
fmt.Println(len(primes))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;for&lt;/code&gt;与&lt;code&gt;for...range&lt;/code&gt;数组与切片操作也相同。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;letters := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;}
for i := 0; i &amp;lt; len(letters); i++ {
       fmt.Println(letters[i])
}
for _, letter := range letters {
       fmt.Println(letter)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;切片字面量&#34;&gt;切片字面量&lt;/h1&gt;
&lt;p&gt;与数组相同，若最初知道切片有哪些值，可以使用切片字面量来通过这些值初始化切片。&lt;/p&gt;
&lt;p&gt;切片字面量方括号是空的，后跟切片存储的元素的类型，再跟一个花括号的列表，列表中是每个元素的初始值。&lt;br&gt;
&lt;code&gt;[]int{9, 18, 27}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := []string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
fmt.Println(notes[3], notes[6], notes[0])
primes := []int{
       2,
       3,
       5,
}
fmt.Println(primes[0], primes[1], primes[2])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fa ti do
2 3 5
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;切片运算符&#34;&gt;切片运算符&lt;/h1&gt;
&lt;p&gt;每个切片都构建在一个底层的数组之上，实际上是底层的数组存储了切片的数据；切片仅仅是数组中的一部分（或者所有）元素的视图。&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;make&lt;/code&gt; 函数或者切片字面量创建一个切片的时候，底层的数组会自动创建出来（只有通过切片，才能访问它），但也可以创建一个数组，然后再基于数组通过切片运算符创建一个切片。  &lt;code&gt;mySlice := myArray[1:3]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;切片运算符有两个索引：其中一个标识切片开始的位置，另一个标识切片在此位置之前结束。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;underlyingArray := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slicel := underlyingArray[0:3]
fmt.Println(slicel)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出： &lt;code&gt;[a b c]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：切片需要在第二个位置之前结束。  比如 underlyingArray[i:j] ，生成的切片从 underlyingArray[i] 到 underlyingArray[j-1]。&lt;/p&gt;
&lt;p&gt;若想要一个包含了底层数组最后一个元素的切片，需要在运算符中指定越过数组结尾的第二个索引。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;underlyingArray := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slice3 := underlyingArray[2:5]
fmt.Println(slice3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出： &lt;code&gt;[c d e]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;切片运算符默认需要两个索引，若忽略第一个索引，第一个元素会被使用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;underlyingArray := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slice4 := underlyingArray[:3]
fmt.Println(slice4)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;code&gt;[a b c]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;若忽略了结束的索引，从底层数组的开始索引到数组结尾之间的所有元素都会被包含到结果切片中。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;underlyingArray := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slice5 := underlyingArray[1:]
fmt.Println(slice5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;code&gt;[b c d e]&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;底层数组&#34;&gt;底层数组&lt;/h1&gt;
&lt;p&gt;切片并不会自己保存任何数据，仅仅是底层数组元素的视图。当使用切片的时候，仅仅可以操作通过切片可见的部分。&lt;/p&gt;
&lt;p&gt;甚至可以有多个切片都指向相同的底层数组，每一个切片会是一个指向数组元素的子集的视图，切片甚至可以重叠。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;array3 := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slice3 := array3[0:3]
slice4 := array4[2:5]
fmt.Println(slice3, slice4)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;修改底层数组修改切片&#34;&gt;修改底层数组，修改切片&lt;/h1&gt;
&lt;p&gt;注意：由于切片只是底层数组内容的视图，若修改底层数组，这些变化也会反映到切片。&lt;/p&gt;
&lt;p&gt;给切片的一个元素赋一个新值，也会修改底层数组相应的元素。&lt;/p&gt;
&lt;p&gt;若有多个切片指向了同一个底层数组，数组的元素修改会反映给所有的切片。&lt;/p&gt;
&lt;p&gt;由于这些问题，通常我们会使用 &lt;code&gt;make&lt;/code&gt; 和 &lt;code&gt;切片字面量&lt;/code&gt; 来创建切片，而不是创建一个数组，再用一个切片在上面操作。  使用了 make 和 切片字面量 就不用关心底层数组了。&lt;/p&gt;
&lt;h1 id=&#34;使用append函数在切片上添加数据&#34;&gt;使用&amp;quot;append&amp;quot;函数在切片上添加数据&lt;/h1&gt;
&lt;p&gt;go 提供一个内建的函数 &lt;code&gt;append&lt;/code&gt; 来将一个或多个值追加到切片的末尾，它返回一个与原始切片元素完全相同的并且在尾部追加了新元素的新的更大的切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;slice := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;}
fmt.Println(slice, len(slice))
slice = append(slice, &amp;#34;c&amp;#34;)      //在切片末尾追加一个元素
fmt.Println(slice, len(slice))  //将append返回值赋回相同的切片变量
slice = append(slice, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;)
fmt.Println(slice, len(slice))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[a b] 2
[a b c] 3
[a b c d e] 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;无需记住需要追加到尾部的新值的索引，仅仅调用append函数并且传入切片和需要追加到末尾的值，就会得到一个新的更长的切片。&lt;/p&gt;
&lt;p&gt;注意需要确保将append返回的值重新赋给传递给append的那个变量，这是为了避免append返回的切片中的一些不一致行为。&lt;/p&gt;
&lt;p&gt;切片的底层数组不能增长大小，若数组没有足够的空间来保存新的元素，所有的元素会被拷贝到一个新的更大的数组中，且切片会被更新为引用这个新的数组，但由于这些场景都发生在append函数内部，无法知道返回的切片与传入append函数的切片是否具有相同的底层数组，若保留了两个切片，会导致一些非预期的错误。&lt;/p&gt;
&lt;p&gt;调用append函数，惯例是将函数的返回值赋给传入的那个切片变量，若只保存一个切片，就无需考虑多个切片是否共享同一个底层数组。&lt;/p&gt;
&lt;h1 id=&#34;切片和零值&#34;&gt;切片和零值&lt;/h1&gt;
&lt;p&gt;与数组一样，若访问了一个切片中没有赋值的元素，会得到那个元素类型的零值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;floatSlice := make([]float64, 10)
boolSlice := make([]bool, 10)    //创建元素没有赋值的切片
fmt.Println(floatSlice[9], boolSlice[5])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: &lt;code&gt;0 false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;与数组不同，切片变量有零值：nil，一个没有赋值的切片变量值为 nil。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var intSlice []int
var stringSlice []string
fmt.Printf(&amp;#34;intSlice: %#v, stringSlice: %#v\n&amp;#34;, intSlice, stringSlice)   //&amp;#34;%#v&amp;#34;把值格式化为它在go代码中呈现的样子
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在其他语言中，需要在使用切片变量前先测试是否包含切片，但在go中，函数有意被写成对待nil的切片就像它是一个空切片一样。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(len(intSlice))  //把nil切片传递给len函数，返回0，就像传入一个空的切片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;append函数也会把nil切片看作是一个空的切
片，若append传入了空的切片，会在切片里增加一个元素并返回只有一个元素的切片。 若传入nil切片，也会得到只有一个元素的切片。实际上并没有一个切片来追加元素，append函数会在幕后创建一个切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;intSlice = append(intSlice, 27)   //向append传入一个nil切片
fmt.Printf(&amp;#34;intSlice: %#v\n&amp;#34;, intSlice)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;stringSlice: []string(27)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;意味着通常无需担心切片是nil还是空的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var slice []string   //变量值是nil
if len(slice) == 0 {   //len函数返回0
       slice = append(slice, &amp;#34;first item&amp;#34;)   //append函数会返回一个元素的切片
}
fmt.Printf(&amp;#34;%#v\n&amp;#34;, slce)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[]string{&amp;#34;first item&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用切片和append读取额外的文件行&#34;&gt;使用切片和&amp;quot;append&amp;quot;读取额外的文件行&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func GetFloats(fileName string) ([]float64, error) {    //返回一个切片
       var numbers []float64     //该变量默认为nil，append处理nil的行为与处理空切片一样
       file, err := os.Open(fileName)
       if err != nil {
              return numbers, err
       }
       scanner := bufio.NewScanner(file)
       for scanner.Scan() {
              number, err := strconv.ParseFloat(scanner.Text(), 64)   //将string转换为float64且赋值给一个临时变量
	      if err != nil {
                     return numbers, err
	      }
              numbers = append(numbers, number)   //追加新的数字给切片
       }
       err = file.Close()
       if err != nil {
              return numbers, err
       }
       if scanner.Err() != nil {
              return numbers, scanner.Err()
       }
       return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不必修改主程序中任何代码，因为使用&lt;code&gt;:=&lt;/code&gt;短变量声明，来将GetFloats函数的返回值赋给一个变量，numbers变量自动从[3]float64 (数组类型) 切换到 []float64 (切片类型)，并且 for&amp;hellip;range 循环和len函数对于数组和切片的行为是一致的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;xxx/xxx/datafile&amp;#34;
)

func main() {
	numbers, err := datafile.GetFloats(&amp;#34;data.txt&amp;#34;)  //自动获得一个[]float64来代替[3]float64
	if err != nil {
		log.Fatal(err)
	}
	var sum float64 = 0
	for _, number := range numbers {
		sum += number
	}
	sampleCount := float64(len(numbers))
	fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, sum/sampleCount)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;出错时返回nil值切片&#34;&gt;出错时返回nil值切片&lt;/h1&gt;
&lt;p&gt;进一步优化Getfloats函数，当前，即使出现错误也会返回一个numbers切片，这意味着会返回一个包含无效数据的切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;numbers, err := strconv.ParseFloat(scanner.Text(), 64)
if err != nil {
return numbers, err  //返回了一个不该被使用的无效数据
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用GetFloats的代码应该检查返回的错误值，若不是nil则需要忽略返回的切片。那为啥还要多此一举返回一个包含无效数据的切片？接下来修改GetFloats函数，让函数出错时返回一个nil代替之前的包含无效数据的切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func GetFloats(fileName string) ([]float64, error) {
       var numbers []float64
       file, err := os.Open(fileName)
       if err != nil {
              return nil, err   //返回nil而不是切片，切片在此处的值也是nil，但修改使之更显而易见
       }
       scanner := bufio.NewScanner(file)
       for scanner.Scan() {
              number, err := strconv.ParseFloat(scanner.Text(), 64)
	      if err != nil {
                     return nil, err   //返回nil而不是切片
	      }
              numbers = append(numbers, number)
       }
       err = file.Close()
       if err != nil {
              return nil, err  //返回nil而不是切片
       }
       if scanner.Err() != nil {
              return nil, scanner.Err()  //返回nil而不是切片
       }
       return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;命令行参数&#34;&gt;命令行参数&lt;/h1&gt;
&lt;p&gt;每当要计算一个新的平均数时，都要修改data.txt，有一种替代方案：用户把值作为命令行参数传递给程序。&lt;/p&gt;
&lt;p&gt;就像通过传入不同的参数来控制函数的行为一样，在终端传递参数给程序，这叫做&lt;code&gt;命令行接口&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;从osargs切片获取命令行参数&#34;&gt;从&amp;quot;os.Args&amp;quot;切片获取命令行参数&lt;/h1&gt;
&lt;p&gt;os 包有一个包级别的变量 os.Args , 是一个字符串的切片，代表了当前执行程序的命令行参数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;os&amp;#34;
)

func main() {
       fmt.Println(os.Args)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如将上述代码编译后，运行:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./xxx a b c d e

输出：
[./xxx a b c d e]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;切片运算符可用于其他切片&#34;&gt;切片运算符可用于其他切片&lt;/h1&gt;
&lt;p&gt;上述 ./xxx 是程序的名字，我们并不想要，解决：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;os&amp;#34;
)

func main() {
       fmt.Println(os.Args[1:])    //获取一个包含os.Args的从第二个元素到最后一个元素的新的切片
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就避免了上述问题。&lt;/p&gt;
&lt;h1 id=&#34;使用命令行参数&#34;&gt;使用命令行参数&lt;/h1&gt;
&lt;p&gt;在 os.Args 上使用切片运算符来忽略程序名称，并把返回切片赋给一个 arguments 变量，设置一个 sum 变量来保存所有输入数字的和，然后使用 for&amp;hellip;range 循环来处理 arguments 的元素（使用 _ 空白标识符来忽略元素索引）。使用strconv.ParseFloat 来将参数从字符串转换为 float64 ，若出现错误，输出并退出，若无错误，将数字累加到 sum。 当循环处理完所有参数时，用 len(arguments) 来确定样本个数，然后用 sum 除以样本个数得到平均值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;os&amp;#34;
	&amp;#34;strconv&amp;#34;
)

func main() {
	arguments := os.Args[1:]             //通过os.Args获取一个不包含首元素的字符串切片
	var sum float64 = 0                  //定义一个保存数字的累加值
	for _, argument := range arguments { //处理命令行的每一个参数
		number, err := strconv.ParseFloat(argument, 64) //将字符串转换为float64
		if err != nil {
			log.Fatal(err)
		} //若转换函数出现问题则输出log并退出
		sum += number //累加数字
	}
	sampleCount := float64(len(arguments))          //参数的长度可以用作样本的个数
	fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, sum/sampleCount) //计算平均值并进行打印
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;可变长参数函数&#34;&gt;可变长参数函数&lt;/h1&gt;
&lt;p&gt;一些函数调用可以获取任何个数的参数，例如 fmt.Println 或 append 。但不要直接在任何函数中使用，定义的所有函数的参数个数与函数调用的参数个数要严格匹配，否则会导致编译错误。&lt;/p&gt;
&lt;p&gt;那么 Println 与 append 是如何做到的呢？因为它定义了一个&lt;code&gt;可变长参数函数&lt;/code&gt;，一个可变长参数函数可以以多种参数个数来调用，为了让函数的参数可变长，在函数声明中的最后的（或仅有的）参数类型前使用省略号&lt;code&gt;...&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func myFunc(param1 int, param2 ...string) {
       //function code here
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;可变长参数函数的最后一个参数接收一个切片类型的变长参数&lt;/code&gt;，这个切片可以被函数当作普通切片来处理。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func severalInts(numbers ...int) {
       fmt.Println(numbers)
}

func main() {
       severalInts(1)
       severalInts(1, 2, 3)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有一个带有字符串参数的函数，若不提供变长参数，不会返回错误，会收到一个空切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func severalStrings(strings ...string) {
       fmt.Println(strings)
}

func main() {
       severalStrings(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;)
       severalStrings()   //若没有参数，会收到一个空的切片
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数也可以接收一个或多个非可变长参数，即使一个函数调用可以忽略可变长参数，其中的非可变长参数是不可忽略的，若忽略会导致编译失败。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;只有函数定义中的最后一个参数是可变长参数&lt;/code&gt; ，不能放到其他必需参数前。&lt;/p&gt;
&lt;h1 id=&#34;使用可变长参数函数&#34;&gt;使用可变长参数函数&lt;/h1&gt;
&lt;p&gt;maximum 函数会接收任意个数的float64参数并会返回其中的最大值，这个函数的所有参数被保存在一个切片类型的参数 numbers 中，初始设置当前最大值为 -Inf ，一个代表了负无穷的特殊值，通过调用math.Inf获得。（可以使用当前最大值0，但这个最大值可能是负数），然后使用 for&amp;hellip;range 来处理 numbers 上的每个值，将其与最大值比较。若大于最大值，将其设置为最大值，处理完所有参数后剩下的最大值就是要返回的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;math&amp;#34;
)

func maximum(numbers ...float64) float64 {  //接收任何个数的float64参数
	max := math.Inf(-1)   //以一个很小的值开始
	for _, number := range numbers {
		if number &amp;gt; max {
			max = number   //找到参数中的最大值
		}
	}   //处理变长参数的每一个值
	return max
}

func main() {
	fmt.Println(maximum(71.8, 56.2, 89.5))
	fmt.Println(maximum(90.7, 89.7, 98.5, 92.3))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;ldquo;inRange&amp;quot;函数，接收一个最小值，一个最大值和任何个数的float64参数，丢弃在给定最小值和给定最大值范围之外的参数，返回一个在范围之内的参数值的切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func inRange(min float64, max float64, numbers ...float64) []float64 {
	var result []float64   //这个切片会保存范围内的值
	for _, number := range numbers {
		if number &amp;gt;= min &amp;amp;&amp;amp; number &amp;lt;= max {
			result = append(result, number)
		}
	}
	return result
}

func main() {
	fmt.Println(inRange(1, 100, -12.5, 3.2, 0, 50, 103.5))   //寻找&amp;gt;=1且&amp;lt;=100的参数
	fmt.Println(inRange(-10, 10, 4.1, 12, -12, -5.2))   //寻找&amp;gt;=-10且&amp;lt;=10的参数
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用可变长参数函数计算平均值&#34;&gt;使用可变长参数函数计算平均值&lt;/h1&gt;
&lt;p&gt;来创造一个可以接收任意多个float64类型参数，并返回它们的平均值的可变长参数函数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func average(numbers ...float64) float64 {  //获取任意个数的float64参数
	var sum float64 = 0   //定义一个变量来保存参数的总和
	for _, number := range numbers {
		sum += number
	}
	return sum / float64(len(numbers))
}

func main() {
	fmt.Println(average(100, 50))
	fmt.Println(average(90.7, 89.7, 98.5, 92.3))
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;向可变长参数函数传递一个切片&#34;&gt;向可变长参数函数传递一个切片&lt;/h1&gt;
&lt;p&gt;将numbers切片传递给average函数。&lt;/p&gt;
&lt;p&gt;当调用一个可变长参数函数时，在传入的切片变量后增加省略号&lt;code&gt;...&lt;/code&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func severalInts(numbers ...int) {
       fmt. Println(numbers)
}
func mix(num int, flag bool, strings ...string) {
       fmt.Println(num, flag, strings)
}
func main() {
       intSlice := []int{1, 2, 3}
       severalInts(intSlice...)   //使用int切片代替可变参数
       stringsSlice := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;}
       mix(1, true, stringsSlice...)   //使用string切片代替可变参数
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;log&amp;#34;
       &amp;#34;os&amp;#34;
       &amp;#34;strconv&amp;#34;
)

func average(numbers ...float64) float64 {
	var sum float64 = 0
	for _, number := range numbers {
		sum += number
	}
	return sum / float64(len(numbers))
}

func main() {
        arguments := os.Args[1:]
        var numbers []float64  //该切片保存了将要被计算平均值的数字
	for _, argument := range arguments {
               number, err := strconv.ParseFloat(argument, 64)
	       if err != nil {
                      log.Fatal(err)
	       }
               numbers = append(numbers, number)
	}
        fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, average(numbers...))  //向可变参数函数传入切片
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会把命令行参数转换为float64的切片，然后传递给可变参数的average函数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.数组</title>
      <link>https://tinklespring.com/posts/5.%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 15 Jul 2023 10:11:00 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/5.%E6%95%B0%E7%BB%84/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;go 有两种内置的存储列表的方式，本篇介绍其中一种：数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;数组保存值的集合&#34;&gt;数组保存值的集合&lt;/h1&gt;
&lt;p&gt;数组是所有共享同一类型的值的集合。&lt;/p&gt;
&lt;p&gt;数组中包含的值称为它的&lt;code&gt;元素&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以有一个字符串数组、一个布尔数组或其他类型的数组（甚至数组的数组）。&lt;/p&gt;
&lt;p&gt;可以将整个数组存储在单个变量中，然后访问数组中所需要的任何元素。&lt;/p&gt;
&lt;p&gt;数组保存特定数量的元素，不能增长或收缩，要声明保存数组的变量，需要在方括号&lt;code&gt;[]&lt;/code&gt;中指定它所保存的元素数量，后跟数组所保存的元素类型。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/5-%e6%95%b0%e7%bb%84/%e5%a3%b0%e6%98%8e%e6%95%b0%e7%bb%84.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;要设置数组元素的值或稍后检索值，需要一种方法来指定哪个元素，数组中的元素从0开始编号，一个元素的编号称为其&lt;code&gt;索引&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如，创建一个由7个字符串组成的数组：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var notes [7]string
notes[0] = &amp;#34;do&amp;#34;    //给第一个元素赋值
notes[1] = &amp;#34;re&amp;#34;
notes[2] = &amp;#34;mi&amp;#34;
fmt.Println(notes[0])   //打印第一个元素
fmt.Println(notes[1])   //打印第二个元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个整型数组：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var primes [5]int
primes[0] = 2
primes[1] = 3
fmt.Println(primes[0])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;time.Time值的数组：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var dates [3]time.Time
dates[0] = time.Unix(1257894000, 0)
dates[1] = time.Unix(1447920000, 0)
dates[2] = time.Unix(1508632200, 0)
fmt.Println(dates[1])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: &lt;code&gt;2015-11-19 08:00:00 +0000 UTC&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;数组中的零值&#34;&gt;数组中的零值&lt;/h1&gt;
&lt;p&gt;与变量一样，当创建一个数组时，其所包含的所有值都被初始化为该数组所保存类型的零值。默认情况下，一个 int 值数组用0填充。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var primes [5]int
primes[0] = 2
fmt.Println(primes[0])   //打印显示赋值的元素
fmt.Println(primes[2])   //打印未显式赋值的元素
fmt.Println(primes[4])   //打印未显式赋值的元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2
0
0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字符串的零值是一个空字符串，默认情况下，一个字符串值数组用空字符串填充。&lt;/p&gt;
&lt;p&gt;零值可以使操作数组元素变得安全，即使没有显式为其赋值。 &lt;br&gt;
例如：一个整数计数器数组，可以在不首先显式赋值的情况下给它们中任何一个赋值，因为其都是从0开始。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var counters [3]int
counters[0]++    //将第一个元素从0增加到1
counters[0]++    //将第一个元素从1增加到2
counters[2]++    //将第三个元素从0增加到1
fmt.Println(counters[0], counters[1], counters[2])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2
0
1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建数组时，其所包含的所有值都初始化为数组所保存类型的零值。&lt;/p&gt;
&lt;h1 id=&#34;数组字面量&#34;&gt;数组字面量&lt;/h1&gt;
&lt;p&gt;若事先知道数组应该保存哪些值，可以使用数组字面量来初始化数组。数组字面量的开头与数组类型类似，其元素的数量将放在方括号中，后跟元素的类型，再后面跟大括号，里面是每个元素应该具有的初始值列表，元素值用逗号分隔。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/5-%e6%95%b0%e7%bb%84/%e6%95%b0%e7%bb%84%e5%ad%97%e9%9d%a2%e9%87%8f.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;与之前不同，不是逐个为数组元素赋值，而是使用数组字面量初始化整个数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;数组字面量&lt;/code&gt;允许使用短变量声明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
primes := [5]int{2, 3, 5, 7, 11}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以将数组字面量分散到多行上，但必须在代码中的每个换行字符前使用逗号，若数组字面量的最后一项后面跟着换行符，需要在其后面跟一个逗号。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;text := [3]string{
       &amp;#34;this is a series of long strings&amp;#34;,
       &amp;#34;which would be awkward to place&amp;#34;,
       &amp;#34;together on a single line&amp;#34;,    //末尾的逗号是必须的。
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;fmt包中的函数如何处理数组&#34;&gt;&amp;ldquo;fmt&amp;quot;包中的函数如何处理数组&lt;/h1&gt;
&lt;p&gt;当只想调试代码时，不必逐个将数组元素传递给fmt包中的Println和其他函数，只需传递整个数组。fmt包有做格式化和打印数组的逻辑。（fmt包还可以处理切片、映射和其他数据结构）&lt;/p&gt;
&lt;p&gt;Printf和Sprintf函数使用的&amp;rdquo;%#v&amp;quot;动词，将按照go代码中显示的方式格式化值，当用&amp;quot;%#v&amp;quot;格式化时，数组在结果中显示为go数组字面量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var notes [3]string = [3]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;}
var primes [5]int = [5]int{2, 3, 5, 7, 11}
fmt.Printf(&amp;#34;%#v\n&amp;#34;, notes)
fmt.Printf(&amp;#34;%#v\n&amp;#34;, primes)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[3]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;}
[5]int{2, 3, 5, 7, 11}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在循环里访问数组元素&#34;&gt;在循环里访问数组元素&lt;/h1&gt;
&lt;p&gt;不必显示地编写代码中要访问的数组元素的整数索引。 可以使用整型变量中的值作为数组索引。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
index := 1
fmt.Println(index, notes[index])  //打印索引1处的数组元素
index = 3
fmt.Println(index, notes[index])  //打印索引3处的数组元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这意味着可以使用for循环来处理数组元素之类的操作，循环遍历数组中的索引，并使用循环变量访问当前索引处的元素。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for i := 0; i &amp;lt;= 2; i++ {
       fmt.Println(i, notes[i])
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用len函数检查数组长度&#34;&gt;使用&amp;quot;len&amp;quot;函数检查数组长度&lt;/h1&gt;
&lt;p&gt;写只访问有效数组索引的循环容易出错，有两种方式。&lt;/p&gt;
&lt;p&gt;第一种是在访问数组前检查数组中元素的的实际数量，可以使用内置的&lt;code&gt;len&lt;/code&gt;函数来实现，该函数返回数组的长度（其包含的元素个数）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
fmt.Println(len(notes))   //打印“notes”数组的长度
primes := [5]int{2, 3, 5, 7, 11}
fmt.Println(len(primes))  //打印“primes”数组的长度
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置循环以处理整个数组时，可以使用&lt;code&gt;len&lt;/code&gt;确定哪些索引可以安全访问。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for i := 0; i &amp;lt; len(notes); i++ {
       fmt.Println(i, notes[i])
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若len(notes)返回7，可访问的索引最多是6，因为数组索引从0开始。&lt;/p&gt;
&lt;h1 id=&#34;使用forrange安全遍历数组&#34;&gt;使用&amp;quot;for&amp;hellip;range&amp;quot;安全遍历数组&lt;/h1&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/5-%e6%95%b0%e7%bb%84/forrange.png&#34;
        alt/&gt;&lt;br&gt;
在range格式中，提供一个变量，该变量保存每个元素的整数索引，另一个变量保存元素本身的值，以及要循环的数组，循环将为数组中的每个元素运行一次，将元素的索引赋值给第一个变量，将元素的值赋值给第二个变量，然后在循环块中添加代码处理这些值。&lt;/p&gt;
&lt;p&gt;这种for循环形式没有混乱的初始化、条件和标志（post）表达式，由于元素值是自动分配给变量的，因此不会有意外访问无效数组索引的风险。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for index, note := range notes {
       fmt.Println(index, note)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于每个元素，index变量设置为元素的索引，note变量设置为元素的值。&lt;/p&gt;
&lt;h1 id=&#34;在forrange循环中使用空白标识符&#34;&gt;在&amp;quot;for&amp;hellip;range&amp;quot;循环中使用空白标识符&lt;/h1&gt;
&lt;p&gt;go 要求使用声明的每个变量，若停止使用&lt;code&gt;for...range&lt;/code&gt;循环中的变量，将编译错误。&lt;/p&gt;
&lt;p&gt;当调用一个具有多个返回值的函数时，忽略其中一个返回值，将该值赋值给空白标识符&lt;code&gt;_&lt;/code&gt;，这会让go丢弃该值，而不会编译错误。&lt;/p&gt;
&lt;p&gt;若不需要每个数组元素的索引，可以：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for _, note := range notes {
       fmt.Println(note)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若不需要值变量，也可以使用空白标识符：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for index, _ := range notes {
       fmt.Println(index)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;获得数组中数字的平均值&#34;&gt;获得数组中数字的平均值&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
	numbers := [3]float64{71.8, 56.2, 89.5}
	var sum float64 = 0
	for _, number := range numbers {
		sum += number
	}
	sampleCount := float64(len(numbers))            //获取类型为int的数组长度，并将其转换为float64
	fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, sum/sampleCount) //将数组值的总和除以数组长度得到平均值
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;读取文本文件&#34;&gt;读取文本文件&lt;/h1&gt;
&lt;p&gt;编辑一个data.txt文件，将三个数据写进去：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;71.8
56.2
89.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先编写一个读取文件的程序：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;os&amp;#34;
)

func main() {
	file, err := os.Open(&amp;#34;data.txt&amp;#34;) //打开文件进行读取
	if err != nil {
		log.Fatal(err)
	} //若打开文件时出现错误，报告错误并退出
	scanner := bufio.NewScanner(file) //为文件创建一个新的扫描器
	for scanner.Scan() {              //从文件中读取一行
		fmt.Println(scanner.Text()) //打印该行
	} //循环至文件结尾，scanner.Scan返回false
	err = file.Close() //关闭文件以释放资源
	if err != nil {
		log.Fatal(err)
	} //若关闭文件时出现错误，报告错误并退出
	if scanner.Err() != nil {
		log.Fatal(scanner.Err())
	} //若扫描文件时出现错误，报告错误并退出
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述程序如何工作：&lt;br&gt;
首先向 os.Open 函数传递一个带有要打开文件的名字的字符串，从 os.Open 会返回两个值：指向代表被打开文件的 os.File 值的指针，以及一个错误值。若错误值为 nil ，则表示文件成功打开，其他任何值都表示存在错误（比如文件丢失或不可读）。若错误，则会记录错误信息并退出程序。&lt;/p&gt;
&lt;p&gt;然后将 os.File 值传递给 bufio.NewScanner 函数，将返回一个从文件中读取的 bufio.Scanner 值。&lt;/p&gt;
&lt;p&gt;bufio.Scanner 上的 Scan 方法是用来作为 for 循环的一部分。将从文件中读取一行文本，若读取数据成功则返回 true ，否则返回 false 。若将 Scan 用作 for 循环的条件，那么只要有更多的数据需要读取，循环就会继续运行，一旦到达文件的结尾（或出现错误），Scan 将返回 false ，循环退出。&lt;/p&gt;
&lt;p&gt;在 bufio.Scanner 上调用 Scan 方法后，调用 Text 方法将返回一个包含已经读取数据的字符串，对这个程序，调用 Println 打印每一行。&lt;/p&gt;
&lt;p&gt;一旦循环退出，就完成了对文本的处理，保持文件打开会消耗操作系统的资源，因此当程序完成对文件操作时要对文件进行关闭。对 os.File 调用 Close 方法将完成对文件的关闭。与 Open 函数一样，Close 方法也返回一个 error 值，除非出现错误，否则该值为 nil ，（与 Open 不同，Close 只返回一个值，除了错误外没有其他值可以返回）。&lt;/p&gt;
&lt;p&gt;在扫描文件时，bufio.Scanner 也可能遇到错误，调用扫描器上的 Err 方法将返回该错误，在退出之前记录该错误。&lt;/p&gt;
&lt;h1 id=&#34;将文本数据读入数组&#34;&gt;将文本数据读入数组&lt;/h1&gt;
&lt;p&gt;需要将data.txt读取的字符串转换为数字并存储在数组中: &lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/5-%e6%95%b0%e7%bb%84/%e5%b0%86%e6%96%87%e4%bb%b6%e8%af%bb%e5%85%a5%e6%95%b0%e7%bb%84.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Package datafile allows reading data sample from files.
package datafile

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;os&amp;#34;
	&amp;#34;strconv&amp;#34;
)

// GetFloats reads a float64 from each line of a file.
func GetFloats(fileName string) ([3]float64, error) {
	var numbers [3]float64
	file, err := os.Open(fileName)
	if err != nil {
		return numbers, err
	}
	i := 0
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		numbers[i], err = strconv.ParseFloat(scanner.Text(), 64)
		if err != nil {
			return numbers, err
		}
		i++
	}
	err = file.Close()
	if err != nil {
		return numbers, err
	}
	if scanner.Err() != nil {
		return numbers, scanner.Err()
	}
	return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;希望能读取除了data.txt意外的文件，因此接受打开的文件名作为参数，将函数设置为返回两个值，一个float64值数组和一个错误值。只有当错误值为nil时，才应将第一个返回值视为可用。&lt;/p&gt;
&lt;p&gt;接下来，声明一个由三个float64值组成的数组，将保存从文件中读取的数字。&lt;/p&gt;
&lt;p&gt;与之前代码一样，打开文件进行读取，不同之处在于，打开传递给函数的任何文件名，而不是硬编码的 &amp;ldquo;data.txt&amp;rdquo; 字符串，若遇到错误，需要返回一个数组以及错误值，所以只返回numbers数组（尽管还没有为其赋值）。&lt;/p&gt;
&lt;p&gt;需要知道将每一行赋值给哪个数组元素，因此创建一个变量来跟踪当前索引。&lt;/p&gt;
&lt;p&gt;设置bufio.Scanner和循环遍历文件行的代码与之前的代码相同，但是循环的代码不同，需要对从文件中读取的字符串调用 strconv.ParseFloat 来将其转换为 float64 ，并将结果赋值给数组。若ParseFloat导致了错误，需要返回该错误，若解析成功，需要对 i 增值，以便下一个数被赋值给下一个数组元素。&lt;/p&gt;
&lt;p&gt;关闭文件并报告任何错误，若没有错误，将到达 GetFloats 函数末尾，并返回float64值数组以及nil错误。&lt;/p&gt;
&lt;h1 id=&#34;更新程序读取文本文件&#34;&gt;更新程序读取文本文件&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;xxx/xxx/datafile&amp;#34;
       &amp;#34;log&amp;#34;
)

func main() {
       numbers, err := datafile.GetFloats(&amp;#34;data.txt&amp;#34;)
       if err != nil {
              log.Fatal(err)
       }
       var sum float64 = 0
       for _, number := range numbers {
              sum += number
       }
       sampleCount := float64(len(numbers))
       fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, sum/sampleCount)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述程序只有在data.txt中有三行或更少行时才运行，若超过三行则会报错。  因为声明了 numbers 数组来保存3个元素。&lt;/p&gt;
&lt;p&gt;Go数组的大小是固定的，不能增长或收缩。下一篇将解决这个问题！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4.代码集：包</title>
      <link>https://tinklespring.com/posts/4.%E4%BB%A3%E7%A0%81%E9%9B%86%E5%8C%85/</link>
      <pubDate>Tue, 11 Jul 2023 15:57:40 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/4.%E4%BB%A3%E7%A0%81%E9%9B%86%E5%8C%85/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;到目前位置，一直将代码放在一个文件里，随着程序变得越来越大、越来越复杂，这会是一个大问题～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;使用包在程序之间共享代码&#34;&gt;使用包在程序之间共享代码&lt;/h1&gt;
&lt;p&gt;将共享函数移到新的包中！&lt;/p&gt;
&lt;p&gt;golang允许定义自己的包，包是一组代码，fmt包格式化输出，math包处理数字，strings包处理字符串，已经在多个程序中使用了来自每一个包的函数。&lt;/p&gt;
&lt;p&gt;能够在程序之间使用相同的代码是包存在的主要原因之一。&lt;/p&gt;
&lt;h1 id=&#34;go工作区目录保存包代码&#34;&gt;go工作区目录保存包代码&lt;/h1&gt;
&lt;p&gt;工作区目录包含三个子目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bin ：保存已编译的二进制可执行程序；&lt;/li&gt;
&lt;li&gt;pkg ：保存已编译的二进制包文件；&lt;/li&gt;
&lt;li&gt;src ：保存go的源代码；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在src中，每个包的代码都位于它自己单独的子目录中，按照惯例，子目录名应与包名相同。&lt;/p&gt;
&lt;p&gt;每个包目录应该包含一个或多个源代码文件，文件名不重要，但要以 &lt;code&gt;.go&lt;/code&gt; 结尾。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/4-%e4%bb%a3%e7%a0%81%e9%9b%86-%e5%8c%85/go%e5%b7%a5%e4%bd%9c%e5%8c%ba%e7%9b%ae%e5%bd%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建一个新包&#34;&gt;创建一个新包&lt;/h1&gt;
&lt;p&gt;做一个简单的包：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
└── src
    └── greeting
        └── greeting.go
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与所有go源代码文件一样，这个文件以package行开始，与其他代码不同，这段代码不是main包的一部分，是一个名为greeting的包的一部分。还有两个函数定义，希望这些函数可以在greeting包之外访问，所以需要首字母大写：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package greeting

import &amp;#34;fmt&amp;#34;

func Hello() {
	fmt.Println(&amp;#34;Hello!&amp;#34;)
}
func Hi() {
	fmt.Println(&amp;#34;Hi!&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;将包导入程序&#34;&gt;将包导入程序&lt;/h1&gt;
&lt;p&gt;在程序中使用新包：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
└── src
    ├── greeting
    │   └── greeting.go
    └── hi
        └── main.go
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与每个go源代码文件一样，这段代码从package开始，但希望这是一个可执行的命令，需要使用main的包名。&lt;/p&gt;
&lt;p&gt;通常，包名应与所在目录名保持一致，但是main包例外。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;greeting&amp;#34;

func main() {
	greeting.Hello()
	greeting.Hi()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;导入greeting包，该目录名与 import 语句中的名称相匹配。&lt;/p&gt;
&lt;h1 id=&#34;包使用相同的文件布局&#34;&gt;包使用相同的文件布局&lt;/h1&gt;
&lt;p&gt;与main包一样，都要有三部分结构： package 子句、import 语句、实际代码。&lt;/p&gt;
&lt;h1 id=&#34;包命名规范&#34;&gt;包命名规范&lt;/h1&gt;
&lt;p&gt;每次调用包中的函数时都要输入包名，包名遵循以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包名应全部为小写；&lt;/li&gt;
&lt;li&gt;若含义明显，应缩写；&lt;/li&gt;
&lt;li&gt;尽可能是一个词，若是两个词，不应该用下划线分隔，第二个词也不应该大写；&lt;/li&gt;
&lt;li&gt;导入的包名避免与本地变量名冲突；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;包限定符&#34;&gt;包限定符&lt;/h1&gt;
&lt;p&gt;当访问从不同包导出的函数、变量或其他东西时，需要通过在函数或变量钱输入包名来限定其名称；当访问定义在当前包中的函数或变量时，不应该限定包名。&lt;/p&gt;
&lt;h1 id=&#34;常量&#34;&gt;常量&lt;/h1&gt;
&lt;p&gt;许多包导出常量：从不更改的命名值。&lt;/p&gt;
&lt;p&gt;声明常量看起来像变量声明，具有名称、可选的类型和常量值，不同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;const&lt;/code&gt;关键字而不是var关键字；&lt;/li&gt;
&lt;li&gt;必须在声明常量时赋值，不能像变量那样后赋值；&lt;/li&gt;
&lt;li&gt;变量有短变量声明语法，常量没有；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与变量声明一样，可以省略类型，将从分配的值推断：&lt;code&gt;const SquareSides = 4&lt;/code&gt; ;&lt;/p&gt;
&lt;p&gt;变量的值可以变化，但常量值必须保持不变。&lt;/p&gt;
&lt;p&gt;与变量和函数一样，名称以大写字母开头的常量是可导出的。&lt;/p&gt;
&lt;h1 id=&#34;嵌套的包目录和导入路径&#34;&gt;嵌套的包目录和导入路径&lt;/h1&gt;
&lt;p&gt;可以将类似的包组嵌套在go工作区的一个目录中，然后该目录将成为它包含的所有包的导入路径的一部分。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/4-%e4%bb%a3%e7%a0%81%e9%9b%86-%e5%8c%85/%e5%b5%8c%e5%a5%97%e5%8c%85%e7%9b%ae%e5%bd%95%e4%b8%8e%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用go-install安装程序可执行文件&#34;&gt;使用&amp;quot;go install&amp;quot;安装程序可执行文件&lt;/h1&gt;
&lt;p&gt;与go build 不同，go install 以包含代码的目录来命名可执行文件。将存储在工作区中名为 bin 的目录中。&lt;/p&gt;
&lt;h1 id=&#34;设置gopath&#34;&gt;设置GOPATH&lt;/h1&gt;
&lt;p&gt;GOPATH 是一个环境变量，go工具会参考它来查找工作区位置。大多数开发者将所有代码都保存在一个工作区中，但也可以使用 GOPATH 将工作区转移到其他目录。&lt;/p&gt;
&lt;p&gt;若代码存储在默认目录之外的地方，需要设置GOPATH: &lt;code&gt;export GOPATH=&amp;quot;/xxxx/xxx&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;发布包&#34;&gt;发布包&lt;/h1&gt;
&lt;p&gt;可以在git等仓库中保存代码，这样其他开发人员就可以在自己的项目中使用它。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;github.com/abc/defg&amp;#34;
       &amp;#34;log&amp;#34;
)

func main() {
       fmt.Print(&amp;#34;xxxxxx&amp;#34;)
       grade, err := defg.GetFloat()
       if err != nil {
              log.Fatal(err)
       }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用go-get下载和安装包&#34;&gt;使用&amp;quot;go get&amp;quot;下载和安装包&lt;/h1&gt;
&lt;p&gt;使用包所在的URL作为导入路径，可以使用&lt;code&gt;go get&lt;/code&gt;自动下载和安装包：&lt;code&gt;go get github.com/abc/defg&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;go将连接到github，下载存储库并将其保存在go工作区的src目录中。&lt;/p&gt;
&lt;h1 id=&#34;使用go-doc阅读包文档&#34;&gt;使用&amp;quot;go doc&amp;quot;阅读包文档&lt;/h1&gt;
&lt;p&gt;可以使用 &lt;code&gt;go doc&lt;/code&gt; 命令来显示关于任何包或函数的文档。&lt;br&gt;
例如: &lt;code&gt;go doc strconv&lt;/code&gt;   &lt;code&gt;go doc strconv ParsetFloat&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用doc注释记录包&#34;&gt;使用doc注释记录包&lt;/h1&gt;
&lt;p&gt;若希望用户看到有关包或函数的文档，需要自己添加。&lt;/p&gt;
&lt;p&gt;只需在代码中添加文档注释，直接出现在package子句或函数声明之前的普通go注释将被视为文档注释，将显示在go doc 的输出中。&lt;/p&gt;
&lt;p&gt;添加文档注释时，需要遵循一些惯例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注释应该是完整的句子；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包注释应以 &lt;code&gt;Package&lt;/code&gt; 开头，后跟包名；
&lt;code&gt;Package mypackage enable widget management&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数注释应以其描述的函数的名称开头；
&lt;code&gt;MyFunction converts widget to gizmos&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以通过缩进在注释中包含代码示例；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了代码示例的缩进，不要为了强调或格式化添加额外的标点符号。文档注释将显示为纯文本，并以这种方式进行格式化；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;在web浏览器中查看文档&#34;&gt;在web浏览器中查看文档&lt;/h1&gt;
&lt;p&gt;可以在搜索引擎中搜索。&lt;/p&gt;
&lt;h1 id=&#34;使用godoc提供html文档&#34;&gt;使用&amp;quot;godoc&amp;quot;提供HTML文档&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;godoc&lt;/code&gt; 工具根据主要的go安装和工作区中的代码生成HTML文档。&lt;/p&gt;
&lt;p&gt;可以在web服务器模式运行 godoc ：&lt;code&gt;godoc -http=:8880&lt;/code&gt; ，然后可以在浏览器中访问：&lt;code&gt;http://localhost:8880/pkg&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;godoc服务器包含你的包&#34;&gt;&amp;ldquo;godoc&amp;quot;服务器包含你的包&lt;/h1&gt;
&lt;p&gt;除了来自go标准库的包之外，godoc 还为go工作区中的任何包构建HTML文档，这些包有可能是第三方的包，也可能是自己写的包。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>