<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.111.3"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>8.结构体：struct&nbsp;&ndash;&nbsp;承离的觉前</title><link rel="stylesheet" href="/css/core.min.003a667cf21024ef30f2985fb57c9bd6f6873cf899ee14e9302e68e9f04b681df9440cec4ebdaa101dca533a262c242f.css" integrity="sha384-ADpmfPIQJO8w8phftXyb1vaHPPiZ7hTpMC5o6fBLaB35RAzsTr2qEB3KUzomLCQv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="8.结构体：struct" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VHXKH6D389"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VHXKH6D389');
</script>

<body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/img/logo.png" alt /><span class="site name">承离的觉前</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a><a class="nav item" href="https://github%2ecom/cldjq"target="_blank" rel="noopener noreferrer">GitHub</a></nav></div></span></div><div class="site slogan"><span class="title">地振高岗 一派溪山千古秀 门朝大海 三合河水万年流</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">8.结构体：struct</h1><p class="article date">Saturday, July 29, 2023</p></section><article class="article markdown-body"><blockquote>
<p>有时需要保存超过一种类型的数据。</p>
</blockquote>
<p>切片可以保存一组数据，映射能保存一组键和一组值，这两种数据结构都只能保存一种类型。有时需要一组不同类型的数据，例如邮件地址，其中包含了街道名、邮编等，无法使用切片或者映射来保存，但是可以使用 <code>struct</code> 类型来保存。</p>
<h1 id="struct是由多种类型的值构成">struct是由多种类型的值构成</h1>
<p>使用struct关键字来声明一个 struct 类型，后面跟花括号，在括号中，可以定义一个或多个字段：struct 组合的值。每一个字段定义在一个单独的行，由字段名称、后面跟着的字段需要保存的值类型组成。<br>
<img  src="/img/Golang/8-struct/struct%e8%af%ad%e6%b3%95.png"
        alt/></p>
<p>可以使用一个struct类型来最为定义的变量的类型，例：</p>
<pre tabindex="0"><code>var myStruct struct {
       number float64
       word   string
       toggle bool
}
fmt.Printf(&#34;%#v\n&#34;, myStruct)
</code></pre><p>输出：</p>
<pre tabindex="0"><code>struct { number float64; word string; toggle bool }
{number:0, word:&#34;&#34;, toggle:false}   //struct中每个字段都被设置成其类型的零值
</code></pre><p>当调用Printf中的 %#v 时，将myStruct中的值作为struct字面量打印。</p>
<p>写struct字段时，仅仅在字段名称和类型之间插入一个空格即可，go fmt 会自动格式化。</p>
<h1 id="使用点运算符访问struct字段">使用点运算符访问struct字段</h1>
<p>我们使用点运算符来表示函数属于另一个包，或方法属于一个值。</p>
<p>与此类似，可以使用点运算符来标识属于struct的字段，这也可以用于它们的赋值和检索。</p>
<pre tabindex="0"><code>var myStruct struct {
        number float64
        word   string
        toggle bool
}
myStruct.number = 3.14
myStruct.word = &#34;pie&#34;
myStruct.toggle = &#34;true&#34;   //给struct字段赋值
fmt.Println(myStruct.number)  
fmt.Println(myStruct.word)
fmt.Println(myStruct.toggle)  //从struct字段取值
</code></pre><h1 id="在struct中保存订阅者的数据">在struct中保存订阅者的数据</h1>
<p>我们知道了如何声明一个保存了struct的变量和如何给字段赋值，可以创建一个来保存杂志订阅者的数据。</p>
<pre tabindex="0"><code>var subscriber struct {
        name   string
        rate   float64
        active bool
}
subscriber.name = &#34;Aman Singh&#34;
subscriber.rate = 4.99
subscriber.active = true
fmt.Println(&#34;Name:&#34;, subscriber.name)
fmt.Println(&#34;Monthly rate:&#34;, subscriber.rate)
fmt.Println(&#34;Active?&#34;, subscriber.active)
</code></pre><p>尽管订阅者的数据使用了多种方式存储，struct让我们把这些都集中在一个方便的包里。</p>
<h1 id="定义类型和struct">定义类型和struct</h1>
<p>定义struct变量很麻烦，定义每一个变量时需要重复整个struct类型声明。</p>
<pre tabindex="0"><code>var subscriber1 struct {
        name   string
        rate   float64
        active bool
}      //为subscriber1变量定义struct类型
subscriber1.name = &#34;Aman Singh&#34;
fmt.Println(&#34;Name:&#34;, subscriber1.name)
var subscriber2 struct {
        name   string
        rate   float64
        active bool
}     //为subscriber2变量定义struct类型
subscriber2.name = &#34;Beth Ryan&#34;
fmt.Println(&#34;Name:&#34;, subscriber2.name)
</code></pre><p>我们已经使用了多种类型，像int、string、bool、切片、映射和struct，但是无法创建全新类型。</p>
<p>类型定义允许自己创建新的类型，可以基于基础类型来创建新的定义类型。</p>
<p>定义一个类型，需要使用<code>type</code>关键字，后跟新类型的名字，然后是希望基于的基础类型，若使用struct类型作为基础类型，需要使用struct关键字，后跟以花括号包裹的一组字段定义，就像声明struct变量时一样。</p>
<p><img  src="/img/Golang/8-struct/type%e7%b1%bb%e5%9e%8b.png"
        alt/></p>
<p>与变量一样，类型定义可以被放在一个函数中，但把它的作用域限定在该函数块中，意味着不能在函数外面使用，所以类型经常定义在函数外的包级别。</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

type part struct {    //定义一个名为part的类型，part基础类型有下面这俩字段的结构体
	description string
	count       int
}   

type car struct {    //定义一个名为car的类型，car的基础类型是有下面这些字段的struct
	name     string
	topSpeed float64
}

func main() {
	var porsche car    //定义一个car类型的变量
	porsche.name = &#34;Porsche 911 R&#34;   //访问struct的字段
	porsche.topSpeed = 323
	fmt.Println(&#34;Name:&#34;, porsche.name)
	fmt.Println(&#34;Top speed:&#34;, porsche.topSpeed)

	var bolts part
	bolts.description = &#34;Hex bolts&#34;
	bolts.count = 24
	fmt.Println(&#34;Description:&#34;, bolts.description)
	fmt.Println(&#34;Count:&#34;, bolts.count)
}
</code></pre><p>当这些变量被声明后，可以设置这些字段的值和取回这些值。</p>
<h1 id="定义一个类型">定义一个类型</h1>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

type subscriber struct {
        name    string
        rate    float64
        active  bool
}

func main() {
        var sub subscriber   //定义一个subscriber类型的变量
        sub.name = &#34;Aman Singh&#34;
        fmt.Println(&#34;Name:&#34;, sub.name)
        var sub2 subscriber  //使用subscriber类型定义第二个变量
        sub2.name = &#34;Beth Ryan&#34;
        fmt.Println(&#34;Name:&#34;, sub2.name)
        
}
</code></pre><h1 id="与函数一起使用已定义类型">与函数一起使用已定义类型</h1>
<p>已定义类型可以用于变量类型以外的地方，也可以用于函数参数和返回值。</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

type part struct {
	description string
	count       int
}

func showInfo(p part) { //声明一个以part作为类型的参数
	fmt.Println(&#34;Description:&#34;, p.description)
	fmt.Println(&#34;Count:&#34;, p.count)
}

func main() {
	var bolts part
	bolts.description = &#34;Hex bolts&#34;
	bolts.count = 24
	showInfo(bolts) //将part传递给函数
}
</code></pre><p>函数接受一个单独的参数，使用part作为参数的类型，在showInfo内部，可以像其他struct变量一样通过参数变量访问字段。</p>
<p>还有一个minimumOrder函数来根据特定的描述创建part和预赋值其中的count字段，将minimumOrder的返回值类型定义为part，这样就能返回一个新的struct：</p>
<pre tabindex="0"><code>func minimumOrder(description string) part {  //声明一个part类型的返回值
        var p part    //创建一个part值
        p.description = description
        p.count = 100
        return p   //返回part
}

func main() {
        p := minimumOrder(&#34;Hex bolts&#34;)     //调用minimumOrder，使用一个变量的短声明来保存返回的part
        fmt.Println(p.description, p.count)
}
</code></pre><p>下面例子，printInfo函数接受subscriber作为参数，并输出它的字段值，defaultSubscriber函数来建立一个新的subscriber struct并赋一些初始的值，它们接受一个名为name的字符串参数并用它来设置新的subscriber的name字段，然后把rate和active字段设置为默认值，最后将整个subscriber struce返回给调用者。</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func printInfo(s subscriber) { //声明一个参数，使用subscriber类型
	fmt.Println(&#34;Name:&#34;, s.name)
	fmt.Println(&#34;Monthly rate:&#34;, s.rate)
	fmt.Println(&#34;Active:&#34;, s.active)
}

func defaultSubscriber(name string) subscriber { //返回一个subscriber值
	var s subscriber //创建一个新的subscriber
	s.name = name
	s.rate = 5.99
	s.active = true //设置struct字段
	return s        //返回subscriber
}

func main() {
	subscriber1 := defaultSubscriber(&#34;Aman Singh&#34;) //使用名字来建立一个subscriber
	subscriber1.rate = 4.99                        //使用一个特定的费率
	printInfo(subscriber1)                         //打印字段值
	subscriber2 := defaultSubscriber(&#34;Beth Ryan&#34;)  //使用名字来建立一个subscriber
	printInfo(subscriber2)                         //打印字段值
}
</code></pre><p>输出：</p>
<pre tabindex="0"><code>Name: Aman Singh
Monthly rate: 4.99
Active: true
Name: Beth Ryan
Monthly rate: 5.99
Active: true
</code></pre><p>在主函数中，可以将subscriber的名称传递给defaultSubscriber来创建一个新的subscriber struct，一个subscriber获取一个打折的费率，所以直接重设struct的字段，传递给一个已经填充完全的subscriber struct给printInfo函数来打印它的内容。</p>
<p>不要使用一个已经存在的类型名称作为变量的名称！</p>
<h1 id="使用函数修改struct">使用函数修改struct</h1>
<p>go 是一个按值传递的语言，函数调用时接收的是一个参数的拷贝，若函数修改了参数值，其修改的只是拷贝，而不是原始值。</p>
<p>对于 struct 也是一样。</p>
<p>函数能够接收指针来代替直接接收值，当调用这个函数时，使用取址运算符<code>&amp;</code>来传送需要更新的值的指针，然后在函数内部，使用<code>*</code>来更新指针指向的值。</p>
<pre tabindex="0"><code>func main() {
        amount := 6
        double(&amp;amount)   //传递一个指针来取代变量的值
        fmt.Println(amount)
}
func double(number *int) {  //接受一个指针来代替int值
        *number *= 2  //使用指针更新值
}
</code></pre><p>输出：</p>
<pre tabindex="0"><code>12
</code></pre><p>使用指针来让函数也能更新struct：更新 s 参数类型来接受一个 subscriber struct 的指针，而不是直接使用struct，然后更新 struct 中的rate字段，在main中，调用applyDiscount并传入 subscriber struct 的指针，在输出rate字段时，能看到被更新成功。</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func applyDiscount(s *subscriber) { //获取struct的指针，而不是struct
	s.rate = 4.99 //更新struct字段
}

func main() {
	var s subscriber
	applyDiscount(&amp;s) //传入一个指针，而不是struct
	fmt.Println(s.rate)
}
</code></pre><p>在double函数中，需要使用 * 运算符来获取指针指向的值，当在applyDiscount函数中设置rate字段时不需要 * 吗？<br>
使用点运算符在struct指针和struct上都可以访问字段。</p>
<h1 id="通过指针访问struct的字段">通过指针访问struct的字段</h1>
</article><section class="article labels"><a class="category" href=/categories/golang/>Golang</a><a class="tag" href=/tags/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7/>打怪升级</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/7.%E6%95%B0%E6%8D%AE%E6%A0%87%E7%AD%BE%E6%98%A0%E5%B0%84/"><span class="iconfont icon-article"></span>7.数据标签：映射</a></p></section><section class="article discussion"><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "cldjq" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">承离的觉前</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://tinklespring.com" 
        target="_blank" rel="noopener noreferrer">TinkleSpring</a><span>&nbsp;&amp;&nbsp;</span><a href="https://tinklespring.com" 
        target="_blank" rel="noopener noreferrer">TinkleSpring</a>
<a href='https://ipv6-test.com/validate.php?url=referer'
  ><img src='https://ipv6-test.com/button-ipv6-80x15.png' 
        alt='ipv6 ready' title='ipv6 ready' border='0' 
/></a>
</p></div>
</section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-VHXKH6D389', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</body>

</html>