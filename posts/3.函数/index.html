<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.111.3"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>3.函数&nbsp;&ndash;&nbsp;承离的觉前</title><link rel="stylesheet" href="/css/core.min.003a667cf21024ef30f2985fb57c9bd6f6873cf899ee14e9302e68e9f04b681df9440cec4ebdaa101dca533a262c242f.css" integrity="sha384-ADpmfPIQJO8w8phftXyb1vaHPPiZ7hTpMC5o6fBLaB35RAzsTr2qEB3KUzomLCQv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="3.函数" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VHXKH6D389"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VHXKH6D389');
</script>

<body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/img/logo.png" alt /><span class="site name">承离的觉前</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a><a class="nav item" href="https://github%2ecom/cldjq"target="_blank" rel="noopener noreferrer">GitHub</a></nav></div></span></div><div class="site slogan"><span class="title">地振高岗 一派溪山千古秀 门朝大海 三合河水万年流</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">3.函数</h1><p class="article date">Thursday, June 29, 2023</p></section><article class="article markdown-body"><h1 id="printf-与-sprintf-格式化输出">Printf 与 Sprintf 格式化输出</h1>
<p>Printf 代表“带格式的打印”，接受一个字符串并将一个或多个值插入其中，以特定的方式进行格式化，然后打印结果字符串。<br>
Sprintf函数（也是fmt包的一部分）的工作方式与Printf 类似，不过返回格式化的字符串而不是打印。</p>
<pre tabindex="0"><code>fmt.Printf(&#34;About one-third: %0.2f\n&#34;, 1.0/3.0)
</code></pre><pre tabindex="0"><code>resultString := fmt.Sprintf(&#34;About one-third: %0.2f\n&#34;, 1.0/3.0)
fmt.Printf(resultString)
</code></pre><p>Printf的两个特性：</p>
<ul>
<li>格式化动词（字符串中的%0.2f是动词）</li>
<li>值的宽度（动词中间的0.2）</li>
</ul>
<h1 id="格式化动词">格式化动词</h1>
<p>Printf第一个参数是一个字符串，用于格式化输出，大部分格式与字符串中显示的格式完全相同，但是任何 <code>%</code> 都将被视为格式化动词的开始，字符串的一部分将被特定格式的值所替换，其余参数用作这些动词的值。</p>
<p><code>%</code> 后面的字母表示要使用哪个动词，常见动词：</p>
<table>
<thead>
<tr>
<th style="text-align:center">动词</th>
<th style="text-align:center">输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%f</td>
<td style="text-align:center">浮点数</td>
</tr>
<tr>
<td style="text-align:center">%d</td>
<td style="text-align:center">十进制整数</td>
</tr>
<tr>
<td style="text-align:center">%s</td>
<td style="text-align:center">字符串</td>
</tr>
<tr>
<td style="text-align:center">%t</td>
<td style="text-align:center">布尔值（true或false）</td>
</tr>
<tr>
<td style="text-align:center">%v</td>
<td style="text-align:center">任何值（根据所提供的值的类型选择适当的格式）</td>
</tr>
<tr>
<td style="text-align:center">%#v</td>
<td style="text-align:center">任何值，按其在go程序代码中显示的格式进行格式化</td>
</tr>
<tr>
<td style="text-align:center">%T</td>
<td style="text-align:center">所提供值的类型（int、string）</td>
</tr>
<tr>
<td style="text-align:center">%%</td>
<td style="text-align:center">一个完全的百分号</td>
</tr>
</tbody>
</table>
<p>示例：</p>
<pre tabindex="0"><code>fmt.Printf(&#34;A float: %f\n&#34;, 3.1415)
fmt.Printf(&#34;An integer: %d\n&#34;, 15)
fmt.Printf(&#34;A string: %s\n&#34;, &#34;hello&#34;)
fmt.Printf(&#34;A boolean: %t\n&#34;, false)
fmt.Printf(&#34;Values: %v %v %v\n&#34;, 1.2, &#34;\t&#34;, true)
fmt.Printf(&#34;Values: %#v %#v %#v\n&#34;, 1.2, &#34;\t&#34;, true)
fmt.Printf(&#34;Types: %T %T %T\n&#34;, 1.2, &#34;\t&#34;, true)
fmt.Printf(&#34;Percent sign: %%\n&#34;)
</code></pre><p>输出：</p>
<pre tabindex="0"><code>A float: 3.141500
An integer: 15
A string: hello
A boolean: false
Values: 1.2       true
Values: 1.2  &#34;\t&#34; true
Types: float64 string bool
Percent sign: %
</code></pre><p>确保使用 \n 转义序列在每个格式化字符串的末尾添加一个换行符，因为与Println不同，Printf不会自动添加新行。</p>
<pre tabindex="0"><code>fmt.Printf(&#34;%v %v %v&#34;, &#34;&#34;, &#34;\t&#34;, &#34;\n&#34;)
fmt.Printf(&#34;%#v %#v %#v&#34;, &#34;&#34;, &#34;\t&#34;, &#34;\n&#34;)
</code></pre><p>输出：</p>
<pre tabindex="0"><code>
&#34;&#34; &#34;\t&#34; &#34;\n&#34;
</code></pre><p>%#v 可以显示一些值，不实用%#v，这些值可能会在输出中隐藏，上述 空字符串、制表符、换行符，在 %v 打印时是不可见的。</p>
<h1 id="格式化宽度">格式化宽度</h1>
<p>可以在格式化动词的百分号后面指定最小宽度，若该动词参数比最小宽度短，则使用空格填充。</p>
<pre tabindex="0"><code>fmt.Printf(&#34;%12s | %s\n&#34;, &#34;Product&#34;, &#34;Cost in Cents&#34;)
fmt.Printf(&#34;%12s | %s\n&#34;, &#34;Stamps&#34;, 50)
fmt.Printf(&#34;%12s | %s\n&#34;, &#34;Paper Clips&#34;, 5)
fmt.Printf(&#34;%12s | %s\n&#34;, &#34;Tape&#34;, 99)
</code></pre><p>输出：</p>
<pre tabindex="0"><code>     Product | Cost in Cents
      Stamps | 50
 Paper Clips |  5
        Tape | 99
</code></pre><h1 id="格式化小数宽度">格式化小数宽度</h1>
<p>整个数的最小宽度包括数字位和小数点，若包括，较短的数将在开始处填充空格，直到达到这个宽度，若省略，则不会添加任何空格。<br>
小数点后的宽度是要显示的小数位数，若是更精确的数字，将被四舍五入。</p>
<pre tabindex="0"><code>fmt.Printf(&#34;%%7.3f: %7.3f\n&#34;, 12.3456)
fmt.Printf(&#34;%%7.2f: %7.2f\n&#34;, 12.3456)
fmt.Printf(&#34;%%7.1f: %7.1f\n&#34;, 12.3456)
fmt.Printf(&#34;%%.1f: %.1f\n&#34;, 12.3456)
fmt.Printf(&#34;%%.2f: %.2f\n&#34;, 12.3456)
</code></pre><p>输出：</p>
<pre tabindex="0"><code>%7.3f:   12.346
%7.2f:    12.35
%7.1f:     12.3
%.1f:  12.3
%.2f:  12.35
</code></pre><p><code>%.2f</code> 将允许取任意精度的浮点数，并将它们四舍五入到小数点后两位。（不会做任何不必要的填充）。</p>
<h1 id="声明函数">声明函数</h1>
<p>声明以func关键字开头，后面跟希望函数具有的名称、一对圆括号()，然后是包含函数代码的块。<br>
一旦声明了一个函数，就可以在包的其他地方调用，只需输入函数名，后面跟一对圆括号。当执行此操作时，函数快中的代码就会运行。</p>
<p>示例：</p>
<pre tabindex="0"><code>package main
import &#34;fmt&#34;
func sayHi() {
       fmt.Println(&#34;Hi!&#34;)
}
func main() {
       sayHi()
}
</code></pre><p>当调用当前包中定义的函数时，不应该指定包名，（输入 main.sayHi() 将导致编译错误）。</p>
<p>函数名的规则与变量名的规则相同：</p>
<ul>
<li>名称必须以 <code>字母开头</code> ，后跟任何数量的数字和字母；</li>
<li>名称以 <code>大写字母</code> 开头的函数是可导出的，且可以在当前包之外使用；</li>
<li>名称以 <code>小写字母</code> 开头的函数是不可导出的，只能在当前包中使用；</li>
<li>名称包含多个单词应符合驼峰式大小写；</li>
</ul>
<h1 id="声明函数参数">声明函数参数</h1>
<p>若希望对函数的调用包含参数，则需声明一个或多个参数，<code>参数是函数的局部变量，其值是在调用函数时设置的。</code></p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

func main() {
	repeatLine(&#34;hello&#34;, 3)
}
func repeatLine(line string, times int) {
	for i := 0; i &lt; times; i++ {
		fmt.Println(line)
	}
}
</code></pre><p>在函数声明中的圆括号中声明一个或多个参数，用逗号分隔，与变量一样，需要为声明的每个参数提供一个名称，后面跟一个类型（float64、bool等）。</p>
<p>若函数定义了参数，那么在调用时需要传递一组匹配的参数。当函数运行时，每个参数都将被设置为对应参数中的值的副本，然后这些参数值在函数块的代码中被使用。</p>
<h1 id="使用函数">使用函数</h1>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

func paintNeeded(width float64, height float64) {
	area := width * height
	fmt.Printf(&#34;%.2f liters needed\n&#34;, area/10.0)
}
func main() {
	paintNeeded(4.2, 3.0)
	paintNeeded(5.2, 3.5)
	paintNeeded(5.0, 3.3)
}
</code></pre><h1 id="函数和变量的作用域">函数和变量的作用域</h1>
<p>上述在paintNeeded函数块中声明了一个area变量，与条件块和循环块一样，函数块中声明的变量只在该函数块的作用域内。</p>
<p>与条件块和循环块一样，在函数外部声明的变量将在该函数块的作用域内，这意味着可以在包级别上声明一个变量，并且可以在包中的任何函数内访问。</p>
<h1 id="函数返回值">函数返回值</h1>
<p>函数总是返回特定类型的值（只返回该类型），若要声明函数返回值，在函数声明中的参数后面添加该返回值类型，在函数块中使用 <code>return</code> 关键字，后面跟要返回的值。函数的调用者可以将返回值分配给一个变量，直接将它传递给另一个函数，或用它做任何其他需要做的事。</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

func double(number float64) float64 {
	return number * 2
}
func main() {
	dozen := double(6.0)
	fmt.Println(dozen)
	fmt.Println(double(4.2))
}
</code></pre><p>当 return 语句运行时，函数立即退出，不运行它后面的任何代码，可以将其与if语句一起使用，在没有必要运行剩余代码的情况下（由于一些错误或其他情况）退出函数。</p>
<pre tabindex="0"><code>func status(grade float64) string {
	if grade &lt; 60.0 {
            return &#34;failing&#34;
	}
        return &#34;passing&#34;
}
func main() {
        fmt.Println(status(60.1))
        fmt.Println(status(59))
}
</code></pre><p>若包含一个不属于 if 块的 return 语句，有可能使代码在任何情况都不会运行，go要求声明了返回类型的任何函数都必须以 return 语句结束，以任何其他语句结束都将导致编译错误。</p>
<p>若返回值类型与声明的返回类型不匹配，也将编译错误。</p>
<h1 id="使用返回值">使用返回值</h1>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

func paintNeeded(width float64, height float64) float64 {
	area := width * height
	return area / 10.0
}
func main() {
	var amount, total float64
	amount = paintNeeded(4.2, 3.0)
	fmt.Printf(&#34;%0.2f liters needed\n&#34;, amount)
	total += amount
	amount = paintNeeded(5.2, 3.5)
	fmt.Printf(&#34;%0.2f liters needed\n&#34;, amount)
	total += amount
	fmt.Printf(&#34;Total: %0.2f liters\n&#34;, total)
}
</code></pre><p>返回值允许main函数决定所计算的数量做什么，而不是依赖paintNeeded函数打印它。</p>
<p>对下述代码进行更改，会怎么样？</p>
<pre tabindex="0"><code>func paintNeeded(width float64, height float64) float64 {
        area := width * height
        return area / 10.0
}
</code></pre><table>
<thead>
<tr>
<th style="text-align:center">如果这样</th>
<th style="text-align:center">会失败，因为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><pre>func paintNeeded(width float64, height float64) float64 {<br>        area := width * height<br>}<br>删除return 语句<pre></td>
<td style="text-align:center">如果函数声明了返回类型，go要求包含一个return语句</td>
</tr>
<tr>
<td style="text-align:center"><pre>func paintNeeded(width float64, height float64) float64 {<br>        area := width * height<br>        return area / 10.0<br>        fmt.Println(area / 10.0)<br>}<br>在return语句后加一行<pre></td>
<td style="text-align:center">如果函数声明了返回类型，go要求最后一个语句是return语句</td>
</tr>
<tr>
<td style="text-align:center"><pre>func paintNeeded(width float64, height float64) {<br>        area := width * height<br>        return area / 10.0<br>}<br>删除返回类型声明<pre></td>
<td style="text-align:center">go不允许返回未声明的值</td>
</tr>
<tr>
<td style="text-align:center"><pre>func paintNeeded(width float64, height float64) float64 {<br>        area := width * height<br>        return int(area / 10.0)<br>}<br>更改要返回值的类型<pre></td>
<td style="text-align:center">go要求返回值的类型与声明的类型匹配</td>
</tr>
</tbody>
</table>
<h1 id="错误值">错误值</h1>
<p>一个错误值是一个可以返回字符串的名为 Error 的方法返回的任何值。创建错误值的最简单方法是将字符串传递给 errors 包的 New 函数，该函数将返回一个新的错误值。若对该错误值调用 Error 方法，将会得到传递给 errors.New 的字符串。</p>
<pre tabindex="0"><code>package main

import (
      &#34;errors&#34;
      &#34;fmt&#34;
)

func main() {
      err := errors.New(&#34;height can&#39;t be negative&#34;)
      fmt.Println(err.Error())
}
</code></pre><p>若将错误值传递给fmt或log包中的函数，则可能不需要调用它的Error方法。fmt和log中的函数已经被编写成能够检查是否传递给它们的值有Error方法，若有，则打印Error的返回值。</p>
<pre tabindex="0"><code>err := errors.New(&#34;height can&#39;t be negative&#34;)
fmt.Println(err)
log.Fatal(err)
</code></pre><p>若需要格式化数字或其他值以便在错误信息中使用，可以使用 fmt.Error 函数，就像 fmt.Printf 或 fmt.Sprintf 一样，将值插入格式字符串中，但是不会打印或返回一个字符串，而是返回一个错误值。</p>
<pre tabindex="0"><code>err := fmt.Error(&#34;a height of %0.2f is invalid&#34;, -2.33333)
fmt.Println(err.Error())
fmt.Println(err)
</code></pre><h1 id="声明多个返回值">声明多个返回值</h1>
<p>要声明函数的多个返回值，需将返回值类型放在函数声明的第二组圆括号内（在函数参数的圆括号之后），用都好分隔。（当只有一个返回值时，返回值周围的圆括号是可选的，但是若有多个返回值，则必须使用圆括号。）当调用该函数时，需要考虑额外的返回值，通常通过将它们分配给额外的变量来实现。</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

func manyReturns() (int, bool, string) {
	return 1, true, &#34;hello&#34;
}
func main() {
	myInt, myBool, myString := manyReturns()
	fmt.Println(myInt, myBool, myString)
}
</code></pre><p>若要使返回值目的更清楚，可以将每个返回值提供名称，类似于参数名称，命名返回值的主要用途是作为程序员阅读代码的文档。</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;math&#34;
)

func floatParts(number float64) (integerPart int, fractionalPart float64) {
	wholeNumber := math.Floor(number)
	return int(wholeNumber), number - wholeNumber
}
func main() {
	cans, remainder := floatParts(1.26)
	fmt.Println(cans, remainder)
}
</code></pre><h1 id="在paintneeded函数中使用多个返回值">在paintNeeded函数中使用多个返回值</h1>
<p>如上所见，可以返回任何类型的多个返回值，但是对于多个返回值，常见的做法是返回一个主返回值，后跟一个额外值，表示函数是否遇到错误，若无问题，通常将额外值设置为nil，若发生错误，则设置为错误值。</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

func paintNeeded(width float64, height float64) (float64, error) {
	if width &lt; 0 {
		return 0, fmt.Errorf(&#34;a width of %0.2f is invalid&#34;, width)
	}
	if height &lt; 0 {
		return 0, fmt.Errorf(&#34;a height of %0.2f is invalid&#34;, height)
	}
	area := width * height
	return area / 10.0, nil
}
func main() {
	amount, err := paintNeeded(4.2, -3.0)
	fmt.Println(err)
	fmt.Printf(&#34;%0.2f liters needed\n&#34;, amount)
}
</code></pre><p>在 main 函数中，添加第二个变量记录 paintNeeded 中的错误值，若将一个无效的参数传递给paintNeeded，将得到一个错误返回值，并打印该错误。</p>
<h1 id="始终处理错误">始终处理错误</h1>
<p>当将一个无效的参数传递给paintNeeded时，得到一个错误返回值，并将其打印出，但也打印了一个无效信息。</p>
<p>当函数返回一个错误值时，通常也必须返回一个主返回值，但伴随错误值的任何其他返回值都应被认为不可靠，被忽略。当调用返回错误值的函数时，在继续运行前测试该值是否为 nil 是重要的，若不是 nil ，则意味着有一个错误必须进行处理。</p>
<p>如何处理错误取决于具体情况，对与 paintNeeded 函数，也许最好是简单跳过当前计算，并继续执行程序其余部分：</p>
<pre tabindex="0"><code>func main() {
	amount, err := paintNeeded(4.2, -3.0)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf(&#34;%0.2f liters needed\n&#34;, amount)
	}
}
</code></pre><p>可以调用 Log.Fatal 来显示错误信息并退出程序。</p>
<pre tabindex="0"><code>func main() {
	amount, err := paintNeeded(4.2, -3.0)
	if err != nil {
		Log.Fatal(err)
	}
        fmt.Printf(&#34;%0.2f liters needed\n&#34;, amount)
}
</code></pre><p>如下是一个计算一个数字平方根的程序，若一个负数传递给 squareRoot 函数，将返回一个错误：</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;math&#34;
)

func squareRoot(number float64) (float64, error) {
	if number &lt; 0 {
		return 0, fmt.Errorf(&#34;can&#39;t get square root of number&#34;)
	}
	return math.Sqrt(number), nil
}
func main() {
	root, err := squareRoot(-9.3)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf(&#34;%0.3f&#34;, root)
	}
}
</code></pre><table>
<thead>
<tr>
<th style="text-align:center">若如此</th>
<th style="text-align:center">会失败，因为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><pre>return math.Sqrt(number)<del>, nil</del><br>删除要返回的参数之一<pre></td>
<td style="text-align:center">要返回的参数的数量必须始终与函数声明中的返回值的数量匹配</td>
</tr>
<tr>
<td style="text-align:center"><pre>root<del>, err</del> := squareRoot(-9.3)<br>删除返回值所赋值给的变量之一<pre></td>
<td style="text-align:center">若使用函数的任何一个返回值，go要求使用所有的返回值</td>
</tr>
<tr>
<td style="text-align:center"><pre>root, err := squareRoot(-9.3)<br><del>if err != nil {</del><br><del>       fmt.Println(err)</del><br><del>} else {</del><br>       fmt.Printf(&quot;%0.3f&quot;, root)<br><del>}</del><br>删除使用其中一个返回值的代码<pre></td>
<td style="text-align:center">go要求使用声明的每个变量，当涉及错误返回值时，实际上是一个非常有用的特性，因为有助于避免意外地忽略错误</td>
</tr>
</tbody>
</table>
<h1 id="函数形参接收实参的副本">函数形参接收实参的副本</h1>
<p>当调用一个声明了行参的函数时，需要为调用提供实参，每个实参中的值被复制到相应的行参变量。（执行此操作的编程语言有时称为“值传递”）。这在大多数情况是可以的，但如果想把一个变量的值传递给一个函数并让它以某种方式改变这个值，就会遇到麻烦。</p>
<p>函数只能更改行参中的该值的副本，而不能更改原始值，因此，在函数内部所做的任何更改在函数外部都将不可见。</p>
<p><code>Go是一种“值传递”语言；函数行参从函数调用中接收实参的副本。</code></p>
<h1 id="指针">指针</h1>
<p>需要一种方法来允许函数改变变量所保存的原始值，而不是副本。</p>
<p>可以使用 <code>&amp;</code> 符号来获取变量的地址，是go的“地址”运算符。<br>
例如：</p>
<pre tabindex="0"><code>amount := 6
fmt.Println(amount)
fmt.Println(&amp;amount)
</code></pre><p>可以获得任何类型变量的地址，每个变量的地址不同。</p>
<p>计算机为程序留出的内存是一个拥挤的地方，其充满了变量值：布尔值、整数、字符串等，如果有变量的地址，可以用其找到变量所包含的值。</p>
<p><code>表示变量地址的值称为指针</code>，它指向可以找到变量的位置。</p>
<h1 id="指针类型">指针类型</h1>
<p>指针的类型可以写为一个 <code>*</code> 符号，后面跟着指针指向的变量的类型。</p>
<p>例如，指向一个 int 变量的指针的类型写为 *int ，可以大声读作：“指向int的指针”。</p>
<p>可以使用 <code>reflect.Type()</code> 函数来显示之前程序中指针的类型：</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;
	&#34;reflect&#34;
)

func main() {
	var myInt int
	fmt.Println(reflect.TypeOf(&amp;myInt))
	var myFloat float64
	fmt.Println(reflect.TypeOf(&amp;myFloat))
	var myBool bool
	fmt.Println(reflect.TypeOf(&amp;myBool))
}
</code></pre><p>可以声明保存指针的变量，指针变量只能保存指向一种类型值的指针，因此变量可能只保存 *int 指针，只保存 *float64 指针。。。。</p>
<pre tabindex="0"><code>var myInt int
var myIntPointer *int  //声明一个指向int的指针变量
myIntPointer = &amp;myInt  //给变量分配一个指针
fmt.Println(myIntPointer)

var myFloat float64
var myFloatPointer *float64  //声明一个指向float64的指针变量
myFloatPointer = &amp;myFloat    //给变量分配一个指针
fmt.Println(myFloatPointer)
</code></pre><p>与其他类型一样，若要立即为指针变量复制，可以使用短变量声明：</p>
<pre tabindex="0"><code>var myBool bool
myBoolPointer := &amp;myBool
fmt.Println(myBoolPointer)
</code></pre><h1 id="获取和更改指针的值">获取和更改指针的值</h1>
<p>通过在代码中的指针之前输入 <code>*</code> 来获得指针饮用的变量的值。 *myIntPointer 可以读作：“myIntPointer 处的值”</p>
<pre tabindex="0"><code>myInt := 4
myIntPointer := &amp;myInt
fmt.Println(myIntPointer)
fmt.Println(*myIntPointer)

myFloat := 98.6
myFloatPointer := &amp;myFloat
fmt.Println(myIntPointer)
fmt.Println(*myIntPointer)

myBool := true
myBoolPointer := &amp;myBool
fmt.Println(myBoolPointer)
fmt.Println(*myBoolPointer)
</code></pre><p>输出：</p>
<pre tabindex="0"><code>0x1040a124
4
0x1040a140
98.6
0x1040a150
true
</code></pre><p><code>*</code> 运算符还可以更新指针处的值：</p>
<pre tabindex="0"><code>myInt := 4
fmt.Println(myInt)
myIntPointer := &amp;myInt
*myIntPointer = 8    //给指针处的变量（myInt）赋一个新值
fmt.Println(*myIntPointer)   //打印指针处变量的值
fmt.Println(myInt)     //打印变量的值
</code></pre><p>输出：</p>
<pre tabindex="0"><code>4    //myInt初始值
8    //*myIntPointer的更新结果
8    //myInt的更新值（与*myIntPointer）相同
</code></pre><h1 id="函数指针">函数指针</h1>
<p>可以从函数返回指针，只需声明函数的返回类型是指针类型。</p>
<pre tabindex="0"><code>func createPointer() *float64 {    //声明函数返回一个float64指针
        var myFloat = 98.5
        return &amp;myFloat    //返回指定类型的指针
}

func main() {
        var myFloatPointer *float64 = createPointer()   //将返回的指针赋给一个变量
        fmt.Println(*myFloatPointer)    //打印指针处的值
}
</code></pre><p>在go中，返回一个指向函数局部变量的指针是可以的，即使该变量不在作用域内，只要仍然拥有指针，go将确保仍然可以访问该值。</p>
<p>还可以将指针作为参数传递给函数，只需说明一个或多个参数的类型是指针。</p>
<pre tabindex="0"><code>func printPointer(myBoolPointer *bool) {    //为该参数使用一个指针类型
        fmt.Println(*myBoolPointer)         //打印传入指针处的值
}
func main() {
        var myBool bool = true
        printPointer(&amp;myBool)    //向函数传递一个指针
}
</code></pre><p>确保只使用指针作为参数，若函数声明它将使用指针，若试图将值传递给期望指针的函数，，将会编译错误。</p>
<h1 id="使用指针修复double函数">使用指针修复<code>double</code>函数</h1>
<p>有一个double函数，接受一个 int 值并将其乘以2，希望能传入一个值并使该值加倍。但 go 是一种值传递语言，意味着函数参数从调用方接收任何参数的副本，函数将值的副本加倍，原始值不变。</p>
<pre tabindex="0"><code>func main() {
        amount := 6
        double(amount)   //向函数传递实参
        fmt.Println(amount)   //打印原始值
}

func double(number int) {    //行参设置为实参的一个副本
        number *= 2     //改变副本值，不改变原始值
}
</code></pre><p>若向函数传递一个指针，然后更改该指针处的值，那么这些更改在函数外部仍然有效。</p>
<p>修改：</p>
<pre tabindex="0"><code>func main() {
        amount := 6
        double(&amp;amount)     //传递一个指针而不是一个变量值
        fmt.Println(amount)
}
func double(number *int) {   //接受一个指针而不是一个int值
        *number *= 2    //更新指针处的值
}
</code></pre><p>在double函数中，需要更新number参数的类型来获取 *int 而不是 int ，然后修改函数代码来更新number指针处的值，而不是直接更新变量，在main函数中，只需更新对double的调用来传递一个指针，而不是一个直接的值。 当运行更新后的代码时，指向amount变量的指针将被传递给double函数，double函数将获取该指针处的值并使其加倍，从而更改amount变量中的值。</p>
</article><section class="article labels"><a class="category" href=/categories/golang/>Golang</a><a class="tag" href=/tags/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7/>打怪升级</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/2.%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/"><span class="iconfont icon-article"></span>2.条件与循环</a></p></section><section class="article discussion"><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "cldjq" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">承离的觉前</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://tinklespring.com" 
        target="_blank" rel="noopener noreferrer">TinkleSpring</a><span>&nbsp;&amp;&nbsp;</span><a href="https://tinklespring.com" 
        target="_blank" rel="noopener noreferrer">TinkleSpring</a>
<a href='https://ipv6-test.com/validate.php?url=referer'
  ><img src='https://ipv6-test.com/button-ipv6-80x15.png' 
        alt='ipv6 ready' title='ipv6 ready' border='0' 
/></a>
</p></div>
</section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-VHXKH6D389', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</body>

</html>