<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.111.3"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>1-1.golang25个保留关键字&nbsp;&ndash;&nbsp;承离的觉前</title><link rel="stylesheet" href="/css/core.min.003a667cf21024ef30f2985fb57c9bd6f6873cf899ee14e9302e68e9f04b681df9440cec4ebdaa101dca533a262c242f.css" integrity="sha384-ADpmfPIQJO8w8phftXyb1vaHPPiZ7hTpMC5o6fBLaB35RAzsTr2qEB3KUzomLCQv"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="1-1.golang25个保留关键字" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-VHXKH6D389"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-VHXKH6D389');
</script>

<body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/img/logo.png" alt /><span class="site name">承离的觉前</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about">About</a><a class="nav item" href="https://github%2ecom/cldjq"target="_blank" rel="noopener noreferrer">GitHub</a></nav></div></span></div><div class="site slogan"><span class="title">地振高岗 一派溪山千古秀 门朝大海 三合河水万年流</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">1-1.golang25个保留关键字</h1><p class="article date">Wednesday, May 31, 2023</p></section><article class="article markdown-body"><blockquote>
<p>golang 有25个保留关键字，比26个英文字母还少一个～</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">break</td>
<td style="text-align:center">default</td>
<td style="text-align:center">func</td>
<td style="text-align:center">interface</td>
<td style="text-align:center">select</td>
</tr>
<tr>
<td style="text-align:center">case</td>
<td style="text-align:center">defer</td>
<td style="text-align:center">go</td>
<td style="text-align:center">map</td>
<td style="text-align:center">struct</td>
</tr>
<tr>
<td style="text-align:center">chan</td>
<td style="text-align:center">else</td>
<td style="text-align:center">goto</td>
<td style="text-align:center">package</td>
<td style="text-align:center">switch</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">fallthrough</td>
<td style="text-align:center">if</td>
<td style="text-align:center">range</td>
<td style="text-align:center">type</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">for</td>
<td style="text-align:center">import</td>
<td style="text-align:center">return</td>
<td style="text-align:center">var</td>
</tr>
</tbody>
</table>
<p>Go 25个关键字不能用作标识符，分为3类：</p>
<pre tabindex="0"><code>包管理：
import  package

程序实体声明与定义：
chan const func interface map struct type var

程序流程控制：
break  case         continue  default  defer
else   fallthrough  for       go       goto
if     range        return    select   switch
</code></pre><h1 id="包管理">包管理</h1>
<p><font color=#0099ff size=2 face="黑体">import</font><br>
用于导入包，这样就可以使用包中被导出的标识符。</p>
<pre tabindex="0"><code>import (
    _ &#34;package path&#34;
    . &#34;package path&#34;
    alias &#34;package path&#34;
)
</code></pre><p>包路径前面有三种修饰符：<br>
<code>_</code> 下划线即空白标识符，表示不使用包中的标识符，计算包级变量的初始化表达式和执行导入包的init初始化函数。<br>
<code>.</code> 点号代替包的别名，表示访问包中的导出标识符无需使用包名。<br>
<code>alias</code> 表示包的别名。</p>
<p><font color=#0099ff size=2 face="黑体">package</font> <br>
package用于声明包的名称，需要放在go文件所有代码的最前面，一个包由一个或多个go源文件组成，需放在同一个目录下，且同一个目录下的这些go文件的package的名字只能有一个。</p>
<h1 id="程序实体声明与定义">程序实体声明与定义</h1>
<p><font color=#0099ff size=2 face="黑体">chan</font><br>
<code>chan</code> 用于声明信道（channel）。<br>
信道提供一种机制使两个并发执行的函数实现同步，并通过传递具体元素类型的值来通信，未初始化的信道值为<code>nil</code>。</p>
<p>声明格式：
<code>chan T</code>   可以被用来发送和接收类型T的值。<br>
<code>chan&lt;- T</code> 只能被用来发送类型T的值。<br>
<code>&lt;-chan T</code> 只能被用来接收类型T的值。<br>
其中 <code>&lt;-</code> 操作符指定信道的方向，发送或接收，没有给定方向，则信道是双向的，信道可以通过类型转换或赋值被强制为只发送或只接收。<br>
信道的初始化可以通过 make 函数来实现，其结果值充当了对底层数据结构的引用。初始化时可以为信道设置缓冲区大小，默认值是零，表示不带缓冲的或同步的信道。</p>
<p><code>ci := make(chan int)</code>           整数类型的无缓冲信道<br>
<code>cj := make(chan int, 0)</code>        整数类型的无缓冲信道<br>
<code>cp := make(chan *os.file, 100)</code> 指向文件指针的带缓冲信道</p>
<p><font color=#0099ff size=2 face="黑体">const</font><br>
const 用于声明常量，需指明初始值，一旦创建不可修改。<br>
由于编译时的限制，定义它们的表达式必须也是可被编译器求值的常量表达式。例如 1&laquo;3 就是一个常量表达式，而 math.Sin(math.Pi/4) 则不是，因为对 math.Sin 的函数调用在运行时才会发生。</p>
<pre tabindex="0"><code>const name T = value                    // 指明类型
const name0, name1 T = value0, value1   // 指明类型，定义多个常量
const name = value                      // 无类型常量
const name0, name1 = value0, value1     // 无类型常量，可定义多个

// const name0 T, name1 T = value0, value1	// 错误，const 不能在同一行出现多个类型名（同一类型也不行）

// 将常量定义放在小括号中
const (
	name0 = value0
	name1 = value1
)
</code></pre><p>在小括号中的常量声明列表，const 常与iota常量生成器联用，用来申明连续的 数值常量集。</p>
<pre tabindex="0"><code>// 无类型数值常量集（可转为整型或浮点型）
const (
	Sunday = iota       // 0
	Monday	            // 1
	Tuesday	            // 2
	Wednesday           // 3
	Thursday            // 4
	Friday	            // 5
	Partyday            // 6
	numberOfDays        // 7，该常量未导出
)

// 无类型数值常量集（可转为浮点型）
const (
	Sunday = iota + 0.1   // 0.1
	Monday		      // 1.1
	Tuesday		      // 2.1
	Wednesday	      // 3.1
	Thursday	      // 4.1
	Friday		      // 5.1
	Partyday	      // 6.1
	numberOfDays 	      // 7.1，该常量未导出
)
</code></pre><p>关于go的常量还有：<br>
1）常量可以是类型化的或无类型化的。字面常量，true，false， iota 和某些只包含无类型化操作数的常量表达式是无类型化的；</p>
<p>2）常量可由常量声明或类型转换显式地赋予其类型， 也可由变量声明或赋值以及作为表达式中的操作数隐式地赋予其类型。若常量的值不能由其类型表示就会产生一个错误。 例如，3.0 可赋予任何整数或浮点数类型的常量，而 2147483648.0 （等价于 1&laquo;31）则只能赋予 float32, float64 或 uint32 类型的常量，而不能赋予 int32 或 string类型的常量；</p>
<p>3）尽管数值常量在该语言中可拥有任意精度， 但编译器可能使用其有限精度的内部表示来实现它们。即，每个实现必须：</p>
<ul>
<li>使用至少256位表示整数常量；</li>
<li>使用至少256位表示浮点常量，包括复数常量及尾数部分，和至少16位的有符号指数；</li>
<li>若无法精确表示一个整数常量，则给出一个错误；</li>
<li>若由于溢出而无法表示一个浮点或复数常量，则给出一个错误；</li>
<li>若由于精度限制而无法表示一个浮点或复数常量，则舍入为最近似的可表示常量。</li>
</ul>
<p>这些要求适用于 字面常量 和 常量表达式 的求值结果。</p>
<p>golang中的const 不支持 C/C++ 中修饰函数的参数和返回值，如下语句是非法的：</p>
<pre tabindex="0"><code>func test(const name *string)
func test(name *string) const *string
</code></pre><p><font color=#0099ff size=2 face="黑体">func</font><br>
func 用于定义函数，go函数支持变参且返回值支持多个，但不支持默认参数，若函数存在多个返回值形参则需要使用小括号括起来，格式：</p>
<pre tabindex="0"><code>func funcName(){}			    //无参无返回值
func funcName(t T) T {}			    //有参有返回值
func funcName(t T, list ...T) (T1,T1) {}    //有变参有多个返回值
</code></pre><p>格式上要注意，函数体的第一个大括号必须函数名同行。</p>
<p><font color=#0099ff size=2 face="黑体">interface</font><br>
interface 用于定义接口。一个接口是一个方法集，如果一个类型实现了一个接口中的所有方法集，那么说明该类型实现此接口。接口类型变量可以存储任何实现了该接口的类型的值。特别的，<code>interface{}</code>表示空接口类型，默认地，所有类型均实现了空接口，所以<code>interface{}</code>可以接收任意类型值。</p>
<pre tabindex="0"><code>// 空接口
interface{}

// 一个简单的 File 接口
type File interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
</code></pre><p><font color=#0099ff size=2 face="黑体">map</font><br>
map 用于声明映射变量。映射属容器类类型，是一个同种类型元素的无序组，通过唯一的键可以获取对应的值。可以使用 make 创建 map 变量，在定义 map 时可以省略容量，超出容量时会自动扩容，但尽量提供一个合理的初始值。未初始化的映射值为 nil。</p>
<p>// 由于map底层是一个hash map，其并没有具体的容量，指定容量也是一个建议值，所以无法使用 <code>cap()</code>函数来获取map的容量。</p>
<pre tabindex="0"><code>// 错误示例
func main() {
    m := make(map[string]int, 99)
    println(cap(m))     // error: invalid argument m1 (type map[string]int) for cap  
}    
</code></pre><h6 id="创建map">创建map</h6>
<pre tabindex="0"><code>// 创建 0 容量的 map
var myMap = make(map[T1]T2) 
var myMap = map[T1]T2{}

// 创建指定容量的 map
var myMap = make(map[T1]T2, hint) 

// 创建并初始化 map
var myMap = map[string]int {
	&#34;dable&#34; : 27,
	&#34;cat&#34; : 28,
}
</code></pre><p>示例：</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

func main() {
	nameAge := make(map[string]int)
	nameAge[&#34;bob&#34;] = 18                     //增
	nameAge[&#34;tom&#34;] = 16                     //增
	delete(nameAge, &#34;bob&#34;)                  //删
	nameAge[&#34;tom&#34;] = 19                     //改
	v := nameAge[&#34;tom&#34;]                     //查
	fmt.Println(&#34;v=&#34;,v)
	v, ok := nameAge[&#34;tom&#34;]                 //查，推荐用法
	if ok { 
		fmt.Println(&#34;v=&#34;,v,&#34;ok=&#34;,ok)
	}   
	for k, v :=range nameAge {      		//遍历
		fmt.Println(k, v)
	}   
}
</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>v= 19
v= 19 ok= true
tom 19
</code></pre><h6 id="map-遍历">map 遍历</h6>
<p>遍历所有key</p>
<pre tabindex="0"><code>// 方式一
for k := range mapVar {
	...
}

// 方式二（不推荐）
for k, _ := range mapVar {
	...
}
</code></pre><p>遍历所有value</p>
<pre tabindex="0"><code>for _, v := range mapVar {
	...
}
</code></pre><p>遍历所有key与value</p>
<pre tabindex="0"><code>for k, v := range mapVar {
	...
}
</code></pre><p>// map 在没有被修改的情况下，使用range多次遍历map时输出的key和value的顺序可能不同，这是go设计者有意为之，在每次range时的顺序被随机化，旨在提示开发者，go底层实现并不保证map遍历顺序稳定，请大家不要依赖range遍历结果顺序。<a href="https://go.dev/blog/maps"target="_blank" rel="noopener noreferrer">Go maps in action</a>
</p>
<h6 id="map增删改查">map增删改查</h6>
<p>向map写入元素时，键值对不存在会自动添加，键值存在时将被新值覆盖。使用 <code>delete()</code> 删除某键值对，使用 <code>len()</code> 获取元素个数。</p>
<pre tabindex="0"><code>// 新增或修改
m[&#34;name&#34;] = &#34;wade&#34;
 
// 删除，key 不存在则啥也不干
delete(m, &#34;name&#34;)
 
// 三种查询方式 
// 查询，key 不存在返回 value 类型的零值
v := m[&#34;name&#34;]
v, ok := m[&#34;name&#34;]
_, ok := m[&#34;name&#34;]
</code></pre><hr>
<p>map使用需注意：</p>
<ul>
<li>
<p>map默认初始值为 <code>nil</code>
map 声明时未初始化的情况下值为 nil。对 nil map 取值，返回对应类型的零值，不会引发 panic；但写入会引发 panic，所以推荐做法是向 map 写入时先判断 map 是否为 nil；</p>
</li>
<li>
<p>map range 的顺序是随机的</p>
</li>
<li>
<p>map 值传递表现出引用传递的效果
Go 没有引用传递，只有值传递与指针传递。所以 map 作为函数实参传递时本质上也是值传递，只不过因为 map 底层数据结构是通过指针指向实际的元素存储空间，在被调函数中修改 map，对调用者同样可见，所以 map 作为函数实参传递时表现出了引用传递的效果。因此，传递 map 时，函数形参无需使用指针；</p>
</li>
<li>
<p>map 的元素不可选址
map 中的元素并不是一个变量，而是一个值，对 map 元素取值将报运行时错误，因此当 map 的元素为结构体类型的值，那么无法直接修改结构体中的字段值。如果想修改，有两个解决办法，一是存储 struct 的指针类型，二是使用临时变量，每次取出来后再设置回去；</p>
</li>
<li>
<p>map 并发读写不安全
需要加锁，或只用 <code>sync.Map</code> ，否则会引发panic。</p>
</li>
</ul>
<p>示例：<a href="https://dablelv.blog.csdn.net/article/details/90729484"target="_blank" rel="noopener noreferrer">go map 三板斧</a>
</p>
<p><font color=#0099ff size=2 face="黑体">struct</font><br>
<code>struct</code> 用于定义结构体，结构体属容器类型，是多个相同或不同类型值的集合。</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

type Vertex struct {
	X, Y int
}

var (
	v1 = Vertex{1, 2}  // 类型为 Vertex
	v2 = Vertex{X: 1}  // Y:0 被省略
	v3 = Vertex{}      // X:0 和 Y:0
	p  = &amp;Vertex{1, 2} // 类型为 *Vertex
)

func main() {
	fmt.Printf(&#34;%#v %#v %#v %#v\n&#34;, v1, v2, v3, p)
}
</code></pre><p><font color=#0099ff size=2 face="黑体">type</font><br>
<code>type</code> 用于定义类型，比如定义struct、interface、func与等价类型。</p>
<pre tabindex="0"><code>// 定义struct
type Person struct { name string }

// 定义接口
type Person interface {
	speak(word string)
}

// 定义函数类型
type FuncType func(int, int) int

// 定义等价类型，rune等价于int32
type rune int32
</code></pre><p><font color=#0099ff size=2 face="黑体">var</font><br>
<code>var</code> 用于声明函数级变量和包级变量。</p>
<pre tabindex="0"><code>var name T							// 指明类型，使用类型零值
var name T = value					// 指明类型，指明初始值
var name0, name1 T					// 指明类型，使用类型零值定义多个变量
var name0, name1 T = value0, value1	// 指明类型，指明初始值定义多个变量

var name = value					// 根据值推断变量类型
var name0, name1 = value0, value1	// 根据值推断变量类型，可定义多个不同类型变量

// var name0 T, name1 T				// 错误，var 不能在同一行出现多个类型名（同一类型也不行）

// 将变量定义放在括号中
var (
	name0 = value0
	name1 = value1
)
</code></pre><p>定义变量可以使用短变量声明方式（:=） 替代var，但短变量声明方式只能用于函数体内声明函数级变量，且需指明初始值，声明时不能指明变量类型，类型由初始化确定。</p>
<pre tabindex="0"><code>name := value			// 申明一个变量
name0, name1 := value0, value1	// 申明多个变量，变量类型可以不同
</code></pre><p>声明多个变量时候，只要有一个是新的即可。</p>
<pre tabindex="0"><code>func main() {
	oldVar := 1
	oldVar, newVar := 2, 3
	fmt.Printf(&#34;oldVar=%v newVar=%v\n&#34;, oldVar, newVar) // oldVar=2 newVar=3
}
</code></pre><p><code>var</code> 与 <code>:=</code> 区别：</p>
<ul>
<li>var 既可以声明函数级变量，也可以声明包级变量，而短变量只能声明函数级变量</li>
<li>var 可以不指定初始值，短变量声明方式必须指定初始值</li>
<li>var 可以指定数据类型，短变量声明方式不能指定数据类型</li>
</ul>
<h1 id="程序流程控制">程序流程控制</h1>
<p><font color=#0099ff size=2 face="黑体">for range break continue</font><br>
for 是go 中唯一用于循环结构的关键词，有三种使用方式，分别是单个循环条件，经典的初始化/条件/后续形式，还有和 range 关键词结合使用来遍历容器类对象（数组、切片、映射、信道）。</p>
<pre tabindex="0"><code>// 单条件
i := 1
for i &lt;= 3 {
	fmt.Println(i)
	i = i + 1
}

// 初始化/条件/后续形式
// 注意 Go 中没有前置自增与自减运算符，即++i是非法的
for i:=0; i &lt; 3; i++ {
	fmt.Println(i)
}

// for range 遍历数组
array :=[...]int{0,1,2,3,4,5}
for i, v :=range array{
	fmt.Println(i,v)
}

// 只遍历下标
for i := range array {
	fmt.Println(i)
}
</code></pre><p><code>break</code> 用于终止最内层的 <code>for</code> <code>switch</code> <code>select</code> 语句的执行，break 可以携带标签，用于跳出多层，若存在标签，则标签必须放在<code>for</code> <code>switch</code> <code>select</code> 语句的开始处。</p>
<pre tabindex="0"><code>// 终止for
L:
for i &lt; n {
	switch i {
	case 5:
		break L
	}
}
</code></pre><p><code>continue</code> 用于结束当前循环，提前进入下一轮循环。也可以像break一样携带标签，此时程序的执行流跳转到标签的指定位置，可用于跳出多层<code>for</code> <code>switch</code> <code>select</code> ，提前进入下一轮执行。</p>
<pre tabindex="0"><code>// 提前进入下一轮循环
for i:=0; i &lt; 3; i++ { 
	if i == 1 {
		continue
	}
	fmt.Println(i)
}
// 输出结果
0
2

// 提前进入标签处for的下一轮循环
L:
for i:=0; i &lt; 2; i++ { 
	for j:=0; j &lt; 3; j++{
		if j == 1 {
			continue L
		}
		fmt.Println(i, j)
	}
}
//输出结果
0 0
1 0
</code></pre><p><font color=#0099ff size=2 face="黑体">goto</font><br>
<code>goto</code> 用于将程序的执行转移到与其标签相应的语句。可以使用 goto 退出多层<code>for</code> <code>switch</code> <code>select</code>，功能类似于break携带标签。</p>
<pre tabindex="0"><code>// 终止for
L:
	for i &lt; n {
		switch i {
		case 5:
			goto L
		}
	}
</code></pre><p>注意事项：</p>
<ul>
<li>执行<code>goto</code> 不能在跳转过程中跳过变量的定义，否则编译报错。</li>
</ul>
<pre tabindex="0"><code>	goto L  //编译报错
	v := 3
L:
	fmt.Println(v)
</code></pre><ul>
<li>在块外的goto语句不能跳转至该块中的标签。</li>
</ul>
<pre tabindex="0"><code>if n%2 == 1 {
	goto L1
}
for n &gt; 0 {
	f()
	n--
L1:
	f()
	n--
}
//是错误的，因为标签L1在for语句中的块而goto则不在。
</code></pre><ul>
<li>程序设计时，尽量避免使用goto语句，因为程序执行流的随意跳转会破坏结构化设计风格，导致代码可读性下降。</li>
</ul>
<p><font color=#0099ff size=2 face="黑体">switch case default fallthrough</font><br>
这四个关键词是结合使用的。switch 语句提供多路执行，表达式或类型说明符与 switch 中的 case 相比较从而决定执行哪一分支。如果存在一个且最多只能存在一个 default 默认分支，所有的 case 分支都不满足时将执行 default 分支，且 default 分支不一定要放在最后的位置。Go switch 语句在执行完某个 case 子句后，不会再顺序地执行后面的 case 子句，而是结束当前 switch 语句。使用 fallthrough 可以继续执行下一个 case 或 default 子句。case 表达式可以提供多个待匹配的值，使用逗号分隔。</p>
<p>switch 有两种形式，表达式选择 和 类型选择 。</p>
<ul>
<li>表达式选择
表达式选择可以没有表达式，缺省为 true，这种写法也习惯地取代 if-else-if-else 语句链。表达式可以不是常量。表达式前面可以有简单语句，比如短变量申明语句。可见 Go switch 相对于 C 有较大的区别且更加灵活。</li>
</ul>
<pre tabindex="0"><code>switch tag {
default: s3()		// default 子句可以出现在任意位置，不一定是最后一个
case 0, 1, 2, 3: s1()	// case 表达式可以提供多个待匹配的值，使用逗号分隔
case 4, 5, 6, 7: s2()
}

switch {		// 缺失的表达式为 true
case x &lt; y: f1()
fallthrough		// 强制执行下一个 case 子句
case x &lt; z: f2()
// 此处没有 fallthrough，switch 执行流在此终止	
case x == 4: f3()
}

switch x := f() {	// 缺省表达式试为 true 且前面存在一条短变量申明语句
case x &lt; 0: return -x	// case 表达式无需为常量
default: return x
}
</code></pre><ul>
<li>类型选择<br>
类型选择比较类型而不是值。它类似于表达式选择，由一个特殊的表达式表示类型，该表达式的形式是使用保留字 type 的类型断言而不是实际的类型。</li>
</ul>
<pre tabindex="0"><code>switch x.(type) {
// cases
}
</code></pre><p>使用实际类型 T 与表达式 x 的动态类型进行匹配。与类型断言一样，x 必须是接口类型，列出的每个非接口类型T必须实现 x 且不能相同。</p>
<pre tabindex="0"><code>switch i := x.(type) {
case int:
	printInt(i)                            // i 类型为 int
case float64:
	printFloat64(i)                        // i 类型为 float64
case func(int) float64:
	printFunction(i)                       // i 类型为 func(int) float64
case bool, string:
	printString(&#34;type is bool or string&#34;)  // i 类型为 bool or string
default:
	printString(&#34;don&#39;t know the type&#34;)     // i 类型未知
}
</code></pre><p><font color=#0099ff size=2 face="黑体">if else</font><br>
if 与else 实现条件控制：</p>
<ul>
<li>可省略条件表达式的括号</li>
<li>支持初始化语句，可定义代码块局部变量</li>
<li>if 与 else 块中只有一条语句也需要添加大括号</li>
<li>起始大括号必须与 if 和 else 同行</li>
</ul>
<pre tabindex="0"><code>if err := file.Chmod(0664); err != nil {
	log.Print(err)
	return err
}
</code></pre><p><font color=#0099ff size=2 face="黑体">return</font><br>
return 用于函数执行的终止并可选地提供一个或多个返回值。 任何在函数 F 中被推迟的函数会在 F 返回给其调用者前执行。如果返回值在函数返回形参中指定了名字，那么 return 时可不带返回值列表。</p>
<pre tabindex="0"><code>// 无返回值
func noResult() {
	return
}

// 单返回值
func simpleF() int {
	return 2
}

// 多返回值
func complexF2() (float64, float64) {
	re = 7.0
	im = 4.0
	return re, im
}

// 返回值已具名
unc complexF3() (re float64, im float64) {
	re = 7.0
	im = 4.0
	return
}
</code></pre><p><font color=#0099ff size=2 face="黑体">defer</font><br>
defer 用于预设一个函数调用，推迟函数的执行。 被推迟的函数会在执行 defer 的函数返回之前立即执行。 例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁和关闭文件。</p>
<pre tabindex="0"><code>//将文件的内容作为字符串返回。
func Contents(filename string) (string, error) {
	f, err := os.Open(filename)
	if err != nil {
		return &#34;&#34;, err
	}
	defer f.Close()  // f.Close 会在函数结束后运行

	var result []byte
	buf := make([]byte, 100)
	for {
		n, err := f.Read(buf[0:])
		result = append(result, buf[0:n]...)
		if err != nil {
			if err == io.EOF {
				break
			}
			return &#34;&#34;, err  // 我们在这里返回后，f 就会被关闭
		}
	}
	return string(result), nil // 我们在这里返回后，f 就会被关闭
}
</code></pre><p>推迟诸如 Close 之类的函数调用有两点好处：<br>
第一，它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时，这种情况往往就会发生；<br>
第二，它意味着“关闭”离“打开”很近，这总比将它放在函数结尾处要清晰明了。</p>
<p>使用 <code>defer</code> 注意的点：</p>
<ul>
<li>defer 函数的入参在defer 时确定<br>
被推迟函数的实参（如果该函数为方法还包括接收者）在推迟执行时就会求值，而不是在调用执行时才求值。这样不仅无需担心变量在 defer 函数执行前被改变，还意味着可以给 defer 函数传递不同实参。</li>
</ul>
<pre tabindex="0"><code>for i := 0; i &lt; 5; i++ {
	defer fmt.Printf(&#34;%d &#34;, i)
}
</code></pre><ul>
<li>
<p>多个defer函数的执行顺序为后进先出<br>
被推迟的函数按照后进先出（Last In First Out，LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0。</p>
</li>
<li>
<p>defer 函数在 return 语句赋值返回值与ret之间执行<br>
return 语句不是原子操作，而是被拆成了两步</p>
</li>
</ul>
<pre tabindex="0"><code>rval = xxx
ret
</code></pre><p>而defer函数就是在这两条语句之间执行</p>
<pre tabindex="0"><code>rval = xxx
defer_func
ret
</code></pre><p>所以被defer 的函数可以读取和修改带名称的返回值</p>
<pre tabindex="0"><code>// 返回值为 2
func c() (i int) {
    defer func() { i++ }()
    return 1
}
</code></pre><p><font color=#0099ff size=2 face="黑体">go</font><br>
go 用于创建 Go 程（goroutine），实现并发编程。Go 程是与其它 Go 程并发运行在同一地址空间的函数，相比于线程与进程，它是轻量级的。Go 程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待 I/O，那么其它的线程就会运行。Go 程的设计隐藏了线程创建和管理的诸多复杂性。</p>
<p>在函数或方法前添加 go 关键字能够在新的 Go 程中调用它。当调用完成后，该 Go 程也会安静地退出。效果有点像 Unix Shell 中的 &amp; 符号，它能让命令在后台运行。</p>
<pre tabindex="0"><code>package main

import (
	&#34;fmt&#34;   
	&#34;time&#34;  
)

func main() {
	go func(){ 
		fmt.Println(&#34;in first goroutine&#34;)
	}()     
	go func(){ 
		fmt.Println(&#34;in second goroutine&#34;)
	}()     

	fmt.Println(&#34;main thread start sleep, and other goroutine start execute&#34;)
	time.Sleep(10*time.Second)
}
</code></pre><p>输出结果：</p>
<pre tabindex="0"><code>main thread start sleep, and other goroutine start execute
in second goroutine
in first goroutine
</code></pre><p>输出结果得知，go程 的执行顺序和创建的顺序是没有关系的，也就是说存在多个 go程 时，其执行顺序是随机的。</p>
<p><font color=#0099ff size=2 face="黑体">select</font><br>
select 语句用来选择一组中某个 case 中的发送或接收操作可以被立即执行。它类似于 switch 语句，但是它的 case 必须是一个通信操作。</p>
<p>也就是说 select 是用来监听和 channel 有关的 IO 操作，它与 select，poll，epoll 相似，当 IO 操作发生时，触发相应的动作，实现 IO 多路复用。</p>
<pre tabindex="0"><code>package main

import &#34;fmt&#34;

func main() {
    ch1 := make(chan int, 1)
    ch2 := make(chan int, 1)

    ch1 &lt;- 3
    ch2 &lt;- 5

    select {
    case &lt;- ch1:
        fmt.Println(&#34;ch1 selected&#34;)
    case &lt;- ch2:
        fmt.Println(&#34;ch2 selected&#34;)
	default:
		// 如果ch1与ch2没有数据到来，则进入default处理流程。如果没有default子句，则select一直阻塞等待ch1与ch2的数据到来
		fmt.Println(&#34;default&#34;)
	}
}
</code></pre><p>输出：</p>
<pre tabindex="0"><code>ch1 selected

// 或者
ch2 selected
</code></pre><p>从输出结果得知，当存在多个case满足条件，即有多个 channel 存在数据时，会随机地选择一个执行。<br>
若想让某个 go程 永久阻塞，可以使用没有case和default语句的select：</p>
<pre tabindex="0"><code>select{}

# 等效于
for{}
</code></pre></article><section class="article labels"><a class="category" href=/categories/golang/>Golang</a><a class="tag" href=/tags/%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7/>打怪升级</a></section>
</div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/2.%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/"><span class="iconfont icon-article"></span>2.条件与循环</a></p><p><a class="link" href="/posts/1.golang%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"><span class="iconfont icon-article"></span>1.golang语法基础</a></p></section><section class="article discussion"><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "cldjq" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">承离的觉前</p>
    <p class="powerby"><span>Powered&nbsp;by&nbsp;</span><a href="https://tinklespring.com" 
        target="_blank" rel="noopener noreferrer">TinkleSpring</a><span>&nbsp;&amp;&nbsp;</span><a href="https://tinklespring.com" 
        target="_blank" rel="noopener noreferrer">TinkleSpring</a>
<a href='https://ipv6-test.com/validate.php?url=referer'
  ><img src='https://ipv6-test.com/button-ipv6-80x15.png' 
        alt='ipv6 ready' title='ipv6 ready' border='0' 
/></a>
</p></div>
</section><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/&#43;DiW/UqRcLbRjq" crossorigin="anonymous"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l&#43;B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd&#43;qj&#43;o24G5ZU2zJz" crossorigin="anonymous"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
            onload="renderMathInElement(document.body);"></script>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'G-VHXKH6D389', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</body>

</html>