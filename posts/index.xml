<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 承离的觉前</title>
    <link>https://tinklespring.com/posts/</link>
    <description>Recent content in Posts on 承离的觉前</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 07 Aug 2023 16:27:10 +0800</lastBuildDate>
    
        <atom:link href="https://tinklespring.com/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>10.保密：封装和嵌入</title>
      <link>https://tinklespring.com/posts/10.%E4%BF%9D%E5%AF%86%E5%B0%81%E8%A3%85%E5%92%8C%E5%B5%8C%E5%85%A5/</link>
      <pubDate>Mon, 07 Aug 2023 16:27:10 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/10.%E4%BF%9D%E5%AF%86%E5%B0%81%E8%A3%85%E5%92%8C%E5%B5%8C%E5%85%A5/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;有时，程序会接收到无效的数据，从用户输入、文件读取或其他方式。&lt;code&gt;封装&lt;/code&gt;：一个保护string字段免受无效数据的方法。这样，数据字段能够安全使用。&lt;br&gt;
也会在类型内部嵌入其他的类型，若struct类型需要已经存在于其他类型的方法，不需要赋值方法代码，可以将其嵌入struct类型中，然后像使用自己的类型的定义方法一样使用嵌入的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;创建一个日期struct类型&#34;&gt;创建一个日期struct类型&lt;/h1&gt;
&lt;p&gt;在struct中增加Year、Month、Day字段，每个都是int类型，在main函数中，将执行一个快速的测试来测试新类型，使用struct字面量来创建一个Date值，并填充所有字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Date struct {
        Year  int
        Month int
        Day   int
}

func main() {
        date := Date{Year: 2023, Month: 8, Day: 10}
        fmt.Println(date)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;将date-struct字段设置为无效值&#34;&gt;将Date struct字段设置为无效值&lt;/h1&gt;
&lt;p&gt;用户将日期格式设置的很奇怪，比如：&amp;ldquo;2023 14 50&amp;rdquo; 或 &amp;ldquo;0 0 -2&amp;rdquo; 等，我们知道只有1以上的年的数字才合法，但程序没做任何措施预防用户把日志以外设置为0或-999，月份也只有1-12合法，日只有1-31合法。&lt;/p&gt;
&lt;p&gt;需要一种方法，让用户数据在被赋值之前是合法的，在CS领域中，被称为&lt;code&gt;数据校验&lt;/code&gt;，需要测试Year被设置为大于或等于1，Month被设置为1-12，Day被设置为1-31。&lt;/p&gt;
&lt;h1 id=&#34;setter方法&#34;&gt;setter方法&lt;/h1&gt;
&lt;p&gt;一个struct类型就是另一个定义的类型，可以像对其他类型一样定义它的方法。可以在Date类型上创建 SetYear、SetMonth、SetDay方法来接收值，判断是否有效，若有效则设置到struct字段。&lt;/p&gt;
&lt;p&gt;这类方法被称为 &lt;code&gt;setter方法&lt;/code&gt; , Go的setter方法名为&lt;code&gt;SetX&lt;/code&gt;的形式，X 是想要设置的名称。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setter 方法 是用来设置字段或基础类型中的其他值的方法。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在SetYear方法上进行第一次尝试，接收器参数是Date struct，SetYear接受想要设置的年份作为参数，并设置接收器Date struct上的Year字段，此时并不校验值有效性。在main方法中创建Date并调用SetYear，然后输出struct的Year字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Date struct {
        Year  int
        Month int
        Day   int
}

func (d Date) SetYear(year int) {
        d.Year = year    //设置struct字段
}

func main() {
        date := Date{}  //创建一个Date
        date.SetYear(2023)  //通过方法设置Year字段
        fmt.Println(date.Year)  //打印Year字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当执行时，并没有正常工作，创建了一个Date并使用新值调用了它的setYear方法，Year字段仍被设置为零值。&lt;/p&gt;
&lt;h1 id=&#34;setter方法需要指针接收器&#34;&gt;setter方法需要指针接收器&lt;/h1&gt;
&lt;p&gt;之前Number类型上的Double方法，使用了一个普通的值接收器类型Number，像其他参数一样，接收器参数接受了一个原值的拷贝，Double方法只是更新了拷贝，在方法退出时更新就丢失了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (n *Number) Double() {   //接收器类型为一个指针类型
        *n *= 2  //修改指针指向的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要更新Double来接受指针的接收器类型 &lt;code&gt;*Number&lt;/code&gt; ，当更新指针指向的值的时候，在Double退出后更新会保留。&lt;/p&gt;
&lt;p&gt;同样，SetYear也适用，Date接收器从原struct获取了一个拷贝，任何字段更新都在setYear退出后消失。&lt;/p&gt;
&lt;p&gt;通过将接收器的值修改为指针来修正，不需要更新SetYear方法块，因为 d.Year 会自动获取指针指向的值（与&lt;code&gt;(*d).Year&lt;/code&gt; 一样），main函数中的date.SetYear也不需要修改，因为当Date值传递给方法的时候，会自动转换为 &lt;code&gt;*Date&lt;/code&gt; 。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Date struct {
        Year  int
        Month int
        Day   int
}

func (d *Date) SetYear(year int) {
        d.Year = year
}

func main() {
        date := Date{}
        date.SetYear(2023)  //自动转换为指针
        fmt.Println(date.Year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;添加其余的setter方法&#34;&gt;添加其余的setter方法&lt;/h1&gt;
&lt;p&gt;按照这个模式在Date类型上定义SetMonth和SetDay方法，只需要在方法中使用指针接收器即可，在调用方法时，Go会自动把接收器转换为指针，并在修改struct字段时能够把指针转换回struct值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Date struct {
	Year  int
	Month int
	Day   int
}

func (d *Date) SetYear(year int) {
	d.Year = year
}

func (d *Date) SetMonth(month int) {
	d.Month = month
}

func (d *Date) SetDay(day int) {
	d.Day = day
}

func main() {
	date := Date{}
	date.SetYear(2023)
	date.SetMonth(5)
	date.SetDay(27)
	fmt.Println(date)  //输出所有字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在main函数中，创建了一个Date struct的值，通过新的方法设置了它的Year、Month和Day字段，并输出了整个struct查看结果。&lt;/p&gt;
&lt;h1 id=&#34;在setter方法中添加校验&#34;&gt;在setter方法中添加校验&lt;/h1&gt;
&lt;p&gt;在每个setter方法中，将测试值是否在正确合法范围内，若非法，返回error值，若合法，将正常设置 Date struct字段，并返回nil作为错误值。&lt;/p&gt;
&lt;p&gt;首先对SetYear方法增加校验，修改方法的声明，增加一个error类型的返回值，在方法块的开始处，测试调用者传入的year参数是否小于1，若小于1，返回一个error信息，若大于等于1，将其设置为struct的Year字段并返回nil，表示没有错误。&lt;/p&gt;
&lt;p&gt;在main函数中，调用SetYear并把返回值保存到名为err的变量中，若err不为nil，意味着赋值无效，所以记录错误并退出，否则继续输出Date struct的Year字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;errors&amp;#34; //允许创建error值
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34; //允许记录error并退出
)

type Date struct {
	Year  int
	Month int
	Day   int
}

func (d *Date) SetYear(year int) error { //增加一个error类型的返回值
	if year &amp;lt; 1 {
		return errors.New(&amp;#34;invalid year&amp;#34;) //若year是非法的，返回错误
	}
	d.Year = year
	return nil
}

func main() {
	date := Date{}
	err := date.SetYear(0) //抓捕任何错误
	if err != nil {
		log.Fatal(err)  //若值无效记录错误并退出
	}
	fmt.Println(date.Year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023/08/10 16:56:33 invalid year
exit status 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;传入一个无效的值给SetYear导致程序报错并退出，但若传入有效值，程序会继续输出，SetYear方法工作正常。&lt;/p&gt;
&lt;p&gt;SetMonth 与 SetDay 方法中的校验代码与SetYear类似：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (d *Date) SetYear(year int) error { //增加一个error类型的返回值
	if year &amp;lt; 1 {
		return errors.New(&amp;#34;invalid year&amp;#34;) //若year是非法的，返回错误
	}
	d.Year = year
	return nil
}

func (d *Date) SetMonth(month int) error {
	if month &amp;lt; 1 || month &amp;gt; 12 {
		return errors.New(&amp;#34;invalid month&amp;#34;)
	}
	d.Month = month
	return nil
}

func (d *Date) SetDay(day int) error {
	if day &amp;lt; 1 || day &amp;gt; 31 {
		return errors.New(&amp;#34;invalid day&amp;#34;)
	}
	d.Day = day
	return nil
}

func main() {
        //try
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在SetMonth中，测试提供的月份值，若小于1或大于12，就返回错误，否则设置字段并返回nil。&lt;/p&gt;
&lt;p&gt;在SetDay中，测试提供的日期小于1或大于31，返回错误，有效值设置字段并返回nil。&lt;/p&gt;
&lt;h1 id=&#34;字段仍可以设置为无效值&#34;&gt;字段仍可以设置为无效值&lt;/h1&gt;
&lt;p&gt;使用setter方法，提供校验很不错，但是用户可以直接设置struct字段，仍然能设置无效值。&lt;/p&gt;
&lt;p&gt;没有任何方法能阻止直接设置Date struct字段，若这么做，就会绕过setter方法中的校验代码。&lt;/p&gt;
&lt;p&gt;需要一个方式来保护这些字段，让Date类型只能使用setter方法来更新字段，Go提供了一个方式：&lt;code&gt;把Date类型移动到另一个包，并将数据字段设置为非导出的&lt;/code&gt;。未导出的变量、函数等在大多数情况下无法导出，即使之前的magazine包中的Subscriber struct类型被导出(字段首字母非大写)，但是它的字段并未被导出，导致在magazine包之外无法访问。&lt;/p&gt;
&lt;h1 id=&#34;将date类型移动到另外的包中&#34;&gt;将Date类型移动到另外的包中&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

import &amp;#34;errors&amp;#34;

type Date struct {
	year  int
	month int
	day   int
}  //将字段名称修改为小写字母让其不可被导出

func (d *Date) SetYear(year int) error {
	if year &amp;lt; 1 {
		return errors.New(&amp;#34;invalid year&amp;#34;)
	}
	d.year = year //更新字段名称匹配声明
	return nil
}

func (d *Date) SetMonth(month int) error {
	if month &amp;lt; 1 || month &amp;gt; 12 {
		return errors.New(&amp;#34;invalid month&amp;#34;)
	}
	d.month = month //更新字段名称匹配声明
	return nil
}

func (d *Date) SetDay(day int) error {
	if day &amp;lt; 1 || day &amp;gt; 31 {
		return errors.New(&amp;#34;invalid day&amp;#34;)
	}
	d.day = day  //更新字段名称匹配声明
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改main包：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/calendar&amp;#34;
)

func main() {
        date := calendar.Date{}
        date.year = 2023
        date.month = 14
        date.day = 50
        fmt.Println(date)

        date = calendar.Date{year: 0, month: 0, day: -2}
        fmt.Println(date)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Date的字段未导出，从main包中访问，会导致编译错误。&lt;/p&gt;
&lt;h1 id=&#34;通过导出的方法访问未导出的字段&#34;&gt;通过导出的方法访问未导出的字段&lt;/h1&gt;
&lt;p&gt;可以间接访问字段。未导出的变量、struct字段、函数、方法等仍然能被相同包的导出的函数或者方法访问。所以当mian包中的代码在Date值上调用导出方法SetYear时，SetYear可以修改Date的year字段，即使year是未导出的。导出方法SetYear可以更新未导出的month字段等。&lt;/p&gt;
&lt;p&gt;修改main包来使用setter方法，可以更新Date值的字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/calendar&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        date := calendar.Date{}
        err := date.SetYear(2023)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetMonth(5)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetDay(27)
        if err != nil {
                log.Fatal(err)
        }
        fmt.Println(date)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{2023 5 27}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;未导出的变量、struct字段、函数、方法等仍然能够被相同包的导出的函数或方法访问。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时若传入无效值，执行时会得到错误。&lt;/p&gt;
&lt;p&gt;现在的Date值的字段只能通过setter方法更新，程序被保护，避免意外输出无效数据。&lt;/p&gt;
&lt;h1 id=&#34;getter方法&#34;&gt;getter方法&lt;/h1&gt;
&lt;p&gt;将值设置给struct字段或者变量的方法称为 &lt;code&gt;setter&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;获取struct字段或者变量的值的方法称为 &lt;code&gt;getter&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;按照惯例，getter方法的名称应该与访问的字段或者变量的名字相同。（若希望方法被导出，首字母应该大写。）所以Date需要一个Year方法来访问year字段，Month方法来访问month字段，Day方法来访问day字段。&lt;/p&gt;
&lt;p&gt;getter方法不需要修改接收器，直接使用Date的值作为接收器。若类型的任何方法接受接收器指针类型，为了一致性，通常所有的方法都应该这样做。由于必须对所有的setter方法使用接收器指针，也应对所有的getter方法使用指针。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package calendar

import &amp;#34;errors&amp;#34;

type Date struct {
	year  int
	month int
	day   int
}

func (d *Date) Year() int {  //与setter方法一致，使用一个接收器指针类型；Year与字段名称相同，为了导出首字母大写。
	return d.year   //返回字段值
}

func (d *Date) Month() int {
	return d.month
}

func (d *Date) Day() int {
	return d.day
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改main：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        date := calendar.Date{}
        err := date.SetYear(2023)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetMonth(5)
        if err != nil {
                log.Fatal(err)
        }
        err = date.SetDay(27)
        if err != nil {
                log.Fatal(err)
        }
        fmt.Println(date.Year())
        fmt.Println(date.Month())
        fmt.Println(date.Day())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出(getter方法返回的值)：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2023
5
27
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;封装&#34;&gt;封装&lt;/h1&gt;
</description>
    </item>
    
    <item>
      <title>9.定义类型</title>
      <link>https://tinklespring.com/posts/9.%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 05 Aug 2023 12:28:25 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/9.%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;本篇展示使用任意类型作为基础类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;具有底层基础类型的定义类型&#34;&gt;具有底层基础类型的定义类型&lt;/h1&gt;
&lt;p&gt;Go经常使用 struct 作为基础类型来定义类型，但也能基于 int、string、bool或其他任何类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Liters float64
type Gallons float64  //定义两个新类型，基础类型都是float64

func main() {
        var carFuel Gallons
        var busFuel Liters
        carFuel = Gallons(10.0)   //把float64转换为Gallons
        busFuel = Liters(240.0)   //把float64转换为Liters
        fmt.Println(carFuel, busFuel)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一旦定义一个类型，可以把任何基础类型的值转换为定义的类型，像其他类型转换一样，写下需要转换到的类型，后面跟着小括号中的希望转换的值。&lt;/p&gt;
&lt;p&gt;若需要，上面代码中可以使用短变量声明:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;carFuel := Gallons(10.0)
busFuel := Liters(240.0)  //与类型转换同时使用短变量声明
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若变量使用了已定义的类型，不能把另一个类型的值赋给它，即使另一个类型也具有相同的基础类型。&lt;/p&gt;
&lt;p&gt;但是可以在具有相同基础类型的类型之间转换，Liters可以与Gallons互相转换，因为其基础类型都是float64，但是Go只在转换时考虑基础类型的值，Gallons(Liters(240.0)) 与 Liters(Gallons(240.0)) 没有区别，简单地把值从一个类型转换到另一个类型使针对这个类型应该出现的错误保护机制失效。&lt;/p&gt;
&lt;p&gt;升与加仑转换：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;carFuel = Gallons(Liters(40.0) * 0.264)
busFuel = Liters(Gallons(63.0) * 3.785)
fmt.Printf(&amp;#34;Gallons: %0.1f Liters: %0.1f\n&amp;#34;, carFuel, busFuel)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;定义类型和运算符&#34;&gt;定义类型和运算符&lt;/h1&gt;
&lt;p&gt;一个定义类型提供与所有基础类型相同的运算，基于float64类型，提供算数运算符&lt;code&gt;+、-、*、/&lt;/code&gt;，也提供比较运算&lt;code&gt;==、&amp;gt;、&amp;lt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;并且基于基础类型string的类型，支持&lt;code&gt;+、==、&amp;gt;、&amp;lt;&lt;/code&gt;，但是不支持&lt;code&gt;-&lt;/code&gt;，因为 - 对于string不是合法的运算符。&lt;/p&gt;
&lt;p&gt;一个定义类型可以被用来与字面值一起运算：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(Liters(1.2) + 3.4)
fmt.Println(Gallons(5.5) - 2.2)
fmt.Println(Gallons(1.2) == 1.2)
fmt.Println(Liters(1.2) &amp;lt; 3.4)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;4.6
3.3
true
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义类型不能用来与不同类型的值一起运算，即使它们来自相同的基础类型。若想要将一个Liters中的值与Gallons中的值作运算，需要将其中一个类型转换为另一个类型。&lt;/p&gt;
&lt;h1 id=&#34;使用函数进行类型转换&#34;&gt;使用函数进行类型转换&lt;/h1&gt;
&lt;p&gt;让不同类型的值一起运算，需要进行类型转换：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;carFuel = Gallons(Liters(40.0) * 0.264)
busFuel = Liters(Gallons(63.0) * 3.785)

	func ToGallons(l Liters) Gallons {
                return Gallons(l * 0.364)
	}

        func ToLiters(g Gallons) Liters {
                return Liters(g * 3.785)
        }

        func main() {
                carFuel := Gallons(1.2)
                busFuel := Liters(4.5)
                carFuel += ToGallons(Liters(40.0))   //先将Liters转换为Gallons
                busFuel += ToLiters(Gallons(30.0))   //先将Gallons转换为Liters
                fmt.Printf(&amp;#34;Car fuel: %0.1f gallons\n&amp;#34;, carFuel)
                fmt.Printf(&amp;#34;Bus fuel: %0.1f liters\n&amp;#34;, busFuel)
        }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Car fuel: 11.8 gallons
Bus fuel: 118.1 litters
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;增加一个新类型，Milliliters：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Liters float64
type Milliliters float64
type Gallons float64
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也需要将Milliliters类型进行转换，但如果增加一个Milliliters转换为Gallons的函数，会产生错误，不能在同一个包中出现两个ToGallons函数！&lt;/p&gt;
&lt;p&gt;可以分别修改两个ToGallons函数的名字：LitersToGallons和MillilitersToGallons：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func LitersToGallons(l Liters) Gallons {
        return Gallons(l * 0.264)
}
func MillilitersToGallons(m Milliliters) Gallons {
        return Gallons(m * 0.000264)
}
func GallonsToLiters(g Gallons) Liters {
        return Liters(g * 3.785)
}
func GallonsToMilliliters(g Gallons) Milliliters {
        return Milliliters(g * 3785.41)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然这样消除了冲突，但是名字很长，不方便。&lt;/p&gt;
&lt;p&gt;其他语言的重载，允许存在多个同名函数，只要其参数不同即可，但go不支持重载，有其他方式能达到类似的效果。&lt;/p&gt;
&lt;h1 id=&#34;使用方法修复函数名冲突&#34;&gt;使用方法修复函数名冲突&lt;/h1&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var now time.Time = time.Now()  //time.Now返回一个time.Time值代表当前日期和时间
        var year int = now.Year()  //time.Time值有一个Year方法来返回当前年
        fmt.Printlnt(year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        broken := &amp;#34;G# r#cks&amp;#34;
        replacer := strings.NewReplacer(&amp;#34;#&amp;#34;, &amp;#34;o&amp;#34;)  //返回一个strings.Replacer值，被设置为&amp;#34;#&amp;#34;到&amp;#34;o&amp;#34;的转换
        fixed := replacer.Replace(broken)  //调用strings.Replacer的Replace方法，并传入一个字符串来作转换
        fmt.Println(fixed)  //输出Replace方法返回的字符串
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以用自定义方法来帮助解决类型转换的问题。&lt;/p&gt;
&lt;p&gt;不允许有多个ToGallons函数，所以不得不写很长的函数名称；但是可以有多个名为ToGallons的方法，只要它们被定义在单独的类型中，不用担心名称冲突，让方法名称更短小。&lt;/p&gt;
&lt;h1 id=&#34;定义方法&#34;&gt;定义方法&lt;/h1&gt;
&lt;p&gt;方法定义与函数定义类似，只有一点不同：需要增加一个额外的参数，一个接收器参数，在函数名称之前的括号中；需要提供一个接收器参数的名称，后面跟着类型。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/9-type/%e5%ae%9a%e4%b9%89%e6%96%b9%e6%b3%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;为了调用定义的方法，键入要在其上调用方法的值，一个点和要调用的方法的名称，跟着一对括号；这里调用的方法被称为&lt;code&gt;方法接收器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当调用一个方法时，接收器要被列为第一个，并当定义一个方法的时候，接收器参数也被列为第一个。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;value := MyType(&amp;#34;a MyType value&amp;#34;)
value.sayHi()  //value为方法接收器，sayHi为方法名称
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;方法定义中的接收器参数的名称不重要，重要的是它的类型，定义的方法与此类型的值都关联。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type MyType string   //定义一个类型

func (m MyType) sayHi() {  //定义一个接收器，函数被定义在MyType上
        fmt.Println(&amp;#34;Hi&amp;#34;)
}

func main() {
        value := MyType(&amp;#34;a MyType value&amp;#34;)  //创建一个MyType值
        value.sayHi()  //在这个值上调用sayHi
        anotherValue := MyType(&amp;#34;another value&amp;#34;)  //创建另一个MyType值
        anotherValue.sayHi()  //在另一个值上调用sayHi
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hi
Hi
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先定义了一个名为MyType的类型，使用string作为基础类型，然后定义一个名为sayHi的方法，由于sayHi有一个MyType类型的接收器参数，可以使用任何MyType的值来调用sayHi方法。&lt;/p&gt;
&lt;p&gt;一旦方法被定义在了某个类型，它就能被该类型的任何值调用。&lt;/p&gt;
&lt;h1 id=&#34;接收器参数几乎就是另一个参数&#34;&gt;接收器参数（几乎）就是另一个参数&lt;/h1&gt;
&lt;p&gt;接收器参数的类型是与之联系的方法的类型，除此以外，接收器在Go中没有什么特殊，可以在方法块中访问它们的内容，就像其他的函数参数一样。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type MyType string

func (m MyType) sayHi() {  //输出接收器参数的值
        fmt.Println(&amp;#34;Hi from&amp;#34;, m)
}

func main() {
        value := MyType(&amp;#34;a MyType value&amp;#34;)  //调用方法所需的值
        value.sayHi()  //传递给接收器参数的接收器
        anotherValue := MyType(&amp;#34;another value&amp;#34;)  //调用方法所需的值
        anotherValue.sayHi()  //传递给接收器参数的接收器
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Hi from a MyType value
Hi from another value    //获取了输出中的接收器的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go可以命名接收器的名称，但是若类型定义的所有方法的接收器参数名称一致，则更易读。&lt;/p&gt;
&lt;p&gt;Go开发者通常使用一个字母作为名称：小写的接受器类型名称的首字母（使用m作为MyType接收器的参数名称）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1.能否为任何类型定义新的方法？&lt;br&gt;
方法和类型必须定义在同一包中；意味着不会在hacking包中定义security包中的类型的方法，并且不会为像int或string一类的普通类型定义新的方法。&lt;/p&gt;
&lt;p&gt;2.需要在别人的类型上使用自己的方法&lt;br&gt;
首先考虑是否需要一个函数就足够，函数可以接受需要的任何类型作为参数，但若真的需要一个值具有自定义的方法，在不同的包中给类型增加一些方法，可以创建一个新的类型并将其他包的类型作为匿名字段嵌入，后边会演示如何操作。&lt;/p&gt;
&lt;h1 id=&#34;方法几乎就像一个函数&#34;&gt;方法（几乎）就像一个函数&lt;/h1&gt;
&lt;p&gt;除了在接收器上被调用外，方法与函数完全相同，与其他函数一样，可以在方法名称后面的括号中定义额外的参数，参数变量与接收器参数一样，可以被方法块所访问。当调用方法时，将需要为每个参数提供值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (m MyType) MethodWithParameters(number int, flag bool) {
        fmt.Println(m)
        fmt.Println(number)
        fmt.Println(flag)
}

func main() {
        value := MyType(&amp;#34;MyType value&amp;#34;)
        value.MethodWithParameters(4, true)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MyType value
4
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与函数一样，可以为方法声明一个或多个返回值，返回值将在函数被调用时返回：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (m MyType) WithReturn() int {
        return len(m)
}

func main() {
        value := MyType(&amp;#34;MyType value&amp;#34;)
        fmt.Println(value.WithReturn())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与函数一样，方法名称以大写字母开头，则认为是可导出的，若以小写字母开头，认为是不可导出的。想要在当前包之外使用定义的方法，要确保名字以大写字母开头。&lt;/p&gt;
&lt;h1 id=&#34;指针类型的接收器参数&#34;&gt;指针类型的接收器参数&lt;/h1&gt;
&lt;p&gt;定义了一个新的以int为基础类型的Number类型，为Number类型提供一个名为double的方法，它将接收器的基础类型值乘以2并且重新赋值给接收器，从输出上看方法的接收器并未更新。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Number int  //定义一个基础类型为int的类型

func (n Number) Double() {   //定义一个Number类型
        n *= 2  //接收器的值乘以2，尝试更新接收器
}

func main() {
        number := Number(4)  //创建一个Number的值
        fmt.Println(&amp;#34;Original value of number:&amp;#34;, number)
        number.Double()  //尝试加倍Number
        fmt.Println(&amp;#34;number after calling Double:&amp;#34;, number)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Original value of number: 4
number after calling Double: 4  //Number并未加倍
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之前的double函数也有同样的问题，函数参数接收的是函数调用时的拷贝，不是原始值，当函数退出后任何更新都会失效，为了能让double函数正常，传递一个要更新的值的指针，然后更新该指针指向的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        amount := 6
        double(&amp;amp;amount)  //传递一个指针而不是值
        fmt.Println(amount)
}

func double(number *int) {  //接收指针而不是int值
        *number *= 2  //更新指针指向的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要修改Double方法以使用指针来作其接收器参数：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (n *Number) Double() {  //接收器参数接收指针类型
        *n *= 2  //修改指针指向的值
}

func main() {
        number := Number(4)
        fmt.Println(&amp;#34;Original value of number:&amp;#34;, number)
        number.Double()  //不需要修改方法的调用
        fmt.Println(&amp;#34;number after calling Double:&amp;#34;, number)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Original value of number: 4
number after calling Double: 8  //指针指向的值被更新
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不需要修改方法的调用，当用一个非指针的变量调用一个需要指针的接收器的方法时，Go会自动将非指针类型转换为指针类型，同样指针类型也会自动转换为非指针类型，若调用一个要求值类型的接收器，Go会自动获取指针指向的值，然后传递给方法。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type MyType string

func (m MyType) method() {
        fmt.Println(&amp;#34;Method with value receiver&amp;#34;)
}
func (m *MyType) pointerMethod() {
        fmt.Println(&amp;#34;Method with pointer receiver&amp;#34;)
}

func main() {
        value := MyType(&amp;#34;a value&amp;#34;)
        pointer := &amp;amp;value
        value.method()
        value.pointerMethod()   //值类型自动转换为指针
        pointer.method()   //指针类型自动转换为值
        pointer.pointerMethod()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Method with value receiver
Method with pointer receiver
Method with value receiver
Method with pointer receiver
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;名为method的方法接受一个值类型的接收器，但我们同时使用了值类型和指针类型，如果需要，Go会自动转换；名为pointerMethod的方法接受一个指针类型的接收器，但是使用了值类型和指针类型调用，如果需要，Go会自动转换。&lt;/p&gt;
&lt;p&gt;为了一致性，所有的类型函数接受值类型或者都接受指针类型，避免混用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;为了调用需要接收器指针的方法，需要或者这个值类型的指针！&lt;/p&gt;
&lt;p&gt;只能获取保存在变量中的指针，若尝试获取没有保存在变量中的值的地址，会得到错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;amp;MyType(&amp;#34;a value&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;错误输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cannot take the address of MyType(&amp;#34;a value&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相同的限制也存在于使用接收器指针调用方法时，Go无法将值类型转换为指针类型，除非将接收器的值保存在变量中，若尝试在值类型上调用方法，Go也不会转换为指针，会得到相同的错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;MyType(&amp;#34;a value&amp;#34;).pointerMethod()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;错误输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;cannot call pointer method on MyType(&amp;#34;a value&amp;#34;)
cannot take the address of MyType(&amp;#34;a value&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要将值保存在变量中，允许Go能得到一个指向它的指针：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;value := MyType(&amp;#34;a value&amp;#34;)
value.pointerMethod()   //将其转化为指针
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;这是一个Number类型，定义了两个方法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import &amp;#34;fmt&amp;#34;
type Number int
func (n *Number) Display() {
        fmt.Println(*n)
}
func (n *Number) Double() {
        *n *= 2
}
func main() {
        number := Number(4)
        number.Double()
        number.Display()
}
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;若如此&amp;hellip;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;代码会失败，因为：&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func (n &lt;del&gt;*Number&lt;/del&gt;int) Double() {&lt;br&gt;        *n *= 2&lt;br&gt;}&lt;br&gt;&lt;pre&gt;将接收器参数类型改为一个未在当前包中定义的类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;只能为定义在当前包中的类型定义方法。为一个像int一样全局定义的类型定义方法会导致编译错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func (n &lt;del&gt;*&lt;/del&gt;Number) Double() {&lt;br&gt;        &lt;del&gt;*&lt;/del&gt;n *= 2&lt;br&gt;}&lt;br&gt;&lt;pre&gt;将Double方法的接收器参数改为一个非指针类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;接收器参数接受了一个接收器的拷贝，若Double函数仅修改这个拷贝，当Double返回的时候，原值不会改变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;Number(4).Double()&lt;pre&gt;在一个没有保存到变量的值上直接调用一个需求接收器的指针的方法&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;当调用一个指针类型的接收器时，如果接收器保存在变量中，Go会自动将值转换为指针类型，若没有保存，会得到一个错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func (n &lt;del&gt;*&lt;/del&gt;Number) Display() {&lt;br&gt;        fmt.Println(&lt;del&gt;*&lt;/del&gt;n)&lt;br&gt;}&lt;br&gt;&lt;pre&gt;将Display方法的接收器参数改为一个非指针类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在修改之后，代码仍能正常运行，但破坏了惯例，方法中的接收器参数可以都是指针，或者都是值类型，避免混用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;使用方法将liters和milliliters转换为gallons&#34;&gt;使用方法将Liters和Milliliters转换为Gallons&lt;/h1&gt;
&lt;p&gt;不同于函数，只要方法定义在不同的类型中，就可以重名。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Liters float64
type Milliliters float64
type Gallons float64

func (l Liters) ToGallons() Gallons {
	return Gallons(l * 0.264)
}
func (m Milliliters) ToGallons() Gallons {
	return Gallons(m * 0.000264)
}

func main() {
	soda := Liters(2)
	fmt.Printf(&amp;#34;%0.3f liters equals %0.3f gallons\n&amp;#34;, soda, soda.ToGallons())
	water := Milliliters(500)
	fmt.Printf(&amp;#34;%0.3f milliliters equals %0.3f gallons\n&amp;#34;, water, water.ToGallons())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2.000 liters equals 0.528 gallons
500.000 milliliters equals 0.132 gallons
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;没有使用指针类型作为接收器参数，不需要修改接收器，值类型没有消耗很多内存，参数接受一个拷贝也是合适的。&lt;/p&gt;
&lt;h1 id=&#34;使用方法将gallons转换为liters和milliliters&#34;&gt;使用方法将Gallons转换为Liters和Milliliters&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (g Gallons) ToLiters() Liters {
	return Liters(g * 3.785)
}
func (g Gallons) ToMilliliters() Milliliters {
	return Milliliters(g * 3785.41)
}

func main() {
	milk := Gallons(2)
	fmt.Printf(&amp;#34;%0.3f gallons equals %0.3f liters\n&amp;#34;, milk, milk.Toliters())
	fmt.Printf(&amp;#34;%0.3f gallons equals %0.3f milliliters\n&amp;#34;, milk, milk.ToMilliliters())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;练习：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Liters float64
type Milliliters float64
type Gallons float64

func (l Liters) ToMilliliters() Milliliters {
	return Milliliters(l * 1000)
}
func (m Milliliters) ToLiters() Liters {
	return Liters(m / 1000)
}

func main() {
	l := Liters(3)
	fmt.Printf(&amp;#34;%0.1f liters is %0.1f milliliters\n&amp;#34;, l, l.ToMilliliters())
	ml := Milliliters(500)
	fmt.Printf(&amp;#34;%0.1f milliliters is %0.1f liters\n&amp;#34;, ml, ml.ToLiters())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;3.0 liters is 3000.0 milliliters
500.0 milliliters is 0.5 liters
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>8.结构体：struct</title>
      <link>https://tinklespring.com/posts/8.%E7%BB%93%E6%9E%84%E4%BD%93struct/</link>
      <pubDate>Sat, 29 Jul 2023 18:29:46 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/8.%E7%BB%93%E6%9E%84%E4%BD%93struct/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;有时需要保存超过一种类型的数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;切片可以保存一组数据，映射能保存一组键和一组值，这两种数据结构都只能保存一种类型。有时需要一组不同类型的数据，例如邮件地址，其中包含了街道名、邮编等，无法使用切片或者映射来保存，但是可以使用 &lt;code&gt;struct&lt;/code&gt; 类型来保存。&lt;/p&gt;
&lt;h1 id=&#34;struct是由多种类型的值构成&#34;&gt;struct是由多种类型的值构成&lt;/h1&gt;
&lt;p&gt;使用struct关键字来声明一个 struct 类型，后面跟花括号，在括号中，可以定义一个或多个字段：struct 组合的值。每一个字段定义在一个单独的行，由字段名称、后面跟着的字段需要保存的值类型组成。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/8-struct/struct%e8%af%ad%e6%b3%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;可以使用一个struct类型来作为定义的变量的类型，例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myStruct struct {
       number float64
       word   string
       toggle bool
}
fmt.Printf(&amp;#34;%#v\n&amp;#34;, myStruct)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct { number float64; word string; toggle bool }
{number:0, word:&amp;#34;&amp;#34;, toggle:false}   //struct中每个字段都被设置成其类型的零值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当调用Printf中的 %#v 时，将myStruct中的值作为struct字面量打印。&lt;/p&gt;
&lt;p&gt;写struct字段时，仅仅在字段名称和类型之间插入一个空格即可，go fmt 会自动格式化。&lt;/p&gt;
&lt;h1 id=&#34;使用点运算符访问struct字段&#34;&gt;使用点运算符访问struct字段&lt;/h1&gt;
&lt;p&gt;我们使用点运算符来表示函数属于另一个包，或方法属于一个值。&lt;/p&gt;
&lt;p&gt;与此类似，可以使用点运算符来标识属于struct的字段，这也可以用于它们的赋值和检索。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myStruct struct {
        number float64
        word   string
        toggle bool
}
myStruct.number = 3.14
myStruct.word = &amp;#34;pie&amp;#34;
myStruct.toggle = &amp;#34;true&amp;#34;   //给struct字段赋值
fmt.Println(myStruct.number)  
fmt.Println(myStruct.word)
fmt.Println(myStruct.toggle)  //从struct字段取值
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在struct中保存订阅者的数据&#34;&gt;在struct中保存订阅者的数据&lt;/h1&gt;
&lt;p&gt;我们知道了如何声明一个保存了struct的变量和如何给字段赋值，可以创建一个来保存杂志订阅者的数据。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var subscriber struct {
        name   string
        rate   float64
        active bool
}
subscriber.name = &amp;#34;Aman Singh&amp;#34;
subscriber.rate = 4.99
subscriber.active = true
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber.name)
fmt.Println(&amp;#34;Monthly rate:&amp;#34;, subscriber.rate)
fmt.Println(&amp;#34;Active?&amp;#34;, subscriber.active)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;尽管订阅者的数据使用了多种方式存储，struct让我们把这些都集中在一个方便的包里。&lt;/p&gt;
&lt;h1 id=&#34;定义类型和struct&#34;&gt;定义类型和struct&lt;/h1&gt;
&lt;p&gt;定义struct变量很麻烦，定义每一个变量时需要重复整个struct类型声明。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var subscriber1 struct {
        name   string
        rate   float64
        active bool
}      //为subscriber1变量定义struct类型
subscriber1.name = &amp;#34;Aman Singh&amp;#34;
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber1.name)
var subscriber2 struct {
        name   string
        rate   float64
        active bool
}     //为subscriber2变量定义struct类型
subscriber2.name = &amp;#34;Beth Ryan&amp;#34;
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber2.name)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们已经使用了多种类型，像int、string、bool、切片、映射和struct，但是无法创建全新类型。&lt;/p&gt;
&lt;p&gt;类型定义允许自己创建新的类型，可以基于基础类型来创建新的定义类型。&lt;/p&gt;
&lt;p&gt;定义一个类型，需要使用&lt;code&gt;type&lt;/code&gt;关键字，后跟新类型的名字，然后是希望基于的基础类型，若使用struct类型作为基础类型，需要使用struct关键字，后跟以花括号包裹的一组字段定义，就像声明struct变量时一样。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/8-struct/type%e7%b1%bb%e5%9e%8b.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;与变量一样，类型定义可以被放在一个函数中，但把它的作用域限定在该函数块中，意味着不能在函数外面使用，所以类型经常定义在函数外的包级别。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type part struct {    //定义一个名为part的类型，part基础类型有下面这俩字段的结构体
	description string
	count       int
}   

type car struct {    //定义一个名为car的类型，car的基础类型是有下面这些字段的struct
	name     string
	topSpeed float64
}

func main() {
	var porsche car    //定义一个car类型的变量
	porsche.name = &amp;#34;Porsche 911 R&amp;#34;   //访问struct的字段
	porsche.topSpeed = 323
	fmt.Println(&amp;#34;Name:&amp;#34;, porsche.name)
	fmt.Println(&amp;#34;Top speed:&amp;#34;, porsche.topSpeed)

	var bolts part
	bolts.description = &amp;#34;Hex bolts&amp;#34;
	bolts.count = 24
	fmt.Println(&amp;#34;Description:&amp;#34;, bolts.description)
	fmt.Println(&amp;#34;Count:&amp;#34;, bolts.count)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当这些变量被声明后，可以设置这些字段的值和取回这些值。&lt;/p&gt;
&lt;h1 id=&#34;定义一个类型&#34;&gt;定义一个类型&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
        name    string
        rate    float64
        active  bool
}

func main() {
        var sub subscriber   //定义一个subscriber类型的变量
        sub.name = &amp;#34;Aman Singh&amp;#34;
        fmt.Println(&amp;#34;Name:&amp;#34;, sub.name)
        var sub2 subscriber  //使用subscriber类型定义第二个变量
        sub2.name = &amp;#34;Beth Ryan&amp;#34;
        fmt.Println(&amp;#34;Name:&amp;#34;, sub2.name)
        
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;与函数一起使用已定义类型&#34;&gt;与函数一起使用已定义类型&lt;/h1&gt;
&lt;p&gt;已定义类型可以用于变量类型以外的地方，也可以用于函数参数和返回值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type part struct {
	description string
	count       int
}

func showInfo(p part) { //声明一个以part作为类型的参数
	fmt.Println(&amp;#34;Description:&amp;#34;, p.description)
	fmt.Println(&amp;#34;Count:&amp;#34;, p.count)
}

func main() {
	var bolts part
	bolts.description = &amp;#34;Hex bolts&amp;#34;
	bolts.count = 24
	showInfo(bolts) //将part传递给函数
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数接受一个单独的参数，使用part作为参数的类型，在showInfo内部，可以像其他struct变量一样通过参数变量访问字段。&lt;/p&gt;
&lt;p&gt;还有一个minimumOrder函数来根据特定的描述创建part和预赋值其中的count字段，将minimumOrder的返回值类型定义为part，这样就能返回一个新的struct：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func minimumOrder(description string) part {  //声明一个part类型的返回值
        var p part    //创建一个part值
        p.description = description
        p.count = 100
        return p   //返回part
}

func main() {
        p := minimumOrder(&amp;#34;Hex bolts&amp;#34;)     //调用minimumOrder，使用一个变量的短声明来保存返回的part
        fmt.Println(p.description, p.count)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;下面例子，printInfo函数接受subscriber作为参数，并输出它的字段值，defaultSubscriber函数来建立一个新的subscriber struct并赋一些初始的值，它们接受一个名为name的字符串参数并用它来设置新的subscriber的name字段，然后把rate和active字段设置为默认值，最后将整个subscriber struce返回给调用者。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func printInfo(s subscriber) { //声明一个参数，使用subscriber类型
	fmt.Println(&amp;#34;Name:&amp;#34;, s.name)
	fmt.Println(&amp;#34;Monthly rate:&amp;#34;, s.rate)
	fmt.Println(&amp;#34;Active:&amp;#34;, s.active)
}

func defaultSubscriber(name string) subscriber { //返回一个subscriber值
	var s subscriber //创建一个新的subscriber
	s.name = name
	s.rate = 5.99
	s.active = true //设置struct字段
	return s        //返回subscriber
}

func main() {
	subscriber1 := defaultSubscriber(&amp;#34;Aman Singh&amp;#34;) //使用名字来建立一个subscriber
	subscriber1.rate = 4.99                        //使用一个特定的费率
	printInfo(subscriber1)                         //打印字段值
	subscriber2 := defaultSubscriber(&amp;#34;Beth Ryan&amp;#34;)  //使用名字来建立一个subscriber
	printInfo(subscriber2)                         //打印字段值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Name: Aman Singh
Monthly rate: 4.99
Active: true
Name: Beth Ryan
Monthly rate: 5.99
Active: true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在主函数中，可以将subscriber的名称传递给defaultSubscriber来创建一个新的subscriber struct，一个subscriber获取一个打折的费率，所以直接重设struct的字段，传递给一个已经填充完全的subscriber struct给printInfo函数来打印它的内容。&lt;/p&gt;
&lt;p&gt;不要使用一个已经存在的类型名称作为变量的名称！&lt;/p&gt;
&lt;h1 id=&#34;使用函数修改struct&#34;&gt;使用函数修改struct&lt;/h1&gt;
&lt;p&gt;go 是一个按值传递的语言，函数调用时接收的是一个参数的拷贝，若函数修改了参数值，其修改的只是拷贝，而不是原始值。&lt;/p&gt;
&lt;p&gt;对于 struct 也是一样。&lt;/p&gt;
&lt;p&gt;函数能够接收指针来代替直接接收值，当调用这个函数时，使用取址运算符&lt;code&gt;&amp;amp;&lt;/code&gt;来传送需要更新的值的指针，然后在函数内部，使用&lt;code&gt;*&lt;/code&gt;来更新指针指向的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        amount := 6
        double(&amp;amp;amount)   //传递一个指针来取代变量的值
        fmt.Println(amount)
}
func double(number *int) {  //接受一个指针来代替int值
        *number *= 2  //使用指针更新值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;12
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用指针来让函数也能更新struct：更新 s 参数类型来接受一个 subscriber struct 的指针，而不是直接使用struct，然后更新 struct 中的rate字段，在main中，调用applyDiscount并传入 subscriber struct 的指针，在输出rate字段时，能看到被更新成功。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func applyDiscount(s *subscriber) { //获取struct的指针，而不是struct
	s.rate = 4.99 //更新struct字段
}

func main() {
	var s subscriber
	applyDiscount(&amp;amp;s) //传入一个指针，而不是struct
	fmt.Println(s.rate)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在double函数中，需要使用 * 运算符来获取指针指向的值，当在applyDiscount函数中设置rate字段时不需要 * 吗？&lt;br&gt;
使用点运算符在struct指针和struct上都可以访问字段。&lt;/p&gt;
&lt;h1 id=&#34;通过指针访问struct的字段&#34;&gt;通过指针访问struct的字段&lt;/h1&gt;
&lt;p&gt;若尝试打印一个变量的指针，会看到其指向的内存地址：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var value int = 2
        var pointer *int = &amp;amp;value
        fmt.Println(pointer)  //输出的是指针不是值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;应该使用 &lt;code&gt;*&lt;/code&gt; 运算符，就像调用取值运算符一样，来获取指针指向的值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var value int = 2
        var pointer *int = &amp;amp;value
        fmt.Println(*pointer)  //输出指针指向的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以也需要对指向 struct 的指针使用 &lt;code&gt;*&lt;/code&gt; 运算符，但是直接把 &lt;code&gt;*&lt;/code&gt; 放到指针前是无法工作的，需要使用括号包裹。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type myStruct struct {
        myField int
}

func main() {
        var value myStruct
        value.myField = 3
        var pointer *myStruct = &amp;amp;value
        fmt.Println((*pointer).myField)   //获取指针指向的的struct值，然后访问struct的字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;点运算符允许通过struct的指针来访问字段，就像可以通过struct值直接访问一样，可以不需要括号和&lt;code&gt;*&lt;/code&gt;运算符。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var value myStruct
        value.myField = 3
        var pointer *myStruct = &amp;amp;value
        fmt.Println(pointer.myField)   //通过指针访问struct字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以通过指针来赋值给struct字段：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        var vaule myStruct
        var pointer *myStruct = &amp;amp;value
        pointer.myField = 9     //通过指针来赋值给struct字段
        fmt.Println(pointer.myField)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这就是上边 applyDiscount 函数可以更新struct字段而不用&lt;code&gt;*&lt;/code&gt;运算符，它通过struct指针赋值给rate字段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func applyDiscount(s *subscriber) { //获取struct的指针，而不是struct
	s.rate = 4.99 //通过指针赋值给struct字段
}

func main() {
	var s subscriber
	applyDiscount(&amp;amp;s) //传入一个指针，而不是struct
	fmt.Println(s.rate)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在设置struct字段前展示了defaultSubscriber函数，但是它不需要任何指针，这是为什么？&lt;br&gt;
答：defaultSubscriber函数返回了一个struct值，若调用者保存了返回的值，那么struct值中的字段同时会被保存。只有函数修改已经存在的struct而没有返回它们的时候需要使用指针来保存修改项。&lt;br&gt;
若需要时，defaultSubscriber可以返回一个struct的指针。&lt;/p&gt;
&lt;h1 id=&#34;使用指针传递大型struct&#34;&gt;使用指针传递大型struct&lt;/h1&gt;
&lt;p&gt;函数行参接收一个函数调用的实参的拷贝，即使是struct也是这样，若传递一个有很多字段的比较大的struct，会占用很多内存，会为原始的struct和被拷贝的struct都划分空间。&lt;/p&gt;
&lt;p&gt;除非struct字段少，否则要向函数传入struct的指针，即使函数并不修改struct也是如此。当传递一个struct指针时，内存中只有一个原始的struct，并可以读取、修改等操作，都不会产生一个额外的拷贝。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type subscriber struct {
	name   string
	rate   float64
	active bool
}

func printInfo(s *subscriber) { //获取指针
	fmt.Println(&amp;#34;Name:&amp;#34;, s.name)
	fmt.Println(&amp;#34;Monthly rate:&amp;#34;, s.rate)
	fmt.Println(&amp;#34;Active:&amp;#34;, s.active)
}

func defaultSubscriber(name string) *subscriber { //返回指针
	var s subscriber
	s.name = name
	s.rate = 5.99
	s.active = true
	return &amp;amp;s //返回一个指向struct的指针，而不是struct自己
}

func applyDiscount(s *subscriber) {
	s.rate = 4.99
}

func main() {
	subscriber1 := defaultSubscriber(&amp;#34;Aman Singh&amp;#34;) //一个struct指针
	applyDiscount(subscriber1)                     //由于这里已经是struct的指针，去掉取址运算符
	printInfo(subscriber1)
	subscriber2 := defaultSubscriber(&amp;#34;Beth Ryan&amp;#34;)
	printInfo(subscriber2)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里defaultSubscriber函数，更改为返回一个指针，且printInfo函数也改成接受一个指针，这些函数不需要像applyDiscount一样修改struct，使用指针确保对于每个struct值，只有一个拷贝在内存中，也能保证程序正常工作。&lt;/p&gt;
&lt;h1 id=&#34;将struct类型移动到另一个包&#34;&gt;将struct类型移动到另一个包&lt;/h1&gt;
&lt;p&gt;将type类型保存在magazine包中：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package magazine

type Subscriber struct {
        name   string
        Rate   float64
        active bool
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        var s magazine.Subscriber
        s.Rate = 4.99
        fmt.Println(s.Rate)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Go类型名称与变量和函数名称规则一样，首字母大写被认为可导出，可以从外部包来访问。&lt;/p&gt;
&lt;p&gt;从包中导出struct字段，字段名称的首字母也必须大写。&lt;/p&gt;
&lt;h1 id=&#34;struct字面量&#34;&gt;struct字面量&lt;/h1&gt;
&lt;p&gt;代码定义一个struct并且一个一个的赋值，很不友好，跟切片、映射一样，Go提供了struct字面量来让你创建一个struct并同时为其字段赋值。&lt;/p&gt;
&lt;p&gt;类型列在前，跟着一对花括号，在花括号内部，可以给一些或所有的struct字段赋值，使用字段名称、冒号和值，若定义多个字段，使用逗号分隔。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/8-struct/type%e5%ad%97%e9%9d%a2%e9%87%8f.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;使用struct字面量，创建Subscriber并设置值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;, Rate: 4.99, Active: true}
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber.Name)
fmt.Println(&amp;#34;Rate:&amp;#34;, subscriber.Rate)
fmt.Println(&amp;#34;Active:&amp;#34;, subscriber.Active)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不得不对struct变量使用长声明的方式（除非struct从一个函数中返回），struct字面量允许对刚创建的struct使用短变量声明。&lt;/p&gt;
&lt;p&gt;可以在花括号中忽略一些甚至所有的字段，被忽略的字段会被设置为它们的零值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber{Rate: 4.99}
fmt.Println(&amp;#34;Name:&amp;#34;, subscriber.Name)
fmt.Println(&amp;#34;Rate:&amp;#34;, subscriber.Rate)
fmt.Println(&amp;#34;Active:&amp;#34;, subscriber.Active)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Name:           //被忽略的字段获得了零值
Rate: 4.99
Active: false   //被忽略的字段获得了零值
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;创建一个employee-struct类型&#34;&gt;创建一个Employee struct类型&lt;/h1&gt;
&lt;p&gt;这个新的magazine包，在发布前，需要一个Employee strcut类型来追踪营业员的名称和薪水，并需要把邮件地址放到雇员和订阅者的结构中。&lt;/p&gt;
&lt;p&gt;在magazine包中增加一个类型：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pacakge magazine

type Subscriber struct {
        Name    string
        Rate    float64
        Active  bool
}

type Employee struct {
        Name    string
        Salary  float64
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        var emplpoyee magazine.Employee
        emplpoyee.Name = &amp;#34;Joy Carr&amp;#34;
        emplpoyee.Salary = 60000
        fmt.Println(emplpoyee.Name)
        fmt.Println(emplpoyee.Salary)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;创建一个address-struct类型&#34;&gt;创建一个Address struct类型&lt;/h1&gt;
&lt;p&gt;在Subscriber和Employee类型中增加一个地址，街道、城市、州、和邮编。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Subscriber struct {
        Name    string
        Rate    float64
        Active  bool
        Street  string
        City    string
        State   string
        PostalCode string
}

type Employee struct {
        Name    string
        Salary  float64
        Street  string
        City    string
        State   string
        PostalCode string
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是邮政地址都有相同的格式，无论属于哪个类型，将所有字段在多个类型中重复是痛苦的事情。&lt;/p&gt;
&lt;p&gt;struct字段可以保存任何类型，甚至是struct类型，所以我们创建一个Address struct 类型，然后在Subscriber和Employee类型中增加一个Address类型的字段，并且如果想要修改地址格式，可以保证类型之间的一致性。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Address struct {
        Street  string
        City    string
        State   string
        PostalCode string
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        var address magazine.Address
        address.Street = &amp;#34;123 Oak St&amp;#34;
        address.City = &amp;#34;Omaha&amp;#34;
        address.State = &amp;#34;NE&amp;#34;
        address.PostalCode = &amp;#34;12345&amp;#34;
        fmt.Println(address)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;将struct作为字段增加到另一个类型中&#34;&gt;将struct作为字段增加到另一个类型中&lt;/h1&gt;
&lt;p&gt;给 Subscriber 和 Employee 类型增加一个HomeAddress字段，在struct类型中增加一个struct类型字段与增加其他类型字段相同，字段名称和字段类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package magazine

type Address struct {
        Street  string
        City    string
        State   string
        PostalCode string
}

type Subscriber Struct {
        Name    string
        Rate    float64
        Active  bool
        HomeAddress Address
}

type Employee struct {
        Name    string
        Salary  float64
        HomeAddress Address
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在另一个struct中设置struct&#34;&gt;在另一个struct中设置struct&lt;/h1&gt;
&lt;p&gt;在Subscriber struct中设置 Address struct的字段值，这里有两种方式。&lt;/p&gt;
&lt;p&gt;第一种是创建一个独立的Address struct并使用它填充 Subscriber的整个Address字段：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
        address := magazine.Address{Street: &amp;#34;123 Oak St&amp;#34;, City: &amp;#34;Omaha&amp;#34;, State: &amp;#34;NE&amp;#34;, PostalCode: &amp;#34;12345&amp;#34;}
        subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}  //创建一个Address所属的Subscriber struct
        subscriber.HomeAddress = address    //设置HomeAddress字段
        fmt.Println(subscriber.HomeAddress)  //打印HomeAddress字段
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;另一种方法是通过外部struct来设置内部struct的字段。&lt;br&gt;
当一个Subscriber struct被创建后，其HomeAddress字段也被设置：它是一个Address struct，所有的字段都被设置为零值，若对fmt.Printf使用&amp;quot;%#v&amp;quot;动词来打印HomeAddress，会打印出它在go代码中的样子，也就是说像struct字面量一样，将看到每一个Address字段被设置为空字符串，也就是string类型的零值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber()
fmt.Printf(&amp;#34;%#v\n&amp;#34;, subscriber.HomeAddress)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;magazine.Address{Street:&amp;#34;&amp;#34;, City:&amp;#34;&amp;#34;, State:&amp;#34;&amp;#34;, PostalCode:&amp;#34;&amp;#34;}  //字段已经像Address struct一样被设置了，每一个字段都被设置为空字符串（字符串的零值）
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若subscriber是一个包含Subscriber struct的变量，当输入subscriber.HomeAddress时，会获得一个Address struct，即使没有明确设置HomeAddress。&lt;/p&gt;
&lt;p&gt;可以使用点运算符“链”的方式来访问Address struct中的字段，简单使用subscriber.HomeAddress来访问Address struct，后面跟另一个点运算符和想要访问的Address struct中的字段名称：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber.HomeAddress.City    //subscriber.HomeAddress 这部分返回一个Address struct，City 部分访问Address struct中的City部分
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在subscriber变量中保存一个Subscriber struct，在subscriber的HomeAddress字段中自动创建一个Address struct，设置subscriber.HomeAddress.Street、subscriber.HomeAddress.City和其他的值，然后输出这些值。然后在employee变量中保存Employee struct，并在HomeAddress struct中做相同操作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
	subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}
	subscriber.HomeAddress.Street = &amp;#34;123 Oak St&amp;#34;
	subscriber.HomeAddress.City = &amp;#34;Omaha&amp;#34;
	subscriber.HomeAddress.State = &amp;#34;NE&amp;#34;
	subscriber.HomeAddress.PostalCode = &amp;#34;12345&amp;#34;
	fmt.Println(&amp;#34;Subscriber Name:&amp;#34;, subscriber.Name)
	fmt.Println(&amp;#34;Street:&amp;#34;, subscriber.HomeAddress.Street)
	fmt.Println(&amp;#34;City:&amp;#34;, subscriber.HomeAddress.City)
	fmt.Println(&amp;#34;State&amp;#34;, subscriber.HomeAddress.State)
	fmt.Println(&amp;#34;Postal Code:&amp;#34;, subscriber.HomeAddress.PostalCode)

	// ...  //employee 省略
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;匿名struct字段&#34;&gt;匿名struct字段&lt;/h1&gt;
&lt;p&gt;通过外部struct访问内部struct的字段有点繁琐，想要访问内部struct字段的时候，不得不每次输入代表struct字段的名称。go允许定义一个匿名字段：struct字段没有名字，仅仅只有类型，可以使用匿名字段来让内部struct访问更简单。&lt;/p&gt;
&lt;p&gt;更新 Subscriber 和 Employee 类型，让HomeAddress字段作为一个匿名字段，只需移除字段名称，仅保留字段类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package magazine

type Subscriber struct {
        Name string
        Rate float64
        Active bool
        Address
}

type Employee struct {
        Name  string
        Salary float64
        Address   //删除字段名称（HomeAddress），仅保留类型
}

type Address struct {
        // Fields omitted
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当声明一个匿名字段时，可以使用字段类型名称作为字段名称，所以 subscriber.Address和 employee.Address在下面的代码中仍然访问Address struct：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}
subscriber.Address.Street = &amp;#34;123 Oak St&amp;#34;
subscriber.Address.City = &amp;#34;Omaha&amp;#34;
fmt.Println(&amp;#34;Street:&amp;#34;, subscriber.Address.Street)
fmt.Println(&amp;#34;City:&amp;#34;, subscriber.Address.City)
//...
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;嵌入struct&#34;&gt;嵌入struct&lt;/h1&gt;
&lt;p&gt;匿名字段不只是使struct定义中省略了字段名称。&lt;/p&gt;
&lt;p&gt;一个内部struct使用匿名字段的方式存储在了外部的struct中，这被称为嵌入了外部struct，嵌入struct的字段被提升到了外部struct，可以像访问外部struct的字段一样访问它们。&lt;/p&gt;
&lt;p&gt;所以Address struct类型被嵌入了Subscriber struct和Employee struct类型，不需要写下subscriber.Address.City来获取City字段，可以只写subscriber.City，不需要写下 employee.Address.State，可以只写employee.State。&lt;/p&gt;
&lt;p&gt;修改为将Address当作一个内嵌类型，可以将代码写成完全没有Address类型，就像Address的字段属于它嵌入的struct类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;xxx/xxx/magazine&amp;#34;
)

func main() {
	subscriber := magazine.Subscriber{Name: &amp;#34;Aman Singh&amp;#34;}
	subscriber.Street = &amp;#34;123 Oak St&amp;#34;
	subscriber.City = &amp;#34;Omaha&amp;#34;
	subscriber.State = &amp;#34;NE&amp;#34;
	subscriber.PostalCode = &amp;#34;12345&amp;#34;  //设置Address的字段就像它们在Subscriber上被定义过一样
	fmt.Println(&amp;#34;Subscriber Name:&amp;#34;, subscriber.Name)
	fmt.Println(&amp;#34;Street:&amp;#34;, subscriber.Street)
	fmt.Println(&amp;#34;City:&amp;#34;, subscriber.City)
	fmt.Println(&amp;#34;State&amp;#34;, subscriber.State)
	fmt.Println(&amp;#34;Postal Code:&amp;#34;, subscriber.PostalCode)

	...  //employee 省略

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不是必须内嵌内部struct，也不是必须使用内部struct，有时给外部struct增加新字段会使代码更干净。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>7.数据标签：映射</title>
      <link>https://tinklespring.com/posts/7.%E6%95%B0%E6%8D%AE%E6%A0%87%E7%AD%BE%E6%98%A0%E5%B0%84/</link>
      <pubDate>Sat, 22 Jul 2023 11:37:02 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/7.%E6%95%B0%E6%8D%AE%E6%A0%87%E7%AD%BE%E6%98%A0%E5%B0%84/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;当需要使用一个特定的值，为了找到它，需要从数组或切片中查看每一个元素，有一种集合，其中的每个值都有一个标签，那么就可以快速找到需要的值，&lt;code&gt;映射&lt;/code&gt;就是做这个工作的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;从文件中读取名字&#34;&gt;从文件中读取名字&lt;/h1&gt;
&lt;p&gt;有一个文件 votes.txt ：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Amber Graham
Brian Martin
Amber Graham
Brian Martin
Amber Graham
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每一行代表一次投票，需要处理文件的每一行并统计每个名称出现的总次数，获得多票的胜出。&lt;/p&gt;
&lt;p&gt;首先需要读取votes.txt文件的内容，之前有GetFloats函数来读取文件中的每一行，并转换为一个切片，但只能读取float64值，所以需要增加一个GetStrings函数，把每行作为string值添加到返回的切片中。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package datafile

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;os&amp;#34;
)

func GetStrings(fileName string) ([]string, error) {
	var lines []string
	file, err := os.Open(fileName)
	if err != nil {
		return nil, err
	}
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		lines = append(lines, line)
	}
	err = file.Close()
	if err != nil {
		return nil, err
	}
	if scanner.Err() != nil {
		return nil, scanner.Err()
	}
	return lines, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;xxx/xxx/datafile&amp;#34;
	&amp;#34;log&amp;#34;
)

func main() {
	lines, err: = datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(lines)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用困难的切片方法对名字计数&#34;&gt;使用困难的切片方法对名字计数&lt;/h1&gt;
&lt;p&gt;上述代码从文件中读取名字，如何计算名字出现了多少次？有两种方式，一种是切片，另一种是数据结构映射。&lt;/p&gt;
&lt;p&gt;关于使用切片的方式：创建两个切片，每个的长度都是元素的总个数，并是指定的顺序，第一个切片用来保存在文件中找到的名字，每个名字只出现一次，命名为 names；第二个切片命名为counts，保存文件中的名字出现的次数，元素 counts[0] 保存 names[0] 出现的次数，以次类推。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	lines, err := datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
	if err != nil {
		log.Fatal(err)
	}
	var names []string   //这个变量保存人名
	var counts []int     //这个变量保存每个人名出现的次数
	for _, line := range lines {
		matched := false
		for i, name := range names {   //循环处理names切片中的每一个值
			if name == line {      //若line与当前名称匹配
				counts[i]++    //增加对应的count值
				matched = true  //标识找到了匹配的名字
			}
		}
		if matched == false {       //若没有找到匹配名字
			names = append(names, line)  //添加它作为一个新名字
			counts = append(counts, 1)   //并增加一个新的计数（这行是第一次出现）
		}
	}
	for i, name := range names {
		fmt.Printf(&amp;#34;%s: %d\n&amp;#34;, name, counts[i])   //输出names切片中的每一个元素，和对应的counts切片中的元素
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序使用一个循环嵌套在另一个循环中的方式来统计名字的次数，外面的循环把文件中的每行以每次一行的方式赋值给line变量。内部循环通过遍历names切片中的每个元素来查找与文件中的当前行匹配的名称。&lt;/p&gt;
&lt;p&gt;若某人在选票上写一个名字，会导致文件中加载一个字符串，程序会一个一个确认names的元素中是否有等于这个名字。若没有找到匹配项，程序会在names切片末尾追加这个名字，并在counts切片中相应的位置增加1。假如下一行的这个名字已经存在于names切片中，程序会找到位置，在对应位置增加1。&lt;/p&gt;
&lt;h1 id=&#34;映射&#34;&gt;映射&lt;/h1&gt;
&lt;p&gt;保存名字使用的是切片，对于文件中的每一行，必须在许多names切片的值中寻找来进行比较，这样会导致性能差。&lt;/p&gt;
&lt;p&gt;go有一种方法保存数据集合： &lt;code&gt;映射&lt;/code&gt; 。 一个映射是通过&lt;code&gt;键&lt;/code&gt;来访问每一个值的集合，键是一个简单的方式从映射中找出数据。&lt;/p&gt;
&lt;p&gt;相对于数组和切片只能使用整型数字作为索引，映射可以使用任意类型的键（只要这个类型可以使用 == 来比较），包括数字、字符串和其他。所有的值只能是相同的类型，所有的健也需要是相同的类型，但是键和值的类型不必相同。&lt;/p&gt;
&lt;p&gt;声明一个保存映射的变量，需要 &lt;code&gt;map&lt;/code&gt; 关键字，后跟一对包含键类型的方括号&lt;code&gt;[]&lt;/code&gt;，然后在方括号后跟提供值的类型。&lt;br&gt;
&lt;code&gt;var myMap map[string]float64 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/7-%e6%98%a0%e5%b0%84/map%e8%af%ad%e6%b3%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;与切片一样，声明一个映射变量并不会自动创建一个映射，需要调用make函数（与创建切片相同的函数），可以传递给make想要创建的映射类型（与需要赋值到的类型相同）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var ranks map[string]int    //声明一个映射变量
ranks = make(map[string]int) //真正创建一个映射
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;短变量声明方式：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ranks := make(map[string]int)   //创建一个映射并声明一个用于保存它的变量
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;映射的赋值与取值语法跟数组和切片类似，但数组和切片仅允许使用整型作为元素索引，映射可以选择几乎所有的类型来作为键。&lt;/p&gt;
&lt;p&gt;这是一个名为ranks的映射：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ranks[&amp;#34;gold&amp;#34;] = 1
ranks[&amp;#34;silver&amp;#34;] = 2
ranks[&amp;#34;bronze&amp;#34;] = 3
fmt.Println(ranks[&amp;#34;bronze&amp;#34;])
fmt.Println(ranks[&amp;#34;gole&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个键和值都使用string的映射：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;elements := make(map[string]string)
elements[&amp;#34;H&amp;#34;] = &amp;#34;Hydrogen&amp;#34;
elements[&amp;#34;Li&amp;#34;] = &amp;#34;Lithium&amp;#34;
fmt.Println(elements[&amp;#34;Li&amp;#34;])
fmt.Println(elements[&amp;#34;H&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用整型作为键，bool类型作为值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;isPrime := make(map[int]bool)
isPrime[4] = false
isPrime[7] = true
fmt.Println(isPrime[4])
fmt.Println(isPrime[7])
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;映射字面量&#34;&gt;映射字面量&lt;/h1&gt;
&lt;p&gt;若预先知道映射的键和值，可以使用字面量来创建映射，映射字面量是以映射类型（以“映射[键类型]值类型”的形式）开始，后面跟花括号，内含想要映射初始就包含的 键/值 对。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;myMap := map[string]float64{&amp;#34;a&amp;#34;: 1.2, &amp;#34;b&amp;#34;: 5.6}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ranks := map[string]int{&amp;#34;bronze&amp;#34;: 3, &amp;#34;silver&amp;#34;: 2, &amp;#34;gold&amp;#34;: 1}
fmt.Println(ranks[&amp;#34;gold&amp;#34;])
fmt.Println(ranks[&amp;#34;bronze&amp;#34;])
elements := map[string]string{
        &amp;#34;H&amp;#34;: &amp;#34;Hydrogen&amp;#34;,
        &amp;#34;Li&amp;#34;: &amp;#34;Lithium&amp;#34;,
}   //多行映射字面量
fmt.Println(elements[&amp;#34;H&amp;#34;])
fmt.Println(elements[&amp;#34;Li&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与切片字面量一样，花括号为空创建一个空的映射：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;emptyMap := map[string]float64{}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;映射中的零值&#34;&gt;映射中的零值&lt;/h1&gt;
&lt;p&gt;对于数组和切片，若访问一个没有赋值过的键，会得到一个零值，根据值类型 不行，零值不一定是0。比如映射的值类型是string，零值就是空字符串。&lt;/p&gt;
&lt;p&gt;与数组和切片一样，零值可以更安全地修改映射的值，即使在没有给它赋值的情况下。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;counters := make(map[string]int)
counters[&amp;#34;a&amp;#34;]++
counters[&amp;#34;a&amp;#34;]++
counters[&amp;#34;c&amp;#34;]++
fmt.Println(counters[&amp;#34;a&amp;#34;], counters[&amp;#34;b&amp;#34;], counters[&amp;#34;c&amp;#34;])
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;映射变量的零值是nil&#34;&gt;映射变量的零值是nil&lt;/h1&gt;
&lt;p&gt;与切片一样，映射变量的零值是nil，若声明了一个映射变量但未赋值，是nil，意味着没有映射存在来增加键或值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var nilMap map[int]string
fmt.Printf(&amp;#34;%#v\n&amp;#34;, nilMap)
nilMap[3] = &amp;#34;three&amp;#34;   //映射是nil，无法添加新值，会导致panic
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在增加一个新的键值对前，需要使用make或映射字面量来创建一个映射，并赋值给映射变量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myMap map[int]string = make(map[int]string)
myMap[3] = &amp;#34;three&amp;#34;
fmt.Printf(&amp;#34;%#v\n&amp;#34;, myMap)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;如何区分已经赋值的值和零值&#34;&gt;如何区分已经赋值的值和零值&lt;/h1&gt;
&lt;p&gt;虽然零值很有用，但无法判断一个键是被赋值成了零值还是未赋值。&lt;/p&gt;
&lt;p&gt;有一个例子：错误输出了名为 Carl 的人没有通过，实际上并没有记录他的成绩。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func status(name string) {
        grades := map[string]float64{&amp;#34;Alma&amp;#34;: 0, &amp;#34;Rohit&amp;#34;: 86.5}
        grade := grades[name]
        if grade &amp;lt; 60 {
                fmt.Printf(&amp;#34;%s is failing!\n&amp;#34;, name)
        }
}
func main() {
        status(&amp;#34;Alma&amp;#34;)   //一个映射中已经被赋值为0的键
        status(&amp;#34;Carl&amp;#34;)   //一个映射中未被赋值的键
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Alma is failing!
Carl is failing!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为解决此问题，访问映射键的时候可选地获取第2个布尔类型的值，若这个键已经被赋过值，返回true，否则返回false。通常情况下，开发者会将这个布尔值赋给一个名为&lt;code&gt;ok&lt;/code&gt;的变量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;counters := map[string]int{&amp;#34;a&amp;#34;: 3, &amp;#34;b&amp;#34;, 0}
var value int
var ok bool
value, ok = counters[&amp;#34;a&amp;#34;]   //访问一个已经被赋值过的值
fmt.Println(value, ok)      //ok会返回true
value, ok = counters[&amp;#34;b&amp;#34;]   //访问一个已经被赋值过的值
fmt.Println(value, ok)      //ok会返回true
value, ok = counters[&amp;#34;c&amp;#34;]   //访问一个未赋值过的值
fmt.Println(value, ok)      //ok会返回false
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若仅仅要测试值是否存在，可以通过将其赋值给 &lt;code&gt;_&lt;/code&gt; 空白标识符来忽略值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;counters := map[string]int{&amp;#34;a&amp;#34;: 3, &amp;#34;b&amp;#34;: 0}
var ok bool
_, ok = counters[&amp;#34;b&amp;#34;]   //测试值是否存在，但忽略值
fmt.Println(ok)
_, ok = counters[&amp;#34;c&amp;#34;]   //测试值是否存在，但忽略值
fmt.Println(ok)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第二个返回值可以用来判断如何处理这个值，是已经赋值了但是正好等于零值，还是从未被赋值过。&lt;/p&gt;
&lt;p&gt;修改后：在输出不及格前测试请求的名字是否已经被赋值过。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func  status(name string) {
       grades := map[string]float64{&amp;#34;Alma&amp;#34;: 0, &amp;#34;Rohit&amp;#34;: 86.4}
       grade, ok := grades[name]
       if !ok {
               fmt.Printf(&amp;#34;No grade recorded for %s.\n&amp;#34;, name)
       } else if grade &amp;lt; 60 {
               fmt.Printf(&amp;#34;%s is failing!\n&amp;#34;, name)
       }
}

func main() {
       status(&amp;#34;Alma&amp;#34;)
       status(&amp;#34;Carl&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;练习：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;data := []string{&amp;#34;a&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;e&amp;#34;, &amp;#34;a&amp;#34;, &amp;#34;e&amp;#34;}   //需计算在切片中的每个字母的次数
counts := make(map[string]int)    //保存计数的映射
for _, item := range data {
        counts[item]++     //增加当前字母的次数
}    //处理每个字符
letters := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}   //是否这些字符都在映射中存在
for _, letter := range letters {
        count, ok := counts[letters]    //获取当前字符的计数以及是否出现的指示
        if !ok {   //如果字母未找到
                fmt.Printf(&amp;#34;%s: not found\n&amp;#34;, letter)
        } else {   //如果字母找到
                fmt.Printf(&amp;#34;%s: %d\n&amp;#34;, letter, count)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;a:2
b:not found
c:1
d:not found
e:2
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用delete函数删除键值对&#34;&gt;使用&amp;quot;delete&amp;quot;函数删除键/值对&lt;/h1&gt;
&lt;p&gt;在分配了值之后，某个时候希望将其从映射中移除，go提供了内建的&lt;code&gt;delete&lt;/code&gt;函数，只需传递给delete两个参数：希望删除数据的映射和希望删除的键，然后键和其关联的值都会被删除。&lt;/p&gt;
&lt;p&gt;如下代码，给两个映射的键分配了值，然后将其删除，之后，尝试访问，获取到零值。（对于ranks映射是0，对于isPrime映射是false）。第二个布尔返回值也是false，说明键已经被删除。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var ok bool
ranks := make(map[string]int)
var rank int
ranks[&amp;#34;bronze&amp;#34;] = 3   //给“bronze”键分配值
rank, ok = ranks[&amp;#34;bronze&amp;#34;]  //由于值存在，ok会返回true
fmt.Printf(&amp;#34;rank: %d, ok: %v\n&amp;#34;, rank, ok)
delete(ranks, &amp;#34;bronze&amp;#34;)   //删除键“bronze”和相关的值
rank, ok = ranks[&amp;#34;bronze&amp;#34;]   //由于值已经被删除了ok返回false
fmt.Printf(&amp;#34;rank: %d, ok: %v\n&amp;#34;, rank, ok)

isPrime := make(map[int]bool)
var prime bool
isPrime[5] = true  //给键5分配值
prime, ok = isPrime[5]  //由于值存在，ok会返回true
fmt.Printf(&amp;#34;prime: %v, ok: %v\n&amp;#34;, prime, ok)
delete(isPrime, 5)   //删除键5和相关的值
prime, ok = isPrime[5]   //由于值被删除，ok会返回false
fmt.Printf(&amp;#34;prime: %v, ok: %v\n&amp;#34;, prime, ok)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rank: 3, ok: true
rank: 0, ok: false
prime: true, ok: true
prime: false, ok: false
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用映射来更新程序&#34;&gt;使用映射来更新程序&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/datafile&amp;#34;
        &amp;#34;log&amp;#34;
)
func main() {
        lines, err := datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
        if err != nil {
                log.Fatal(err)
        }
        counts := make(map[string]int)   //声明一个以人名为键，次数为值的映射
        for _, line := range lines {
                counts[lines]++     //为人名增加计数
        }
        fmt.Println(counts)   //输出填充的映射
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;对映射进行forrange循环&#34;&gt;对映射进行&amp;quot;for&amp;hellip;range&amp;quot;循环&lt;/h1&gt;
&lt;p&gt;为了从映射中格式化每个键和值作为一行，需要使用循环遍历映射中的每一条。&lt;/p&gt;
&lt;p&gt;与数组和切片的 for&amp;hellip;range 循环一样，与将一个整数索引赋值给第一个变量不同，映射将键赋给了第一个变量。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/7-%e6%98%a0%e5%b0%84/%e6%98%a0%e5%b0%84for...range%e5%be%aa%e7%8e%af.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;for&amp;hellip;range 循环让遍历映射中的键和值更方便，仅用一个变量保存键，再用一个变量保存值，并会自动遍历映射中的每一个条目。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import &amp;#34;fmt&amp;#34;
func main() {
        grades := map[string]float64{&amp;#34;Alma&amp;#34;: 74.2, &amp;#34;Rohit&amp;#34;: 86.5, &amp;#34;Carl&amp;#34;: 59.7}
        for name, grade := range grades {
                fmt.Printf(&amp;#34;%s has a grade of %0.1f%%\n&amp;#34;, name, grade)  //打印每一个键和它对应的值
        }  //循环遍历每一个键/值对
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Carl has a grade of 59.7%
Alma has a grade of 74.2%
Rohit has a grade of 86.5%
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若只需要循环所有的键，可以忽略对应的值变量：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(&amp;#34;Class roster:&amp;#34;)
for name := range grades {
        fmt.Println(name)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Class roster:
Alma
Rohit
Carl
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若只需要值，可以将键赋 _ 空白标识符：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(&amp;#34;Grades:&amp;#34;)
for _, grade := range grades {
        fmt.Println(grade)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Grades:
59.7
74.2
86.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里有个问题，如果将之前的结果存入一个文件，并执行，会发现映射的键和值是按照随机顺序打印，若多次执行，每次的结果顺序是不一样的。&lt;/p&gt;
&lt;h1 id=&#34;forrange循环以随机顺序处理映射&#34;&gt;&amp;ldquo;for&amp;hellip;range&amp;quot;循环以随机顺序处理映射&lt;/h1&gt;
&lt;p&gt;for&amp;hellip;range 以随机的顺序遍历映射的键和值，因为映射是一个非有序的键/值对集合。但有时需要按照特定的顺序遍历时，要自己写一些代码了。&lt;/p&gt;
&lt;p&gt;例子：使名字按照字母表的顺序输出，使用了两个for循环，第一个循环遍历映射里边所有的键，忽略值，并把其增加到一个字符串的切片上，然后把切片传递给sort包中的Strings函数来以字母表顺序排序。第二个for循环并不遍历映射，而是遍历变量排序后的名字的切片，输出名字，并从映射中获取与名字对应的值，仍然处理映射中的每一个键和值，但是从已排序好的切片中获取而不是从映射中获取的键。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;sort&amp;#34;
)

func main() {
        grades := map[string]float64{&amp;#34;Alma&amp;#34;: 74.2, &amp;#34;Rohit&amp;#34;: 86.5, &amp;#34;Carl&amp;#34;: 59.7}
        var names []string
        for name := range grades {
                names = append(names, name)
        }
        sort.Strings(names)
        for _, name := range names {
                fmt.Printf(&amp;#34;%s has a grade of %0.1f%%\n&amp;#34;, name, grades[name])
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按照以上代码执行，名字是按照字母表顺序排列，不管执行多少次都是如此。&lt;/p&gt;
&lt;p&gt;若不在乎映射中的数据如何处理，使用for&amp;hellip;range循环就可以，但若是需要顺序，就需要自己写代码处理排序问题。&lt;/p&gt;
&lt;h1 id=&#34;使用forrange更新程序&#34;&gt;使用for&amp;hellip;range更新程序&lt;/h1&gt;
&lt;p&gt;将打印整个映射的行用for&amp;hellip;range替换，把键赋给name变量，把映射的值赋值给count变量，然后用printf输出人命和得票数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
        &amp;#34;fmt&amp;#34;
        &amp;#34;xxx/xxx/datafile&amp;#34;
        &amp;#34;log&amp;#34;
)

func main() {
        lines, err := datafile.GetStrings(&amp;#34;votes.txt&amp;#34;)
        if err != nil {
                log.Fatal(err)       
        }
        counts := make(map[string]int)
        for _, line := range lines {
                counts[line]++
        }
        for name, count := range counts {
                fmt.Printf(&amp;#34;Votes for %s: %d\n&amp;#34;, name, count)
        }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当可用的数据集合是数组和切片时，需要很多额外的代码和处理时间来查找，但使用映射处理起来更简便。&lt;/p&gt;
&lt;p&gt;当需要查找集合中的值的时候，可以考虑映射！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>6.切片</title>
      <link>https://tinklespring.com/posts/6.%E5%88%87%E7%89%87/</link>
      <pubDate>Tue, 18 Jul 2023 11:42:00 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/6.%E5%88%87%E7%89%87/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;切片是一个可以通过增长来保存额外数据的集合类型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;切片&#34;&gt;切片&lt;/h1&gt;
&lt;p&gt;切片实际上是一个go的数据结构，与数组相同的是，切片由多个相同类型的元素构成，不同的是，切片允许在结尾追加更多的元素。&lt;/p&gt;
&lt;p&gt;声明一个保存切片的变量，使用一对空方括号，后面跟着这个切片所保存的元素类型 : &lt;code&gt;var mySlice []string&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;除了不指定大小，与声明一个数组变量的语法完全相同。&lt;/p&gt;
&lt;p&gt;与数组变量不同，声明切片变量并不会自动创建一个切片，可以调用内建的&lt;code&gt;make&lt;/code&gt;函数，传递给&lt;code&gt;make&lt;/code&gt;想要创建的切片类型（这个类型与想要赋值的变量的类型相同）和需要创建的切片的长度。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var notes []string   //声明一个切片变量
notes = make([]string, 7)  //创建7个字符串的切片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当切片被创建后，切片中的元素的赋值和取值操作语法与数组相同。&lt;/p&gt;
&lt;p&gt;无需将变量声明和创建切片分成两步，使用一个短变量声明的make会自动推导出变量类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;primes := make([]int, 5)
primes[0] = 2
primes[1] = 3
fmt.Println(primes[0])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;内建的函数&lt;code&gt;len&lt;/code&gt;对切片和数组有相同效果，将一个切片变量传入len，会返回一个整型的长度值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := make([]string, 7)
primes := make([]int, 5)
fmt.Println(len(notes))
fmt.Println(len(primes))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;for&lt;/code&gt;与&lt;code&gt;for...range&lt;/code&gt;数组与切片操作也相同。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;letters := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;}
for i := 0; i &amp;lt; len(letters); i++ {
       fmt.Println(letters[i])
}
for _, letter := range letters {
       fmt.Println(letter)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;切片字面量&#34;&gt;切片字面量&lt;/h1&gt;
&lt;p&gt;与数组相同，若最初知道切片有哪些值，可以使用切片字面量来通过这些值初始化切片。&lt;/p&gt;
&lt;p&gt;切片字面量方括号是空的，后跟切片存储的元素的类型，再跟一个花括号的列表，列表中是每个元素的初始值。&lt;br&gt;
&lt;code&gt;[]int{9, 18, 27}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := []string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
fmt.Println(notes[3], notes[6], notes[0])
primes := []int{
       2,
       3,
       5,
}
fmt.Println(primes[0], primes[1], primes[2])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fa ti do
2 3 5
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;切片运算符&#34;&gt;切片运算符&lt;/h1&gt;
&lt;p&gt;每个切片都构建在一个底层的数组之上，实际上是底层的数组存储了切片的数据；切片仅仅是数组中的一部分（或者所有）元素的视图。&lt;/p&gt;
&lt;p&gt;当使用 &lt;code&gt;make&lt;/code&gt; 函数或者切片字面量创建一个切片的时候，底层的数组会自动创建出来（只有通过切片，才能访问它），但也可以创建一个数组，然后再基于数组通过切片运算符创建一个切片。  &lt;code&gt;mySlice := myArray[1:3]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;切片运算符有两个索引：其中一个标识切片开始的位置，另一个标识切片在此位置之前结束。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;underlyingArray := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slicel := underlyingArray[0:3]
fmt.Println(slicel)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出： &lt;code&gt;[a b c]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：切片需要在第二个位置之前结束。  比如 underlyingArray[i:j] ，生成的切片从 underlyingArray[i] 到 underlyingArray[j-1]。&lt;/p&gt;
&lt;p&gt;若想要一个包含了底层数组最后一个元素的切片，需要在运算符中指定越过数组结尾的第二个索引。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;underlyingArray := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slice3 := underlyingArray[2:5]
fmt.Println(slice3)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出： &lt;code&gt;[c d e]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;切片运算符默认需要两个索引，若忽略第一个索引，第一个元素会被使用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;underlyingArray := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slice4 := underlyingArray[:3]
fmt.Println(slice4)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;code&gt;[a b c]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;若忽略了结束的索引，从底层数组的开始索引到数组结尾之间的所有元素都会被包含到结果切片中。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;underlyingArray := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slice5 := underlyingArray[1:]
fmt.Println(slice5)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;code&gt;[b c d e]&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;底层数组&#34;&gt;底层数组&lt;/h1&gt;
&lt;p&gt;切片并不会自己保存任何数据，仅仅是底层数组元素的视图。当使用切片的时候，仅仅可以操作通过切片可见的部分。&lt;/p&gt;
&lt;p&gt;甚至可以有多个切片都指向相同的底层数组，每一个切片会是一个指向数组元素的子集的视图，切片甚至可以重叠。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;array3 := [5]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;}
slice3 := array3[0:3]
slice4 := array4[2:5]
fmt.Println(slice3, slice4)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;修改底层数组修改切片&#34;&gt;修改底层数组，修改切片&lt;/h1&gt;
&lt;p&gt;注意：由于切片只是底层数组内容的视图，若修改底层数组，这些变化也会反映到切片。&lt;/p&gt;
&lt;p&gt;给切片的一个元素赋一个新值，也会修改底层数组相应的元素。&lt;/p&gt;
&lt;p&gt;若有多个切片指向了同一个底层数组，数组的元素修改会反映给所有的切片。&lt;/p&gt;
&lt;p&gt;由于这些问题，通常我们会使用 &lt;code&gt;make&lt;/code&gt; 和 &lt;code&gt;切片字面量&lt;/code&gt; 来创建切片，而不是创建一个数组，再用一个切片在上面操作。  使用了 make 和 切片字面量 就不用关心底层数组了。&lt;/p&gt;
&lt;h1 id=&#34;使用append函数在切片上添加数据&#34;&gt;使用&amp;quot;append&amp;quot;函数在切片上添加数据&lt;/h1&gt;
&lt;p&gt;go 提供一个内建的函数 &lt;code&gt;append&lt;/code&gt; 来将一个或多个值追加到切片的末尾，它返回一个与原始切片元素完全相同的并且在尾部追加了新元素的新的更大的切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;slice := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;}
fmt.Println(slice, len(slice))
slice = append(slice, &amp;#34;c&amp;#34;)      //在切片末尾追加一个元素
fmt.Println(slice, len(slice))  //将append返回值赋回相同的切片变量
slice = append(slice, &amp;#34;d&amp;#34;, &amp;#34;e&amp;#34;)
fmt.Println(slice, len(slice))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[a b] 2
[a b c] 3
[a b c d e] 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;无需记住需要追加到尾部的新值的索引，仅仅调用append函数并且传入切片和需要追加到末尾的值，就会得到一个新的更长的切片。&lt;/p&gt;
&lt;p&gt;注意需要确保将append返回的值重新赋给传递给append的那个变量，这是为了避免append返回的切片中的一些不一致行为。&lt;/p&gt;
&lt;p&gt;切片的底层数组不能增长大小，若数组没有足够的空间来保存新的元素，所有的元素会被拷贝到一个新的更大的数组中，且切片会被更新为引用这个新的数组，但由于这些场景都发生在append函数内部，无法知道返回的切片与传入append函数的切片是否具有相同的底层数组，若保留了两个切片，会导致一些非预期的错误。&lt;/p&gt;
&lt;p&gt;调用append函数，惯例是将函数的返回值赋给传入的那个切片变量，若只保存一个切片，就无需考虑多个切片是否共享同一个底层数组。&lt;/p&gt;
&lt;h1 id=&#34;切片和零值&#34;&gt;切片和零值&lt;/h1&gt;
&lt;p&gt;与数组一样，若访问了一个切片中没有赋值的元素，会得到那个元素类型的零值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;floatSlice := make([]float64, 10)
boolSlice := make([]bool, 10)    //创建元素没有赋值的切片
fmt.Println(floatSlice[9], boolSlice[5])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: &lt;code&gt;0 false&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;与数组不同，切片变量有零值：nil，一个没有赋值的切片变量值为 nil。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var intSlice []int
var stringSlice []string
fmt.Printf(&amp;#34;intSlice: %#v, stringSlice: %#v\n&amp;#34;, intSlice, stringSlice)   //&amp;#34;%#v&amp;#34;把值格式化为它在go代码中呈现的样子
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在其他语言中，需要在使用切片变量前先测试是否包含切片，但在go中，函数有意被写成对待nil的切片就像它是一个空切片一样。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Println(len(intSlice))  //把nil切片传递给len函数，返回0，就像传入一个空的切片
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;append函数也会把nil切片看作是一个空的切
片，若append传入了空的切片，会在切片里增加一个元素并返回只有一个元素的切片。 若传入nil切片，也会得到只有一个元素的切片。实际上并没有一个切片来追加元素，append函数会在幕后创建一个切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;intSlice = append(intSlice, 27)   //向append传入一个nil切片
fmt.Printf(&amp;#34;intSlice: %#v\n&amp;#34;, intSlice)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;stringSlice: []string(27)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;意味着通常无需担心切片是nil还是空的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var slice []string   //变量值是nil
if len(slice) == 0 {   //len函数返回0
       slice = append(slice, &amp;#34;first item&amp;#34;)   //append函数会返回一个元素的切片
}
fmt.Printf(&amp;#34;%#v\n&amp;#34;, slce)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[]string{&amp;#34;first item&amp;#34;}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用切片和append读取额外的文件行&#34;&gt;使用切片和&amp;quot;append&amp;quot;读取额外的文件行&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func GetFloats(fileName string) ([]float64, error) {    //返回一个切片
       var numbers []float64     //该变量默认为nil，append处理nil的行为与处理空切片一样
       file, err := os.Open(fileName)
       if err != nil {
              return numbers, err
       }
       scanner := bufio.NewScanner(file)
       for scanner.Scan() {
              number, err := strconv.ParseFloat(scanner.Text(), 64)   //将string转换为float64且赋值给一个临时变量
	      if err != nil {
                     return numbers, err
	      }
              numbers = append(numbers, number)   //追加新的数字给切片
       }
       err = file.Close()
       if err != nil {
              return numbers, err
       }
       if scanner.Err() != nil {
              return numbers, scanner.Err()
       }
       return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不必修改主程序中任何代码，因为使用&lt;code&gt;:=&lt;/code&gt;短变量声明，来将GetFloats函数的返回值赋给一个变量，numbers变量自动从[3]float64 (数组类型) 切换到 []float64 (切片类型)，并且 for&amp;hellip;range 循环和len函数对于数组和切片的行为是一致的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;xxx/xxx/datafile&amp;#34;
)

func main() {
	numbers, err := datafile.GetFloats(&amp;#34;data.txt&amp;#34;)  //自动获得一个[]float64来代替[3]float64
	if err != nil {
		log.Fatal(err)
	}
	var sum float64 = 0
	for _, number := range numbers {
		sum += number
	}
	sampleCount := float64(len(numbers))
	fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, sum/sampleCount)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;出错时返回nil值切片&#34;&gt;出错时返回nil值切片&lt;/h1&gt;
&lt;p&gt;进一步优化Getfloats函数，当前，即使出现错误也会返回一个numbers切片，这意味着会返回一个包含无效数据的切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;numbers, err := strconv.ParseFloat(scanner.Text(), 64)
if err != nil {
return numbers, err  //返回了一个不该被使用的无效数据
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用GetFloats的代码应该检查返回的错误值，若不是nil则需要忽略返回的切片。那为啥还要多此一举返回一个包含无效数据的切片？接下来修改GetFloats函数，让函数出错时返回一个nil代替之前的包含无效数据的切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func GetFloats(fileName string) ([]float64, error) {
       var numbers []float64
       file, err := os.Open(fileName)
       if err != nil {
              return nil, err   //返回nil而不是切片，切片在此处的值也是nil，但修改使之更显而易见
       }
       scanner := bufio.NewScanner(file)
       for scanner.Scan() {
              number, err := strconv.ParseFloat(scanner.Text(), 64)
	      if err != nil {
                     return nil, err   //返回nil而不是切片
	      }
              numbers = append(numbers, number)
       }
       err = file.Close()
       if err != nil {
              return nil, err  //返回nil而不是切片
       }
       if scanner.Err() != nil {
              return nil, scanner.Err()  //返回nil而不是切片
       }
       return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;命令行参数&#34;&gt;命令行参数&lt;/h1&gt;
&lt;p&gt;每当要计算一个新的平均数时，都要修改data.txt，有一种替代方案：用户把值作为命令行参数传递给程序。&lt;/p&gt;
&lt;p&gt;就像通过传入不同的参数来控制函数的行为一样，在终端传递参数给程序，这叫做&lt;code&gt;命令行接口&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;从osargs切片获取命令行参数&#34;&gt;从&amp;quot;os.Args&amp;quot;切片获取命令行参数&lt;/h1&gt;
&lt;p&gt;os 包有一个包级别的变量 os.Args , 是一个字符串的切片，代表了当前执行程序的命令行参数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;os&amp;#34;
)

func main() {
       fmt.Println(os.Args)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;比如将上述代码编译后，运行:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;./xxx a b c d e

输出：
[./xxx a b c d e]
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;切片运算符可用于其他切片&#34;&gt;切片运算符可用于其他切片&lt;/h1&gt;
&lt;p&gt;上述 ./xxx 是程序的名字，我们并不想要，解决：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;os&amp;#34;
)

func main() {
       fmt.Println(os.Args[1:])    //获取一个包含os.Args的从第二个元素到最后一个元素的新的切片
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样就避免了上述问题。&lt;/p&gt;
&lt;h1 id=&#34;使用命令行参数&#34;&gt;使用命令行参数&lt;/h1&gt;
&lt;p&gt;在 os.Args 上使用切片运算符来忽略程序名称，并把返回切片赋给一个 arguments 变量，设置一个 sum 变量来保存所有输入数字的和，然后使用 for&amp;hellip;range 循环来处理 arguments 的元素（使用 _ 空白标识符来忽略元素索引）。使用strconv.ParseFloat 来将参数从字符串转换为 float64 ，若出现错误，输出并退出，若无错误，将数字累加到 sum。 当循环处理完所有参数时，用 len(arguments) 来确定样本个数，然后用 sum 除以样本个数得到平均值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;os&amp;#34;
	&amp;#34;strconv&amp;#34;
)

func main() {
	arguments := os.Args[1:]             //通过os.Args获取一个不包含首元素的字符串切片
	var sum float64 = 0                  //定义一个保存数字的累加值
	for _, argument := range arguments { //处理命令行的每一个参数
		number, err := strconv.ParseFloat(argument, 64) //将字符串转换为float64
		if err != nil {
			log.Fatal(err)
		} //若转换函数出现问题则输出log并退出
		sum += number //累加数字
	}
	sampleCount := float64(len(arguments))          //参数的长度可以用作样本的个数
	fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, sum/sampleCount) //计算平均值并进行打印
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;可变长参数函数&#34;&gt;可变长参数函数&lt;/h1&gt;
&lt;p&gt;一些函数调用可以获取任何个数的参数，例如 fmt.Println 或 append 。但不要直接在任何函数中使用，定义的所有函数的参数个数与函数调用的参数个数要严格匹配，否则会导致编译错误。&lt;/p&gt;
&lt;p&gt;那么 Println 与 append 是如何做到的呢？因为它定义了一个&lt;code&gt;可变长参数函数&lt;/code&gt;，一个可变长参数函数可以以多种参数个数来调用，为了让函数的参数可变长，在函数声明中的最后的（或仅有的）参数类型前使用省略号&lt;code&gt;...&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func myFunc(param1 int, param2 ...string) {
       //function code here
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;可变长参数函数的最后一个参数接收一个切片类型的变长参数&lt;/code&gt;，这个切片可以被函数当作普通切片来处理。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func severalInts(numbers ...int) {
       fmt.Println(numbers)
}

func main() {
       severalInts(1)
       severalInts(1, 2, 3)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有一个带有字符串参数的函数，若不提供变长参数，不会返回错误，会收到一个空切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func severalStrings(strings ...string) {
       fmt.Println(strings)
}

func main() {
       severalStrings(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;)
       severalStrings()   //若没有参数，会收到一个空的切片
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;函数也可以接收一个或多个非可变长参数，即使一个函数调用可以忽略可变长参数，其中的非可变长参数是不可忽略的，若忽略会导致编译失败。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;只有函数定义中的最后一个参数是可变长参数&lt;/code&gt; ，不能放到其他必需参数前。&lt;/p&gt;
&lt;h1 id=&#34;使用可变长参数函数&#34;&gt;使用可变长参数函数&lt;/h1&gt;
&lt;p&gt;maximum 函数会接收任意个数的float64参数并会返回其中的最大值，这个函数的所有参数被保存在一个切片类型的参数 numbers 中，初始设置当前最大值为 -Inf ，一个代表了负无穷的特殊值，通过调用math.Inf获得。（可以使用当前最大值0，但这个最大值可能是负数），然后使用 for&amp;hellip;range 来处理 numbers 上的每个值，将其与最大值比较。若大于最大值，将其设置为最大值，处理完所有参数后剩下的最大值就是要返回的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;math&amp;#34;
)

func maximum(numbers ...float64) float64 {  //接收任何个数的float64参数
	max := math.Inf(-1)   //以一个很小的值开始
	for _, number := range numbers {
		if number &amp;gt; max {
			max = number   //找到参数中的最大值
		}
	}   //处理变长参数的每一个值
	return max
}

func main() {
	fmt.Println(maximum(71.8, 56.2, 89.5))
	fmt.Println(maximum(90.7, 89.7, 98.5, 92.3))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&amp;ldquo;inRange&amp;quot;函数，接收一个最小值，一个最大值和任何个数的float64参数，丢弃在给定最小值和给定最大值范围之外的参数，返回一个在范围之内的参数值的切片。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func inRange(min float64, max float64, numbers ...float64) []float64 {
	var result []float64   //这个切片会保存范围内的值
	for _, number := range numbers {
		if number &amp;gt;= min &amp;amp;&amp;amp; number &amp;lt;= max {
			result = append(result, number)
		}
	}
	return result
}

func main() {
	fmt.Println(inRange(1, 100, -12.5, 3.2, 0, 50, 103.5))   //寻找&amp;gt;=1且&amp;lt;=100的参数
	fmt.Println(inRange(-10, 10, 4.1, 12, -12, -5.2))   //寻找&amp;gt;=-10且&amp;lt;=10的参数
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用可变长参数函数计算平均值&#34;&gt;使用可变长参数函数计算平均值&lt;/h1&gt;
&lt;p&gt;来创造一个可以接收任意多个float64类型参数，并返回它们的平均值的可变长参数函数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func average(numbers ...float64) float64 {  //获取任意个数的float64参数
	var sum float64 = 0   //定义一个变量来保存参数的总和
	for _, number := range numbers {
		sum += number
	}
	return sum / float64(len(numbers))
}

func main() {
	fmt.Println(average(100, 50))
	fmt.Println(average(90.7, 89.7, 98.5, 92.3))
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;向可变长参数函数传递一个切片&#34;&gt;向可变长参数函数传递一个切片&lt;/h1&gt;
&lt;p&gt;将numbers切片传递给average函数。&lt;/p&gt;
&lt;p&gt;当调用一个可变长参数函数时，在传入的切片变量后增加省略号&lt;code&gt;...&lt;/code&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func severalInts(numbers ...int) {
       fmt. Println(numbers)
}
func mix(num int, flag bool, strings ...string) {
       fmt.Println(num, flag, strings)
}
func main() {
       intSlice := []int{1, 2, 3}
       severalInts(intSlice...)   //使用int切片代替可变参数
       stringsSlice := []string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;, &amp;#34;d&amp;#34;}
       mix(1, true, stringsSlice...)   //使用string切片代替可变参数
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;log&amp;#34;
       &amp;#34;os&amp;#34;
       &amp;#34;strconv&amp;#34;
)

func average(numbers ...float64) float64 {
	var sum float64 = 0
	for _, number := range numbers {
		sum += number
	}
	return sum / float64(len(numbers))
}

func main() {
        arguments := os.Args[1:]
        var numbers []float64  //该切片保存了将要被计算平均值的数字
	for _, argument := range arguments {
               number, err := strconv.ParseFloat(argument, 64)
	       if err != nil {
                      log.Fatal(err)
	       }
               numbers = append(numbers, number)
	}
        fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, average(numbers...))  //向可变参数函数传入切片
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会把命令行参数转换为float64的切片，然后传递给可变参数的average函数。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>5.数组</title>
      <link>https://tinklespring.com/posts/5.%E6%95%B0%E7%BB%84/</link>
      <pubDate>Sat, 15 Jul 2023 10:11:00 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/5.%E6%95%B0%E7%BB%84/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;go 有两种内置的存储列表的方式，本篇介绍其中一种：数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;数组保存值的集合&#34;&gt;数组保存值的集合&lt;/h1&gt;
&lt;p&gt;数组是所有共享同一类型的值的集合。&lt;/p&gt;
&lt;p&gt;数组中包含的值称为它的&lt;code&gt;元素&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以有一个字符串数组、一个布尔数组或其他类型的数组（甚至数组的数组）。&lt;/p&gt;
&lt;p&gt;可以将整个数组存储在单个变量中，然后访问数组中所需要的任何元素。&lt;/p&gt;
&lt;p&gt;数组保存特定数量的元素，不能增长或收缩，要声明保存数组的变量，需要在方括号&lt;code&gt;[]&lt;/code&gt;中指定它所保存的元素数量，后跟数组所保存的元素类型。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/5-%e6%95%b0%e7%bb%84/%e5%a3%b0%e6%98%8e%e6%95%b0%e7%bb%84.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;要设置数组元素的值或稍后检索值，需要一种方法来指定哪个元素，数组中的元素从0开始编号，一个元素的编号称为其&lt;code&gt;索引&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如，创建一个由7个字符串组成的数组：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var notes [7]string
notes[0] = &amp;#34;do&amp;#34;    //给第一个元素赋值
notes[1] = &amp;#34;re&amp;#34;
notes[2] = &amp;#34;mi&amp;#34;
fmt.Println(notes[0])   //打印第一个元素
fmt.Println(notes[1])   //打印第二个元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个整型数组：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var primes [5]int
primes[0] = 2
primes[1] = 3
fmt.Println(primes[0])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;time.Time值的数组：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var dates [3]time.Time
dates[0] = time.Unix(1257894000, 0)
dates[1] = time.Unix(1447920000, 0)
dates[2] = time.Unix(1508632200, 0)
fmt.Println(dates[1])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出: &lt;code&gt;2015-11-19 08:00:00 +0000 UTC&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;数组中的零值&#34;&gt;数组中的零值&lt;/h1&gt;
&lt;p&gt;与变量一样，当创建一个数组时，其所包含的所有值都被初始化为该数组所保存类型的零值。默认情况下，一个 int 值数组用0填充。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var primes [5]int
primes[0] = 2
fmt.Println(primes[0])   //打印显示赋值的元素
fmt.Println(primes[2])   //打印未显式赋值的元素
fmt.Println(primes[4])   //打印未显式赋值的元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2
0
0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字符串的零值是一个空字符串，默认情况下，一个字符串值数组用空字符串填充。&lt;/p&gt;
&lt;p&gt;零值可以使操作数组元素变得安全，即使没有显式为其赋值。 &lt;br&gt;
例如：一个整数计数器数组，可以在不首先显式赋值的情况下给它们中任何一个赋值，因为其都是从0开始。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var counters [3]int
counters[0]++    //将第一个元素从0增加到1
counters[0]++    //将第一个元素从1增加到2
counters[2]++    //将第三个元素从0增加到1
fmt.Println(counters[0], counters[1], counters[2])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2
0
1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建数组时，其所包含的所有值都初始化为数组所保存类型的零值。&lt;/p&gt;
&lt;h1 id=&#34;数组字面量&#34;&gt;数组字面量&lt;/h1&gt;
&lt;p&gt;若事先知道数组应该保存哪些值，可以使用数组字面量来初始化数组。数组字面量的开头与数组类型类似，其元素的数量将放在方括号中，后跟元素的类型，再后面跟大括号，里面是每个元素应该具有的初始值列表，元素值用逗号分隔。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/5-%e6%95%b0%e7%bb%84/%e6%95%b0%e7%bb%84%e5%ad%97%e9%9d%a2%e9%87%8f.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;与之前不同，不是逐个为数组元素赋值，而是使用数组字面量初始化整个数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;数组字面量&lt;/code&gt;允许使用短变量声明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
primes := [5]int{2, 3, 5, 7, 11}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以将数组字面量分散到多行上，但必须在代码中的每个换行字符前使用逗号，若数组字面量的最后一项后面跟着换行符，需要在其后面跟一个逗号。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;text := [3]string{
       &amp;#34;this is a series of long strings&amp;#34;,
       &amp;#34;which would be awkward to place&amp;#34;,
       &amp;#34;together on a single line&amp;#34;,    //末尾的逗号是必须的。
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;fmt包中的函数如何处理数组&#34;&gt;&amp;ldquo;fmt&amp;quot;包中的函数如何处理数组&lt;/h1&gt;
&lt;p&gt;当只想调试代码时，不必逐个将数组元素传递给fmt包中的Println和其他函数，只需传递整个数组。fmt包有做格式化和打印数组的逻辑。（fmt包还可以处理切片、映射和其他数据结构）&lt;/p&gt;
&lt;p&gt;Printf和Sprintf函数使用的&amp;rdquo;%#v&amp;quot;动词，将按照go代码中显示的方式格式化值，当用&amp;quot;%#v&amp;quot;格式化时，数组在结果中显示为go数组字面量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var notes [3]string = [3]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;}
var primes [5]int = [5]int{2, 3, 5, 7, 11}
fmt.Printf(&amp;#34;%#v\n&amp;#34;, notes)
fmt.Printf(&amp;#34;%#v\n&amp;#34;, primes)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[3]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;}
[5]int{2, 3, 5, 7, 11}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在循环里访问数组元素&#34;&gt;在循环里访问数组元素&lt;/h1&gt;
&lt;p&gt;不必显示地编写代码中要访问的数组元素的整数索引。 可以使用整型变量中的值作为数组索引。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
index := 1
fmt.Println(index, notes[index])  //打印索引1处的数组元素
index = 3
fmt.Println(index, notes[index])  //打印索引3处的数组元素
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这意味着可以使用for循环来处理数组元素之类的操作，循环遍历数组中的索引，并使用循环变量访问当前索引处的元素。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for i := 0; i &amp;lt;= 2; i++ {
       fmt.Println(i, notes[i])
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用len函数检查数组长度&#34;&gt;使用&amp;quot;len&amp;quot;函数检查数组长度&lt;/h1&gt;
&lt;p&gt;写只访问有效数组索引的循环容易出错，有两种方式。&lt;/p&gt;
&lt;p&gt;第一种是在访问数组前检查数组中元素的的实际数量，可以使用内置的&lt;code&gt;len&lt;/code&gt;函数来实现，该函数返回数组的长度（其包含的元素个数）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
fmt.Println(len(notes))   //打印“notes”数组的长度
primes := [5]int{2, 3, 5, 7, 11}
fmt.Println(len(primes))  //打印“primes”数组的长度
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置循环以处理整个数组时，可以使用&lt;code&gt;len&lt;/code&gt;确定哪些索引可以安全访问。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for i := 0; i &amp;lt; len(notes); i++ {
       fmt.Println(i, notes[i])
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若len(notes)返回7，可访问的索引最多是6，因为数组索引从0开始。&lt;/p&gt;
&lt;h1 id=&#34;使用forrange安全遍历数组&#34;&gt;使用&amp;quot;for&amp;hellip;range&amp;quot;安全遍历数组&lt;/h1&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/5-%e6%95%b0%e7%bb%84/forrange.png&#34;
        alt/&gt;&lt;br&gt;
在range格式中，提供一个变量，该变量保存每个元素的整数索引，另一个变量保存元素本身的值，以及要循环的数组，循环将为数组中的每个元素运行一次，将元素的索引赋值给第一个变量，将元素的值赋值给第二个变量，然后在循环块中添加代码处理这些值。&lt;/p&gt;
&lt;p&gt;这种for循环形式没有混乱的初始化、条件和标志（post）表达式，由于元素值是自动分配给变量的，因此不会有意外访问无效数组索引的风险。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for index, note := range notes {
       fmt.Println(index, note)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于每个元素，index变量设置为元素的索引，note变量设置为元素的值。&lt;/p&gt;
&lt;h1 id=&#34;在forrange循环中使用空白标识符&#34;&gt;在&amp;quot;for&amp;hellip;range&amp;quot;循环中使用空白标识符&lt;/h1&gt;
&lt;p&gt;go 要求使用声明的每个变量，若停止使用&lt;code&gt;for...range&lt;/code&gt;循环中的变量，将编译错误。&lt;/p&gt;
&lt;p&gt;当调用一个具有多个返回值的函数时，忽略其中一个返回值，将该值赋值给空白标识符&lt;code&gt;_&lt;/code&gt;，这会让go丢弃该值，而不会编译错误。&lt;/p&gt;
&lt;p&gt;若不需要每个数组元素的索引，可以：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for _, note := range notes {
       fmt.Println(note)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若不需要值变量，也可以使用空白标识符：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;notes := [7]string{&amp;#34;do&amp;#34;, &amp;#34;re&amp;#34;, &amp;#34;mi&amp;#34;, &amp;#34;fa&amp;#34;, &amp;#34;so&amp;#34;, &amp;#34;la&amp;#34;, &amp;#34;ti&amp;#34;}
for index, _ := range notes {
       fmt.Println(index)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;获得数组中数字的平均值&#34;&gt;获得数组中数字的平均值&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
	numbers := [3]float64{71.8, 56.2, 89.5}
	var sum float64 = 0
	for _, number := range numbers {
		sum += number
	}
	sampleCount := float64(len(numbers))            //获取类型为int的数组长度，并将其转换为float64
	fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, sum/sampleCount) //将数组值的总和除以数组长度得到平均值
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;读取文本文件&#34;&gt;读取文本文件&lt;/h1&gt;
&lt;p&gt;编辑一个data.txt文件，将三个数据写进去：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;71.8
56.2
89.5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先编写一个读取文件的程序：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;os&amp;#34;
)

func main() {
	file, err := os.Open(&amp;#34;data.txt&amp;#34;) //打开文件进行读取
	if err != nil {
		log.Fatal(err)
	} //若打开文件时出现错误，报告错误并退出
	scanner := bufio.NewScanner(file) //为文件创建一个新的扫描器
	for scanner.Scan() {              //从文件中读取一行
		fmt.Println(scanner.Text()) //打印该行
	} //循环至文件结尾，scanner.Scan返回false
	err = file.Close() //关闭文件以释放资源
	if err != nil {
		log.Fatal(err)
	} //若关闭文件时出现错误，报告错误并退出
	if scanner.Err() != nil {
		log.Fatal(scanner.Err())
	} //若扫描文件时出现错误，报告错误并退出
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述程序如何工作：&lt;br&gt;
首先向 os.Open 函数传递一个带有要打开文件的名字的字符串，从 os.Open 会返回两个值：指向代表被打开文件的 os.File 值的指针，以及一个错误值。若错误值为 nil ，则表示文件成功打开，其他任何值都表示存在错误（比如文件丢失或不可读）。若错误，则会记录错误信息并退出程序。&lt;/p&gt;
&lt;p&gt;然后将 os.File 值传递给 bufio.NewScanner 函数，将返回一个从文件中读取的 bufio.Scanner 值。&lt;/p&gt;
&lt;p&gt;bufio.Scanner 上的 Scan 方法是用来作为 for 循环的一部分。将从文件中读取一行文本，若读取数据成功则返回 true ，否则返回 false 。若将 Scan 用作 for 循环的条件，那么只要有更多的数据需要读取，循环就会继续运行，一旦到达文件的结尾（或出现错误），Scan 将返回 false ，循环退出。&lt;/p&gt;
&lt;p&gt;在 bufio.Scanner 上调用 Scan 方法后，调用 Text 方法将返回一个包含已经读取数据的字符串，对这个程序，调用 Println 打印每一行。&lt;/p&gt;
&lt;p&gt;一旦循环退出，就完成了对文本的处理，保持文件打开会消耗操作系统的资源，因此当程序完成对文件操作时要对文件进行关闭。对 os.File 调用 Close 方法将完成对文件的关闭。与 Open 函数一样，Close 方法也返回一个 error 值，除非出现错误，否则该值为 nil ，（与 Open 不同，Close 只返回一个值，除了错误外没有其他值可以返回）。&lt;/p&gt;
&lt;p&gt;在扫描文件时，bufio.Scanner 也可能遇到错误，调用扫描器上的 Err 方法将返回该错误，在退出之前记录该错误。&lt;/p&gt;
&lt;h1 id=&#34;将文本数据读入数组&#34;&gt;将文本数据读入数组&lt;/h1&gt;
&lt;p&gt;需要将data.txt读取的字符串转换为数字并存储在数组中: &lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/5-%e6%95%b0%e7%bb%84/%e5%b0%86%e6%96%87%e4%bb%b6%e8%af%bb%e5%85%a5%e6%95%b0%e7%bb%84.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// Package datafile allows reading data sample from files.
package datafile

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;os&amp;#34;
	&amp;#34;strconv&amp;#34;
)

// GetFloats reads a float64 from each line of a file.
func GetFloats(fileName string) ([3]float64, error) {
	var numbers [3]float64
	file, err := os.Open(fileName)
	if err != nil {
		return numbers, err
	}
	i := 0
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		numbers[i], err = strconv.ParseFloat(scanner.Text(), 64)
		if err != nil {
			return numbers, err
		}
		i++
	}
	err = file.Close()
	if err != nil {
		return numbers, err
	}
	if scanner.Err() != nil {
		return numbers, scanner.Err()
	}
	return numbers, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;希望能读取除了data.txt意外的文件，因此接受打开的文件名作为参数，将函数设置为返回两个值，一个float64值数组和一个错误值。只有当错误值为nil时，才应将第一个返回值视为可用。&lt;/p&gt;
&lt;p&gt;接下来，声明一个由三个float64值组成的数组，将保存从文件中读取的数字。&lt;/p&gt;
&lt;p&gt;与之前代码一样，打开文件进行读取，不同之处在于，打开传递给函数的任何文件名，而不是硬编码的 &amp;ldquo;data.txt&amp;rdquo; 字符串，若遇到错误，需要返回一个数组以及错误值，所以只返回numbers数组（尽管还没有为其赋值）。&lt;/p&gt;
&lt;p&gt;需要知道将每一行赋值给哪个数组元素，因此创建一个变量来跟踪当前索引。&lt;/p&gt;
&lt;p&gt;设置bufio.Scanner和循环遍历文件行的代码与之前的代码相同，但是循环的代码不同，需要对从文件中读取的字符串调用 strconv.ParseFloat 来将其转换为 float64 ，并将结果赋值给数组。若ParseFloat导致了错误，需要返回该错误，若解析成功，需要对 i 增值，以便下一个数被赋值给下一个数组元素。&lt;/p&gt;
&lt;p&gt;关闭文件并报告任何错误，若没有错误，将到达 GetFloats 函数末尾，并返回float64值数组以及nil错误。&lt;/p&gt;
&lt;h1 id=&#34;更新程序读取文本文件&#34;&gt;更新程序读取文本文件&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;xxx/xxx/datafile&amp;#34;
       &amp;#34;log&amp;#34;
)

func main() {
       numbers, err := datafile.GetFloats(&amp;#34;data.txt&amp;#34;)
       if err != nil {
              log.Fatal(err)
       }
       var sum float64 = 0
       for _, number := range numbers {
              sum += number
       }
       sampleCount := float64(len(numbers))
       fmt.Printf(&amp;#34;Average: %0.2f\n&amp;#34;, sum/sampleCount)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述程序只有在data.txt中有三行或更少行时才运行，若超过三行则会报错。  因为声明了 numbers 数组来保存3个元素。&lt;/p&gt;
&lt;p&gt;Go数组的大小是固定的，不能增长或收缩。下一篇将解决这个问题！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>4.代码集：包</title>
      <link>https://tinklespring.com/posts/4.%E4%BB%A3%E7%A0%81%E9%9B%86%E5%8C%85/</link>
      <pubDate>Tue, 11 Jul 2023 15:57:40 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/4.%E4%BB%A3%E7%A0%81%E9%9B%86%E5%8C%85/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;到目前位置，一直将代码放在一个文件里，随着程序变得越来越大、越来越复杂，这会是一个大问题～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;使用包在程序之间共享代码&#34;&gt;使用包在程序之间共享代码&lt;/h1&gt;
&lt;p&gt;将共享函数移到新的包中！&lt;/p&gt;
&lt;p&gt;golang允许定义自己的包，包是一组代码，fmt包格式化输出，math包处理数字，strings包处理字符串，已经在多个程序中使用了来自每一个包的函数。&lt;/p&gt;
&lt;p&gt;能够在程序之间使用相同的代码是包存在的主要原因之一。&lt;/p&gt;
&lt;h1 id=&#34;go工作区目录保存包代码&#34;&gt;go工作区目录保存包代码&lt;/h1&gt;
&lt;p&gt;工作区目录包含三个子目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bin ：保存已编译的二进制可执行程序；&lt;/li&gt;
&lt;li&gt;pkg ：保存已编译的二进制包文件；&lt;/li&gt;
&lt;li&gt;src ：保存go的源代码；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在src中，每个包的代码都位于它自己单独的子目录中，按照惯例，子目录名应与包名相同。&lt;/p&gt;
&lt;p&gt;每个包目录应该包含一个或多个源代码文件，文件名不重要，但要以 &lt;code&gt;.go&lt;/code&gt; 结尾。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/4-%e4%bb%a3%e7%a0%81%e9%9b%86-%e5%8c%85/go%e5%b7%a5%e4%bd%9c%e5%8c%ba%e7%9b%ae%e5%bd%95.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建一个新包&#34;&gt;创建一个新包&lt;/h1&gt;
&lt;p&gt;做一个简单的包：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
└── src
    └── greeting
        └── greeting.go
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与所有go源代码文件一样，这个文件以package行开始，与其他代码不同，这段代码不是main包的一部分，是一个名为greeting的包的一部分。还有两个函数定义，希望这些函数可以在greeting包之外访问，所以需要首字母大写：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package greeting

import &amp;#34;fmt&amp;#34;

func Hello() {
	fmt.Println(&amp;#34;Hello!&amp;#34;)
}
func Hi() {
	fmt.Println(&amp;#34;Hi!&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;将包导入程序&#34;&gt;将包导入程序&lt;/h1&gt;
&lt;p&gt;在程序中使用新包：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
└── src
    ├── greeting
    │   └── greeting.go
    └── hi
        └── main.go
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与每个go源代码文件一样，这段代码从package开始，但希望这是一个可执行的命令，需要使用main的包名。&lt;/p&gt;
&lt;p&gt;通常，包名应与所在目录名保持一致，但是main包例外。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;greeting&amp;#34;

func main() {
	greeting.Hello()
	greeting.Hi()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;导入greeting包，该目录名与 import 语句中的名称相匹配。&lt;/p&gt;
&lt;h1 id=&#34;包使用相同的文件布局&#34;&gt;包使用相同的文件布局&lt;/h1&gt;
&lt;p&gt;与main包一样，都要有三部分结构： package 子句、import 语句、实际代码。&lt;/p&gt;
&lt;h1 id=&#34;包命名规范&#34;&gt;包命名规范&lt;/h1&gt;
&lt;p&gt;每次调用包中的函数时都要输入包名，包名遵循以下规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包名应全部为小写；&lt;/li&gt;
&lt;li&gt;若含义明显，应缩写；&lt;/li&gt;
&lt;li&gt;尽可能是一个词，若是两个词，不应该用下划线分隔，第二个词也不应该大写；&lt;/li&gt;
&lt;li&gt;导入的包名避免与本地变量名冲突；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;包限定符&#34;&gt;包限定符&lt;/h1&gt;
&lt;p&gt;当访问从不同包导出的函数、变量或其他东西时，需要通过在函数或变量钱输入包名来限定其名称；当访问定义在当前包中的函数或变量时，不应该限定包名。&lt;/p&gt;
&lt;h1 id=&#34;常量&#34;&gt;常量&lt;/h1&gt;
&lt;p&gt;许多包导出常量：从不更改的命名值。&lt;/p&gt;
&lt;p&gt;声明常量看起来像变量声明，具有名称、可选的类型和常量值，不同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;const&lt;/code&gt;关键字而不是var关键字；&lt;/li&gt;
&lt;li&gt;必须在声明常量时赋值，不能像变量那样后赋值；&lt;/li&gt;
&lt;li&gt;变量有短变量声明语法，常量没有；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与变量声明一样，可以省略类型，将从分配的值推断：&lt;code&gt;const SquareSides = 4&lt;/code&gt; ;&lt;/p&gt;
&lt;p&gt;变量的值可以变化，但常量值必须保持不变。&lt;/p&gt;
&lt;p&gt;与变量和函数一样，名称以大写字母开头的常量是可导出的。&lt;/p&gt;
&lt;h1 id=&#34;嵌套的包目录和导入路径&#34;&gt;嵌套的包目录和导入路径&lt;/h1&gt;
&lt;p&gt;可以将类似的包组嵌套在go工作区的一个目录中，然后该目录将成为它包含的所有包的导入路径的一部分。&lt;br&gt;
&lt;img  src=&#34;https://tinklespring.com/img/Golang/4-%e4%bb%a3%e7%a0%81%e9%9b%86-%e5%8c%85/%e5%b5%8c%e5%a5%97%e5%8c%85%e7%9b%ae%e5%bd%95%e4%b8%8e%e5%af%bc%e5%85%a5%e8%b7%af%e5%be%84.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用go-install安装程序可执行文件&#34;&gt;使用&amp;quot;go install&amp;quot;安装程序可执行文件&lt;/h1&gt;
&lt;p&gt;与go build 不同，go install 以包含代码的目录来命名可执行文件。将存储在工作区中名为 bin 的目录中。&lt;/p&gt;
&lt;h1 id=&#34;设置gopath&#34;&gt;设置GOPATH&lt;/h1&gt;
&lt;p&gt;GOPATH 是一个环境变量，go工具会参考它来查找工作区位置。大多数开发者将所有代码都保存在一个工作区中，但也可以使用 GOPATH 将工作区转移到其他目录。&lt;/p&gt;
&lt;p&gt;若代码存储在默认目录之外的地方，需要设置GOPATH: &lt;code&gt;export GOPATH=&amp;quot;/xxxx/xxx&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;发布包&#34;&gt;发布包&lt;/h1&gt;
&lt;p&gt;可以在git等仓库中保存代码，这样其他开发人员就可以在自己的项目中使用它。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
       &amp;#34;fmt&amp;#34;
       &amp;#34;github.com/abc/defg&amp;#34;
       &amp;#34;log&amp;#34;
)

func main() {
       fmt.Print(&amp;#34;xxxxxx&amp;#34;)
       grade, err := defg.GetFloat()
       if err != nil {
              log.Fatal(err)
       }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用go-get下载和安装包&#34;&gt;使用&amp;quot;go get&amp;quot;下载和安装包&lt;/h1&gt;
&lt;p&gt;使用包所在的URL作为导入路径，可以使用&lt;code&gt;go get&lt;/code&gt;自动下载和安装包：&lt;code&gt;go get github.com/abc/defg&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;go将连接到github，下载存储库并将其保存在go工作区的src目录中。&lt;/p&gt;
&lt;h1 id=&#34;使用go-doc阅读包文档&#34;&gt;使用&amp;quot;go doc&amp;quot;阅读包文档&lt;/h1&gt;
&lt;p&gt;可以使用 &lt;code&gt;go doc&lt;/code&gt; 命令来显示关于任何包或函数的文档。&lt;br&gt;
例如: &lt;code&gt;go doc strconv&lt;/code&gt;   &lt;code&gt;go doc strconv ParsetFloat&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用doc注释记录包&#34;&gt;使用doc注释记录包&lt;/h1&gt;
&lt;p&gt;若希望用户看到有关包或函数的文档，需要自己添加。&lt;/p&gt;
&lt;p&gt;只需在代码中添加文档注释，直接出现在package子句或函数声明之前的普通go注释将被视为文档注释，将显示在go doc 的输出中。&lt;/p&gt;
&lt;p&gt;添加文档注释时，需要遵循一些惯例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注释应该是完整的句子；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包注释应以 &lt;code&gt;Package&lt;/code&gt; 开头，后跟包名；
&lt;code&gt;Package mypackage enable widget management&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数注释应以其描述的函数的名称开头；
&lt;code&gt;MyFunction converts widget to gizmos&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以通过缩进在注释中包含代码示例；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了代码示例的缩进，不要为了强调或格式化添加额外的标点符号。文档注释将显示为纯文本，并以这种方式进行格式化；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;在web浏览器中查看文档&#34;&gt;在web浏览器中查看文档&lt;/h1&gt;
&lt;p&gt;可以在搜索引擎中搜索。&lt;/p&gt;
&lt;h1 id=&#34;使用godoc提供html文档&#34;&gt;使用&amp;quot;godoc&amp;quot;提供HTML文档&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;godoc&lt;/code&gt; 工具根据主要的go安装和工作区中的代码生成HTML文档。&lt;/p&gt;
&lt;p&gt;可以在web服务器模式运行 godoc ：&lt;code&gt;godoc -http=:8880&lt;/code&gt; ，然后可以在浏览器中访问：&lt;code&gt;http://localhost:8880/pkg&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;godoc服务器包含你的包&#34;&gt;&amp;ldquo;godoc&amp;quot;服务器包含你的包&lt;/h1&gt;
&lt;p&gt;除了来自go标准库的包之外，godoc 还为go工作区中的任何包构建HTML文档，这些包有可能是第三方的包，也可能是自己写的包。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3.函数</title>
      <link>https://tinklespring.com/posts/3.%E5%87%BD%E6%95%B0/</link>
      <pubDate>Thu, 29 Jun 2023 11:14:17 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/3.%E5%87%BD%E6%95%B0/</guid>
      <description>&lt;h1 id=&#34;printf-与-sprintf-格式化输出&#34;&gt;Printf 与 Sprintf 格式化输出&lt;/h1&gt;
&lt;p&gt;Printf 代表“带格式的打印”，接受一个字符串并将一个或多个值插入其中，以特定的方式进行格式化，然后打印结果字符串。&lt;br&gt;
Sprintf函数（也是fmt包的一部分）的工作方式与Printf 类似，不过返回格式化的字符串而不是打印。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Printf(&amp;#34;About one-third: %0.2f\n&amp;#34;, 1.0/3.0)
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;resultString := fmt.Sprintf(&amp;#34;About one-third: %0.2f\n&amp;#34;, 1.0/3.0)
fmt.Printf(resultString)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Printf的两个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;格式化动词（字符串中的%0.2f是动词）&lt;/li&gt;
&lt;li&gt;值的宽度（动词中间的0.2）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;格式化动词&#34;&gt;格式化动词&lt;/h1&gt;
&lt;p&gt;Printf第一个参数是一个字符串，用于格式化输出，大部分格式与字符串中显示的格式完全相同，但是任何 &lt;code&gt;%&lt;/code&gt; 都将被视为格式化动词的开始，字符串的一部分将被特定格式的值所替换，其余参数用作这些动词的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%&lt;/code&gt; 后面的字母表示要使用哪个动词，常见动词：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;动词&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;输出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%f&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;浮点数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%d&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;十进制整数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%s&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%t&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;布尔值（true或false）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%v&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任何值（根据所提供的值的类型选择适当的格式）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%#v&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;任何值，按其在go程序代码中显示的格式进行格式化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%T&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;所提供值的类型（int、string）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;%%&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;一个完全的百分号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Printf(&amp;#34;A float: %f\n&amp;#34;, 3.1415)
fmt.Printf(&amp;#34;An integer: %d\n&amp;#34;, 15)
fmt.Printf(&amp;#34;A string: %s\n&amp;#34;, &amp;#34;hello&amp;#34;)
fmt.Printf(&amp;#34;A boolean: %t\n&amp;#34;, false)
fmt.Printf(&amp;#34;Values: %v %v %v\n&amp;#34;, 1.2, &amp;#34;\t&amp;#34;, true)
fmt.Printf(&amp;#34;Values: %#v %#v %#v\n&amp;#34;, 1.2, &amp;#34;\t&amp;#34;, true)
fmt.Printf(&amp;#34;Types: %T %T %T\n&amp;#34;, 1.2, &amp;#34;\t&amp;#34;, true)
fmt.Printf(&amp;#34;Percent sign: %%\n&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;A float: 3.141500
An integer: 15
A string: hello
A boolean: false
Values: 1.2       true
Values: 1.2  &amp;#34;\t&amp;#34; true
Types: float64 string bool
Percent sign: %
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确保使用 \n 转义序列在每个格式化字符串的末尾添加一个换行符，因为与Println不同，Printf不会自动添加新行。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Printf(&amp;#34;%v %v %v&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;\t&amp;#34;, &amp;#34;\n&amp;#34;)
fmt.Printf(&amp;#34;%#v %#v %#v&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;\t&amp;#34;, &amp;#34;\n&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
&amp;#34;&amp;#34; &amp;#34;\t&amp;#34; &amp;#34;\n&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;%#v 可以显示一些值，不实用%#v，这些值可能会在输出中隐藏，上述 空字符串、制表符、换行符，在 %v 打印时是不可见的。&lt;/p&gt;
&lt;h1 id=&#34;格式化宽度&#34;&gt;格式化宽度&lt;/h1&gt;
&lt;p&gt;可以在格式化动词的百分号后面指定最小宽度，若该动词参数比最小宽度短，则使用空格填充。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Printf(&amp;#34;%12s | %s\n&amp;#34;, &amp;#34;Product&amp;#34;, &amp;#34;Cost in Cents&amp;#34;)
fmt.Printf(&amp;#34;%12s | %s\n&amp;#34;, &amp;#34;Stamps&amp;#34;, 50)
fmt.Printf(&amp;#34;%12s | %s\n&amp;#34;, &amp;#34;Paper Clips&amp;#34;, 5)
fmt.Printf(&amp;#34;%12s | %s\n&amp;#34;, &amp;#34;Tape&amp;#34;, 99)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;     Product | Cost in Cents
      Stamps | 50
 Paper Clips |  5
        Tape | 99
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;格式化小数宽度&#34;&gt;格式化小数宽度&lt;/h1&gt;
&lt;p&gt;整个数的最小宽度包括数字位和小数点，若包括，较短的数将在开始处填充空格，直到达到这个宽度，若省略，则不会添加任何空格。&lt;br&gt;
小数点后的宽度是要显示的小数位数，若是更精确的数字，将被四舍五入。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;fmt.Printf(&amp;#34;%%7.3f: %7.3f\n&amp;#34;, 12.3456)
fmt.Printf(&amp;#34;%%7.2f: %7.2f\n&amp;#34;, 12.3456)
fmt.Printf(&amp;#34;%%7.1f: %7.1f\n&amp;#34;, 12.3456)
fmt.Printf(&amp;#34;%%.1f: %.1f\n&amp;#34;, 12.3456)
fmt.Printf(&amp;#34;%%.2f: %.2f\n&amp;#34;, 12.3456)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;%7.3f:   12.346
%7.2f:    12.35
%7.1f:     12.3
%.1f:  12.3
%.2f:  12.35
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;%.2f&lt;/code&gt; 将允许取任意精度的浮点数，并将它们四舍五入到小数点后两位。（不会做任何不必要的填充）。&lt;/p&gt;
&lt;h1 id=&#34;声明函数&#34;&gt;声明函数&lt;/h1&gt;
&lt;p&gt;声明以func关键字开头，后面跟希望函数具有的名称、一对圆括号()，然后是包含函数代码的块。&lt;br&gt;
一旦声明了一个函数，就可以在包的其他地方调用，只需输入函数名，后面跟一对圆括号。当执行此操作时，函数快中的代码就会运行。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main
import &amp;#34;fmt&amp;#34;
func sayHi() {
       fmt.Println(&amp;#34;Hi!&amp;#34;)
}
func main() {
       sayHi()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当调用当前包中定义的函数时，不应该指定包名，（输入 main.sayHi() 将导致编译错误）。&lt;/p&gt;
&lt;p&gt;函数名的规则与变量名的规则相同：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;名称必须以 &lt;code&gt;字母开头&lt;/code&gt; ，后跟任何数量的数字和字母；&lt;/li&gt;
&lt;li&gt;名称以 &lt;code&gt;大写字母&lt;/code&gt; 开头的函数是可导出的，且可以在当前包之外使用；&lt;/li&gt;
&lt;li&gt;名称以 &lt;code&gt;小写字母&lt;/code&gt; 开头的函数是不可导出的，只能在当前包中使用；&lt;/li&gt;
&lt;li&gt;名称包含多个单词应符合驼峰式大小写；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;声明函数参数&#34;&gt;声明函数参数&lt;/h1&gt;
&lt;p&gt;若希望对函数的调用包含参数，则需声明一个或多个参数，&lt;code&gt;参数是函数的局部变量，其值是在调用函数时设置的。&lt;/code&gt;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
	repeatLine(&amp;#34;hello&amp;#34;, 3)
}
func repeatLine(line string, times int) {
	for i := 0; i &amp;lt; times; i++ {
		fmt.Println(line)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在函数声明中的圆括号中声明一个或多个参数，用逗号分隔，与变量一样，需要为声明的每个参数提供一个名称，后面跟一个类型（float64、bool等）。&lt;/p&gt;
&lt;p&gt;若函数定义了参数，那么在调用时需要传递一组匹配的参数。当函数运行时，每个参数都将被设置为对应参数中的值的副本，然后这些参数值在函数块的代码中被使用。&lt;/p&gt;
&lt;h1 id=&#34;使用函数&#34;&gt;使用函数&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func paintNeeded(width float64, height float64) {
	area := width * height
	fmt.Printf(&amp;#34;%.2f liters needed\n&amp;#34;, area/10.0)
}
func main() {
	paintNeeded(4.2, 3.0)
	paintNeeded(5.2, 3.5)
	paintNeeded(5.0, 3.3)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;函数和变量的作用域&#34;&gt;函数和变量的作用域&lt;/h1&gt;
&lt;p&gt;上述在paintNeeded函数块中声明了一个area变量，与条件块和循环块一样，函数块中声明的变量只在该函数块的作用域内。&lt;/p&gt;
&lt;p&gt;与条件块和循环块一样，在函数外部声明的变量将在该函数块的作用域内，这意味着可以在包级别上声明一个变量，并且可以在包中的任何函数内访问。&lt;/p&gt;
&lt;h1 id=&#34;函数返回值&#34;&gt;函数返回值&lt;/h1&gt;
&lt;p&gt;函数总是返回特定类型的值（只返回该类型），若要声明函数返回值，在函数声明中的参数后面添加该返回值类型，在函数块中使用 &lt;code&gt;return&lt;/code&gt; 关键字，后面跟要返回的值。函数的调用者可以将返回值分配给一个变量，直接将它传递给另一个函数，或用它做任何其他需要做的事。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func double(number float64) float64 {
	return number * 2
}
func main() {
	dozen := double(6.0)
	fmt.Println(dozen)
	fmt.Println(double(4.2))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当 return 语句运行时，函数立即退出，不运行它后面的任何代码，可以将其与if语句一起使用，在没有必要运行剩余代码的情况下（由于一些错误或其他情况）退出函数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func status(grade float64) string {
	if grade &amp;lt; 60.0 {
            return &amp;#34;failing&amp;#34;
	}
        return &amp;#34;passing&amp;#34;
}
func main() {
        fmt.Println(status(60.1))
        fmt.Println(status(59))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若包含一个不属于 if 块的 return 语句，有可能使代码在任何情况都不会运行，go要求声明了返回类型的任何函数都必须以 return 语句结束，以任何其他语句结束都将导致编译错误。&lt;/p&gt;
&lt;p&gt;若返回值类型与声明的返回类型不匹配，也将编译错误。&lt;/p&gt;
&lt;h1 id=&#34;使用返回值&#34;&gt;使用返回值&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func paintNeeded(width float64, height float64) float64 {
	area := width * height
	return area / 10.0
}
func main() {
	var amount, total float64
	amount = paintNeeded(4.2, 3.0)
	fmt.Printf(&amp;#34;%0.2f liters needed\n&amp;#34;, amount)
	total += amount
	amount = paintNeeded(5.2, 3.5)
	fmt.Printf(&amp;#34;%0.2f liters needed\n&amp;#34;, amount)
	total += amount
	fmt.Printf(&amp;#34;Total: %0.2f liters\n&amp;#34;, total)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;返回值允许main函数决定所计算的数量做什么，而不是依赖paintNeeded函数打印它。&lt;/p&gt;
&lt;p&gt;对下述代码进行更改，会怎么样？&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func paintNeeded(width float64, height float64) float64 {
        area := width * height
        return area / 10.0
}
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;如果这样&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;会失败，因为&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func paintNeeded(width float64, height float64) float64 {&lt;br&gt;        area := width * height&lt;br&gt;}&lt;br&gt;删除return 语句&lt;pre&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果函数声明了返回类型，go要求包含一个return语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func paintNeeded(width float64, height float64) float64 {&lt;br&gt;        area := width * height&lt;br&gt;        return area / 10.0&lt;br&gt;        fmt.Println(area / 10.0)&lt;br&gt;}&lt;br&gt;在return语句后加一行&lt;pre&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果函数声明了返回类型，go要求最后一个语句是return语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func paintNeeded(width float64, height float64) {&lt;br&gt;        area := width * height&lt;br&gt;        return area / 10.0&lt;br&gt;}&lt;br&gt;删除返回类型声明&lt;pre&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;go不允许返回未声明的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;func paintNeeded(width float64, height float64) float64 {&lt;br&gt;        area := width * height&lt;br&gt;        return int(area / 10.0)&lt;br&gt;}&lt;br&gt;更改要返回值的类型&lt;pre&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;go要求返回值的类型与声明的类型匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;错误值&#34;&gt;错误值&lt;/h1&gt;
&lt;p&gt;一个错误值是一个可以返回字符串的名为 Error 的方法返回的任何值。创建错误值的最简单方法是将字符串传递给 errors 包的 New 函数，该函数将返回一个新的错误值。若对该错误值调用 Error 方法，将会得到传递给 errors.New 的字符串。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
      &amp;#34;errors&amp;#34;
      &amp;#34;fmt&amp;#34;
)

func main() {
      err := errors.New(&amp;#34;height can&amp;#39;t be negative&amp;#34;)
      fmt.Println(err.Error())
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若将错误值传递给fmt或log包中的函数，则可能不需要调用它的Error方法。fmt和log中的函数已经被编写成能够检查是否传递给它们的值有Error方法，若有，则打印Error的返回值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;err := errors.New(&amp;#34;height can&amp;#39;t be negative&amp;#34;)
fmt.Println(err)
log.Fatal(err)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若需要格式化数字或其他值以便在错误信息中使用，可以使用 fmt.Error 函数，就像 fmt.Printf 或 fmt.Sprintf 一样，将值插入格式字符串中，但是不会打印或返回一个字符串，而是返回一个错误值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;err := fmt.Error(&amp;#34;a height of %0.2f is invalid&amp;#34;, -2.33333)
fmt.Println(err.Error())
fmt.Println(err)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;声明多个返回值&#34;&gt;声明多个返回值&lt;/h1&gt;
&lt;p&gt;要声明函数的多个返回值，需将返回值类型放在函数声明的第二组圆括号内（在函数参数的圆括号之后），用都好分隔。（当只有一个返回值时，返回值周围的圆括号是可选的，但是若有多个返回值，则必须使用圆括号。）当调用该函数时，需要考虑额外的返回值，通常通过将它们分配给额外的变量来实现。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func manyReturns() (int, bool, string) {
	return 1, true, &amp;#34;hello&amp;#34;
}
func main() {
	myInt, myBool, myString := manyReturns()
	fmt.Println(myInt, myBool, myString)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若要使返回值目的更清楚，可以将每个返回值提供名称，类似于参数名称，命名返回值的主要用途是作为程序员阅读代码的文档。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;math&amp;#34;
)

func floatParts(number float64) (integerPart int, fractionalPart float64) {
	wholeNumber := math.Floor(number)
	return int(wholeNumber), number - wholeNumber
}
func main() {
	cans, remainder := floatParts(1.26)
	fmt.Println(cans, remainder)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;在paintneeded函数中使用多个返回值&#34;&gt;在paintNeeded函数中使用多个返回值&lt;/h1&gt;
&lt;p&gt;如上所见，可以返回任何类型的多个返回值，但是对于多个返回值，常见的做法是返回一个主返回值，后跟一个额外值，表示函数是否遇到错误，若无问题，通常将额外值设置为nil，若发生错误，则设置为错误值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func paintNeeded(width float64, height float64) (float64, error) {
	if width &amp;lt; 0 {
		return 0, fmt.Errorf(&amp;#34;a width of %0.2f is invalid&amp;#34;, width)
	}
	if height &amp;lt; 0 {
		return 0, fmt.Errorf(&amp;#34;a height of %0.2f is invalid&amp;#34;, height)
	}
	area := width * height
	return area / 10.0, nil
}
func main() {
	amount, err := paintNeeded(4.2, -3.0)
	fmt.Println(err)
	fmt.Printf(&amp;#34;%0.2f liters needed\n&amp;#34;, amount)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 main 函数中，添加第二个变量记录 paintNeeded 中的错误值，若将一个无效的参数传递给paintNeeded，将得到一个错误返回值，并打印该错误。&lt;/p&gt;
&lt;h1 id=&#34;始终处理错误&#34;&gt;始终处理错误&lt;/h1&gt;
&lt;p&gt;当将一个无效的参数传递给paintNeeded时，得到一个错误返回值，并将其打印出，但也打印了一个无效信息。&lt;/p&gt;
&lt;p&gt;当函数返回一个错误值时，通常也必须返回一个主返回值，但伴随错误值的任何其他返回值都应被认为不可靠，被忽略。当调用返回错误值的函数时，在继续运行前测试该值是否为 nil 是重要的，若不是 nil ，则意味着有一个错误必须进行处理。&lt;/p&gt;
&lt;p&gt;如何处理错误取决于具体情况，对与 paintNeeded 函数，也许最好是简单跳过当前计算，并继续执行程序其余部分：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	amount, err := paintNeeded(4.2, -3.0)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf(&amp;#34;%0.2f liters needed\n&amp;#34;, amount)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以调用 Log.Fatal 来显示错误信息并退出程序。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	amount, err := paintNeeded(4.2, -3.0)
	if err != nil {
		Log.Fatal(err)
	}
        fmt.Printf(&amp;#34;%0.2f liters needed\n&amp;#34;, amount)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如下是一个计算一个数字平方根的程序，若一个负数传递给 squareRoot 函数，将返回一个错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;math&amp;#34;
)

func squareRoot(number float64) (float64, error) {
	if number &amp;lt; 0 {
		return 0, fmt.Errorf(&amp;#34;can&amp;#39;t get square root of number&amp;#34;)
	}
	return math.Sqrt(number), nil
}
func main() {
	root, err := squareRoot(-9.3)
	if err != nil {
		fmt.Println(err)
	} else {
		fmt.Printf(&amp;#34;%0.3f&amp;#34;, root)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;若如此&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;会失败，因为&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;return math.Sqrt(number)&lt;del&gt;, nil&lt;/del&gt;&lt;br&gt;删除要返回的参数之一&lt;pre&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;要返回的参数的数量必须始终与函数声明中的返回值的数量匹配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;root&lt;del&gt;, err&lt;/del&gt; := squareRoot(-9.3)&lt;br&gt;删除返回值所赋值给的变量之一&lt;pre&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;若使用函数的任何一个返回值，go要求使用所有的返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;pre&gt;root, err := squareRoot(-9.3)&lt;br&gt;&lt;del&gt;if err != nil {&lt;/del&gt;&lt;br&gt;&lt;del&gt;       fmt.Println(err)&lt;/del&gt;&lt;br&gt;&lt;del&gt;} else {&lt;/del&gt;&lt;br&gt;       fmt.Printf(&amp;quot;%0.3f&amp;quot;, root)&lt;br&gt;&lt;del&gt;}&lt;/del&gt;&lt;br&gt;删除使用其中一个返回值的代码&lt;pre&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;go要求使用声明的每个变量，当涉及错误返回值时，实际上是一个非常有用的特性，因为有助于避免意外地忽略错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;函数形参接收实参的副本&#34;&gt;函数形参接收实参的副本&lt;/h1&gt;
&lt;p&gt;当调用一个声明了行参的函数时，需要为调用提供实参，每个实参中的值被复制到相应的行参变量。（执行此操作的编程语言有时称为“值传递”）。这在大多数情况是可以的，但如果想把一个变量的值传递给一个函数并让它以某种方式改变这个值，就会遇到麻烦。&lt;/p&gt;
&lt;p&gt;函数只能更改行参中的该值的副本，而不能更改原始值，因此，在函数内部所做的任何更改在函数外部都将不可见。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Go是一种“值传递”语言；函数行参从函数调用中接收实参的副本。&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;指针&#34;&gt;指针&lt;/h1&gt;
&lt;p&gt;需要一种方法来允许函数改变变量所保存的原始值，而不是副本。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;&amp;amp;&lt;/code&gt; 符号来获取变量的地址，是go的“地址”运算符。&lt;br&gt;
例如：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;amount := 6
fmt.Println(amount)
fmt.Println(&amp;amp;amount)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以获得任何类型变量的地址，每个变量的地址不同。&lt;/p&gt;
&lt;p&gt;计算机为程序留出的内存是一个拥挤的地方，其充满了变量值：布尔值、整数、字符串等，如果有变量的地址，可以用其找到变量所包含的值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;表示变量地址的值称为指针&lt;/code&gt;，它指向可以找到变量的位置。&lt;/p&gt;
&lt;h1 id=&#34;指针类型&#34;&gt;指针类型&lt;/h1&gt;
&lt;p&gt;指针的类型可以写为一个 &lt;code&gt;*&lt;/code&gt; 符号，后面跟着指针指向的变量的类型。&lt;/p&gt;
&lt;p&gt;例如，指向一个 int 变量的指针的类型写为 *int ，可以大声读作：“指向int的指针”。&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;reflect.Type()&lt;/code&gt; 函数来显示之前程序中指针的类型：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;reflect&amp;#34;
)

func main() {
	var myInt int
	fmt.Println(reflect.TypeOf(&amp;amp;myInt))
	var myFloat float64
	fmt.Println(reflect.TypeOf(&amp;amp;myFloat))
	var myBool bool
	fmt.Println(reflect.TypeOf(&amp;amp;myBool))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以声明保存指针的变量，指针变量只能保存指向一种类型值的指针，因此变量可能只保存 *int 指针，只保存 *float64 指针。。。。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myInt int
var myIntPointer *int  //声明一个指向int的指针变量
myIntPointer = &amp;amp;myInt  //给变量分配一个指针
fmt.Println(myIntPointer)

var myFloat float64
var myFloatPointer *float64  //声明一个指向float64的指针变量
myFloatPointer = &amp;amp;myFloat    //给变量分配一个指针
fmt.Println(myFloatPointer)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与其他类型一样，若要立即为指针变量复制，可以使用短变量声明：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var myBool bool
myBoolPointer := &amp;amp;myBool
fmt.Println(myBoolPointer)
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;获取和更改指针的值&#34;&gt;获取和更改指针的值&lt;/h1&gt;
&lt;p&gt;通过在代码中的指针之前输入 &lt;code&gt;*&lt;/code&gt; 来获得指针饮用的变量的值。 *myIntPointer 可以读作：“myIntPointer 处的值”&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;myInt := 4
myIntPointer := &amp;amp;myInt
fmt.Println(myIntPointer)
fmt.Println(*myIntPointer)

myFloat := 98.6
myFloatPointer := &amp;amp;myFloat
fmt.Println(myIntPointer)
fmt.Println(*myIntPointer)

myBool := true
myBoolPointer := &amp;amp;myBool
fmt.Println(myBoolPointer)
fmt.Println(*myBoolPointer)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;0x1040a124
4
0x1040a140
98.6
0x1040a150
true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;*&lt;/code&gt; 运算符还可以更新指针处的值：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;myInt := 4
fmt.Println(myInt)
myIntPointer := &amp;amp;myInt
*myIntPointer = 8    //给指针处的变量（myInt）赋一个新值
fmt.Println(*myIntPointer)   //打印指针处变量的值
fmt.Println(myInt)     //打印变量的值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;4    //myInt初始值
8    //*myIntPointer的更新结果
8    //myInt的更新值（与*myIntPointer）相同
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;函数指针&#34;&gt;函数指针&lt;/h1&gt;
&lt;p&gt;可以从函数返回指针，只需声明函数的返回类型是指针类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func createPointer() *float64 {    //声明函数返回一个float64指针
        var myFloat = 98.5
        return &amp;amp;myFloat    //返回指定类型的指针
}

func main() {
        var myFloatPointer *float64 = createPointer()   //将返回的指针赋给一个变量
        fmt.Println(*myFloatPointer)    //打印指针处的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在go中，返回一个指向函数局部变量的指针是可以的，即使该变量不在作用域内，只要仍然拥有指针，go将确保仍然可以访问该值。&lt;/p&gt;
&lt;p&gt;还可以将指针作为参数传递给函数，只需说明一个或多个参数的类型是指针。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func printPointer(myBoolPointer *bool) {    //为该参数使用一个指针类型
        fmt.Println(*myBoolPointer)         //打印传入指针处的值
}
func main() {
        var myBool bool = true
        printPointer(&amp;amp;myBool)    //向函数传递一个指针
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;确保只使用指针作为参数，若函数声明它将使用指针，若试图将值传递给期望指针的函数，，将会编译错误。&lt;/p&gt;
&lt;h1 id=&#34;使用指针修复double函数&#34;&gt;使用指针修复&lt;code&gt;double&lt;/code&gt;函数&lt;/h1&gt;
&lt;p&gt;有一个double函数，接受一个 int 值并将其乘以2，希望能传入一个值并使该值加倍。但 go 是一种值传递语言，意味着函数参数从调用方接收任何参数的副本，函数将值的副本加倍，原始值不变。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        amount := 6
        double(amount)   //向函数传递实参
        fmt.Println(amount)   //打印原始值
}

func double(number int) {    //行参设置为实参的一个副本
        number *= 2     //改变副本值，不改变原始值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;若向函数传递一个指针，然后更改该指针处的值，那么这些更改在函数外部仍然有效。&lt;/p&gt;
&lt;p&gt;修改：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
        amount := 6
        double(&amp;amp;amount)     //传递一个指针而不是一个变量值
        fmt.Println(amount)
}
func double(number *int) {   //接受一个指针而不是一个int值
        *number *= 2    //更新指针处的值
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在double函数中，需要更新number参数的类型来获取 *int 而不是 int ，然后修改函数代码来更新number指针处的值，而不是直接更新变量，在main函数中，只需更新对double的调用来传递一个指针，而不是一个直接的值。 当运行更新后的代码时，指向amount变量的指针将被传递给double函数，double函数将获取该指针处的值并使其加倍，从而更改amount变量中的值。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2.条件与循环</title>
      <link>https://tinklespring.com/posts/2.%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/</link>
      <pubDate>Wed, 31 May 2023 11:33:55 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/2.%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;接下来，go的条件与循环～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;调用方法&#34;&gt;调用方法&lt;/h1&gt;
&lt;p&gt;定义方法：与给定类型的值相关联的函数。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;time&amp;#34;
)

func main() {
	var now time.Time = time.Now()
	var year int = now.Year()
	fmt.Println(year)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;time 包有一个表示日期（年、月、日）和时间（小时、分钟、秒等）的Time类型。每一个&lt;code&gt;time.Time&lt;/code&gt;值都有一个返回年份的Year方法。&lt;br&gt;
time.Now 函数返回当前日期和时间的新Time值，将其存储在now变量中，然后对now引用的值调用Year方法。&lt;br&gt;
&lt;code&gt;方法是特定类型的值关联的函数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;strings 包有一个Replacer类型，可以在字符串中搜索子字符串，并且在每次该子字符串出现的地方用另一个字符串替换它：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;strings&amp;#34;
)

func main() {
	broken := &amp;#34;G# r#cks!&amp;#34;
	replacer := strings.NewReplacer(&amp;#34;#&amp;#34;, &amp;#34;o&amp;#34;)
	fixed := replacer.Replace(broken)
	fmt.Println(fixed)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;strings.NewReplacer 函数接受要替换的字符串（&amp;quot;#&amp;quot;）和要替换为的字符串(&amp;ldquo;o&amp;rdquo;) 的参数，并返回给 strings.Replacer。当我们将一个字符串传递给 Replacer 值的 Replace 方法时，将返回一个完成了替换的字符串。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;点表示右边的东西属于左边&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;函数属于一个包，方法属于一个单独的值，这个值出现在点的左边。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;now.Year()
replacer.Replace(broken)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上边 &lt;code&gt;now&lt;/code&gt; 为 值，&lt;code&gt;Year&lt;/code&gt; 为 方法名&lt;br&gt;
&lt;code&gt;replacer&lt;/code&gt; 为 值， &lt;code&gt;Replace&lt;/code&gt; 为方法名&lt;/p&gt;
&lt;h1 id=&#34;评分&#34;&gt;评分&lt;/h1&gt;
&lt;p&gt;写一个程序：输入百分比分数，60% 分数及格，不足则不及格，输入的百分比大于或等于60，程序需要给出响应。&lt;/p&gt;
&lt;h4 id=&#34;获取分数&#34;&gt;获取分数&lt;/h4&gt;
&lt;p&gt;输入百分比分数，按回车键，把输入的数字存在一个变量中。
当有一个值时，通常会分配一个变量，但不打算使用时，可以使用空白标识符。为空白标识符分配一个值实际上会丢弃它。在赋值语句中输入一个下划线 &lt;code&gt;_&lt;/code&gt; ，通常在这里输入的是变量名。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;os&amp;#34;
)

func main() {
	fmt.Print(&amp;#34;Enter a grade: &amp;#34;)
	reader := bufio.NewReader(os.Stdin)
	input, _ := reader.ReadString(&amp;#39;\n&amp;#39;)
	fmt.Println(input)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;处理错误&#34;&gt;处理错误&lt;/h1&gt;
&lt;p&gt;若从 ReadString 方法中得到一个错误返回，空白标识符只会导致错误忽略，程序依然继续运行，可能会使用无效的数据。&lt;br&gt;
log 包有一个 Fatal 函数，可以同时为我们完成两步：将一条消息记录到终端并停止程序运行。（在上下文中，Fatal 是报告一个错误，并杀死你的程序。）&lt;br&gt;
去掉空白标识符用一个 err 变量替换，可以记录错误，然后将使用 Fatal 函数来记录错误并停止程序运行。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;os&amp;#34;
)

func main() {
	fmt.Print(&amp;#34;Enter a grade: &amp;#34;)
	reader := bufio.NewReader(os.Stdin)
	input, err := reader.ReadString(&amp;#39;\n&amp;#39;)
	log.Fatal(err)
	fmt.Println(input)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;条件&#34;&gt;条件&lt;/h1&gt;
&lt;p&gt;若从键盘读取输入时遇到问题，将其设置为报告错误并停止运行，但是一切正常也停止运行。&lt;br&gt;
ReadString 这样的函数和方法返回一个错误值nil，基本上意味着什么都没有，如果 err 为 nil ，表示没有错误，我们的程序被设置为只简单报告nil错误，正确做法是，当err变量的值不是nil时才退出程序。&lt;/p&gt;
&lt;p&gt;可以使用条件语句，只有在满足某个条件时，才导致代码块（一个或多个由花括号&lt;code&gt;{}&lt;/code&gt;包围的语句）被执行的语句。&lt;/p&gt;
&lt;p&gt;计算表达式，若结果为 true，则执行条件块体中的代码，若为false ，则跳过条件块。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if true {
      fmt.Println(&amp;#34;xxxx&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if 1 &amp;lt; 2 {
     fmt.Println(&amp;#34;xxxx&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;go支持条件语句中的多个分支：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if grade == 100 {
           fmt.Println(&amp;#34;Perfect!&amp;#34;)
} else if grade &amp;gt;= 60 {
           fmt.Println(&amp;#34;Pass!&amp;#34;)
} else {
           fmt.Println(&amp;#34;Fail!&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;条件语句依赖布尔表达式（计算结果为true或false）来决定是否执行包含的代码。&lt;/p&gt;
&lt;p&gt;当在条件为假时执行，可以使用 &lt;code&gt;!&lt;/code&gt; 布尔求反运算符。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if !true {
    fmt.Println(&amp;#34;xxx&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;希望两个条件都为真时运行，使用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; （“与”）运算符，两者之一为真时运行，使用&lt;code&gt;||&lt;/code&gt;（“或”）运算符。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if true &amp;amp;&amp;amp; true {
    fmt.Println(&amp;#34;xxxxx&amp;#34;)
}

if false || true {
    fmt.Println(&amp;#34;xxxxx&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;go语言不要求 if 语句的条件用圆括号括起来。&lt;/p&gt;
&lt;h1 id=&#34;有条件地记录致命错误&#34;&gt;有条件地记录致命错误&lt;/h1&gt;
&lt;p&gt;若 err 变量中的值为 nil ，表示从键盘读取成功。更新代码记录错误，在err不是 nil 时退出。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;os&amp;#34;
)

func main() {
	fmt.Print(&amp;#34;Enter a grade: &amp;#34;)
	reader := bufio.NewReader(os.Stdin)
	input, err := reader.ReadString(&amp;#39;\n&amp;#39;)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(input)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新运行程序，可以看到可以正常运行，若读取用户输入有错误，也可以看到这些错误。&lt;/p&gt;
&lt;h1 id=&#34;避免遮盖名字&#34;&gt;避免遮盖名字&lt;/h1&gt;
&lt;p&gt;避免使用缩写，但是命名 error变量不对，会遮盖一个名为 error 的类型名称。&lt;br&gt;
声明变量时，应确保与任何现有的函数、包、类型或其他变量的名称不同。 若在封闭范围内存在同名的东西，变量将对其进行遮盖，也就是说优先级高，这不是一件好事。&lt;br&gt;
但是若想访问变量遮盖的类型、函数或包，将得到变量中的值，此时，会导致编译错误。&lt;/p&gt;
&lt;h1 id=&#34;将字符串转换为数字&#34;&gt;将字符串转换为数字&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;strings&lt;/code&gt; 包中有个 &lt;code&gt;TrimSpace&lt;/code&gt;函数，删除字符串开头和结尾的所有空白字符（换行符、制表符和常规空格）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;s := &amp;#34;\t xxx \n&amp;#34;
fmt.Println(strings.TrimSpace(s))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字符串转换为数字，使用 &lt;code&gt;strconv&lt;/code&gt;包中的 &lt;code&gt;ParseFloat&lt;/code&gt;函数转换为 float64值。&lt;br&gt;
&lt;code&gt;grade, err := strconv.ParseFloat(input, 64)&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;块和变量的作用域&#34;&gt;块和变量的作用域&lt;/h1&gt;
&lt;p&gt;声明的每个变量都有一个作用域，可以在作用域内的任何地方被访问，但是在作用域之外访问会报错。&lt;br&gt;
变量的作用域由其声明所在的块和嵌套在该块中任何块组成。&lt;/p&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/2-%e6%9d%a1%e4%bb%b6%e4%b8%8e%e5%be%aa%e7%8e%af/%e5%9d%97%e5%92%8c%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;packageVar 变量的作用域是整个 main 包，可以在包中定义的任何函数内的任何位置访问 packageVar。&lt;/li&gt;
&lt;li&gt;functionVar 变量作用域是其声明所在的整个函数，包括嵌套在该函数中的if块。&lt;/li&gt;
&lt;li&gt;conditionalVar 变量作用域仅限于if块，当试图在if块外访问conditionalVar，将报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;修改后的程序&#34;&gt;修改后的程序&lt;/h1&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/2-%e6%9d%a1%e4%bb%b6%e4%b8%8e%e5%be%aa%e7%8e%af/%e5%ae%8c%e6%95%b4%e7%a8%8b%e5%ba%8f.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;h1 id=&#34;短变量声明中只有一个变量必须是新的&#34;&gt;短变量声明中只有一个变量必须是新的&lt;/h1&gt;
&lt;p&gt;不能对一个变量声明两次。&lt;br&gt;
但是当一个变量名在同一个作用域中被声明两次时，会编译报错。&lt;/p&gt;
&lt;p&gt;但是，短变量声明中至少有一个变量名是新的，新变量名被视为声明，现有的被视为赋值。&lt;/p&gt;
&lt;h1 id=&#34;练习&#34;&gt;练习&lt;/h1&gt;
&lt;p&gt;需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成一个1到100之间的随机数，将其存储为目标数，供玩家猜测。&lt;/li&gt;
&lt;li&gt;提示玩家猜测目标数是什么，存储他们的回答。&lt;/li&gt;
&lt;li&gt;若玩家猜测的数小于目标数，就说“你猜低了”，若大于目标数，就说“你猜高了” 。&lt;/li&gt;
&lt;li&gt;允许最多猜10次，在每次猜之前，让他们知道还剩多少次。&lt;/li&gt;
&lt;li&gt;若猜的与目标数相同，就说“你猜对了”，然后不再问新的猜测。&lt;/li&gt;
&lt;li&gt;若玩家用完了所有轮次也没猜对，就说“sorry，你没猜对，它是：[目标数]”&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;包名与导入路径&#34;&gt;包名与导入路径&lt;/h1&gt;
&lt;p&gt;math/rand  包有一个 Intn 函数，可以生成一个随机数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import ()
    &amp;#34;fmt&amp;#34;
    &amp;#34;math/rand&amp;#34;

func main() {
    target := rand.Intn(100) + 1
    fmt.Println(target)
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;math/rand&lt;/code&gt; 指的是包的导入路径，不是名称，导入路径是一个独特的字符串，用于标识包以及在导入语句中使用的包，一旦导入包，就可以通过包名来引用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;导入路径&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;包名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;ldquo;fmt&amp;rdquo;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fmt&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;ldquo;log&amp;rdquo;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;log&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;ldquo;strings&amp;rdquo;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;strings&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;ldquo;archive&amp;rdquo;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;archive&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;ldquo;archive/tar&amp;rdquo;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;tar&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;ldquo;archive/zip&amp;rdquo;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;zip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;ldquo;math&amp;rdquo;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;math&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;ldquo;math/cmplx&amp;rdquo;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;cmplx&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;ldquo;math/rand&amp;rdquo;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;rand&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有些包，导入路径与包名都相同，有些包属于类似的类别，被分组在类似的导入路径前缀。&lt;br&gt;
go语言不要求包名与其导入路径有任何关系，按惯例，导入路径的最后（或唯一）一段也用作包名，比如“archive” 包名为 archive，若导入路径为 “archive/zip” 则包名为 zip 。&lt;/p&gt;
&lt;h1 id=&#34;生成随机数&#34;&gt;生成随机数&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;
	&amp;#34;math/rand&amp;#34;
	&amp;#34;time&amp;#34;
)

func main() {
	seconds := time.Now().Unix()
	rand.Seed(seconds)
	target := rand.Intn(100) + 1
	fmt.Println(&amp;#34;I&amp;#39;ve chosen a random number between 1 and 100.&amp;#34;)
	fmt.Println(&amp;#34;Can you guess it?&amp;#34;)
	fmt.Println(target)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;从键盘获取整数&#34;&gt;从键盘获取整数&lt;/h1&gt;
&lt;p&gt;不需要将输入转换为float64，需要将其转换为int（因为只使用整数）。将把从键盘读取的字符串传递给 strconv 包的 Atoi （字符串转整数）函数，不是它的 ParseFloat 函数，Atoi会给一个整数作为其返回值。&lt;/p&gt;
&lt;h1 id=&#34;将猜测与目标进行比较&#34;&gt;将猜测与目标进行比较&lt;/h1&gt;
&lt;p&gt;下一步将用户的猜测与随机生成的数字进行比较；&lt;br&gt;
若值低于目标值，打印信息，说猜低了，否则若猜测值大于目标值，打印信息说猜高了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;math/rand&amp;#34;
	&amp;#34;os&amp;#34;
	&amp;#34;strconv&amp;#34;
	&amp;#34;strings&amp;#34;
	&amp;#34;time&amp;#34;
)

func main() {
	seconds := time.Now().Unix()
	rand.Seed(seconds)
	target := rand.Intn(100) + 1
	fmt.Println(&amp;#34;I&amp;#39;ve chosen a random number between 1 and 100.&amp;#34;)
	fmt.Println(&amp;#34;Can you guess it?&amp;#34;)
	fmt.Println(target)

	reader := bufio.NewReader(os.Stdin)

	fmt.Print(&amp;#34;Make a guess: &amp;#34;)
	input, err := reader.ReadString(&amp;#39;\n&amp;#39;)
	if err != nil {
		log.Fatal(err)
	}
	input = strings.TrimSpace(input)
	guess, err := strconv.Atoi(input)
	if err != nil {
		log.Fatal(err)
	}

	if guess &amp;lt; target {
		fmt.Println(&amp;#34;your guess was low&amp;#34;)
	} else if guess &amp;gt; target {
		fmt.Println(&amp;#34;your guess was high&amp;#34;)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;循环&#34;&gt;循环&lt;/h1&gt;
&lt;p&gt;循环以 for 关键字开头：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个初始化（或init）语句，用于初始化一个变量&lt;/li&gt;
&lt;li&gt;一个条件表达式，用于决定何时中断循环&lt;/li&gt;
&lt;li&gt;一个标志（post）语句，在循环的每次迭代后运行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img  src=&#34;https://tinklespring.com/img/Golang/2-%e6%9d%a1%e4%bb%b6%e4%b8%8e%e5%be%aa%e7%8e%af/%e5%be%aa%e7%8e%af.png&#34;
        alt/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;++&lt;/code&gt; 与 &lt;code&gt;--&lt;/code&gt; 经常用于循环的标志（post）语句中，&lt;code&gt;++&lt;/code&gt; 在每次求值时都会加1， &lt;code&gt;--&lt;/code&gt; 则会减1。&lt;/p&gt;
&lt;p&gt;还包括赋值运算:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+=&lt;/code&gt; 加上另一个值，然后将结果赋回给该变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-=&lt;/code&gt; 减去另一个值，然后将结果赋回给该变量
&lt;code&gt;+=&lt;/code&gt; 与 &lt;code&gt;-=&lt;/code&gt; 可以在循环中用于1以外的增量计数。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for x := 1; x &amp;lt;= 5; x += 2 {
       fmt.Println(x)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;初始化和标志post语句是可选的&#34;&gt;初始化和标志（post）语句是可选的&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x := 1
for x &amp;lt;= 3 {
       fmt.Println(x)
       x++
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;使用continue与break跳过循环&#34;&gt;使用“continue”与“break”跳过循环&lt;/h1&gt;
&lt;p&gt;go 提供了两个控制循环流的两个关键字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;continue ：立即跳转到循环的下一个迭代，不需要在循环块中运行任何其他代码&lt;/li&gt;
&lt;li&gt;break：    立即跳出循环，不再执行循环块中的代码，也不再运行循环，执行将移动到循环之后的语句中。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for x := 1, x &amp;lt;= 3; x++ {
       fmt.Println(&amp;#34;before continue&amp;#34;)
       continue
       fmt.Println(&amp;#34;after continue&amp;#34;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;字符串“after continue”将永远不会打印输出。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for x := 1; x &amp;lt;= 3; x++ {
       fmt.Println(&amp;#34;before break&amp;#34;)
       break
       fmt.Println(&amp;#34;after break&amp;#34;)
}
fmt.Println(&amp;#34;after loop&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在循环第一次迭代中，“before break”被打印出，但随后break立即跳出循环，不打印 “after break”，也不再运行循环。&lt;/p&gt;
&lt;h1 id=&#34;完整代码&#34;&gt;完整代码&lt;/h1&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;bufio&amp;#34;
	&amp;#34;fmt&amp;#34;
	&amp;#34;log&amp;#34;
	&amp;#34;math/rand&amp;#34;
	&amp;#34;os&amp;#34;
	&amp;#34;strconv&amp;#34;
	&amp;#34;strings&amp;#34;
	&amp;#34;time&amp;#34;
)

func main() {
	seconds := time.Now().Unix() //获取当前日期和时间的整数形式
	rand.Seed(seconds)           //播种随机数生成器
	target := rand.Intn(100) + 1 //生成一个介于1-100之间的整数
	fmt.Println(&amp;#34;I&amp;#39;ve chosen a random number between 1 and 100.&amp;#34;)
	fmt.Println(&amp;#34;Can you guess it?&amp;#34;)

	reader := bufio.NewReader(os.Stdin) //创建一个buffio.Reader 允许读取键盘输入
	success := false                    //设置为默认打印失败信息
	for guesses := 0; guesses &amp;lt; 10; guesses++ {
		fmt.Println(&amp;#34;you have&amp;#34;, 10-guesses, &amp;#34;guesses left.&amp;#34;)
		fmt.Print(&amp;#34;Make a guess: &amp;#34;)
		input, err := reader.ReadString(&amp;#39;\n&amp;#39;) //读取用户输入，直到按enter键
		if err != nil {
			log.Fatal(err)
		} //若出现错误则打印信息并退出
		input = strings.TrimSpace(input)  //删除换行符
		guess, err := strconv.Atoi(input) //将输入字符转换为整数
		if err != nil {
			log.Fatal(err)
		} //若出现错误则打印信息并退出

		if guess &amp;lt; target {
			fmt.Println(&amp;#34;your guess was low&amp;#34;)
		} else if guess &amp;gt; target {
			fmt.Println(&amp;#34;your guess was high&amp;#34;)
		} else {
			success = true //阻止显示失败信息
			fmt.Println(&amp;#34;good job! you guessed it!&amp;#34;)
			break //退出循环
		}
	}

	if !success { //如果 “success” 是false，告诉玩家结果
		fmt.Println(&amp;#34;sorry,you didn&amp;#39;t guess number.It was:&amp;#34;, target)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在循环之后，添加了一个if块来打印失败消息，if块只有在条件的计算结果为true时运行，我们希望success为false时执行打印，所以添加布尔求反运算符&lt;code&gt;!&lt;/code&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1-1.golang25个保留关键字</title>
      <link>https://tinklespring.com/posts/1-1.golang25%E4%B8%AA%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97/</link>
      <pubDate>Wed, 31 May 2023 11:18:24 +0800</pubDate>
      
      <guid>https://tinklespring.com/posts/1-1.golang25%E4%B8%AA%E4%BF%9D%E7%95%99%E5%85%B3%E9%94%AE%E5%AD%97/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;golang 有25个保留关键字，比26个英文字母还少一个～&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;break&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;default&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;func&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;interface&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;select&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;case&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;defer&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;go&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;map&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;struct&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;chan&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;else&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;goto&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;package&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;switch&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;const&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;fallthrough&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;if&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;range&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;type&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;continue&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;for&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;import&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;return&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;var&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Go 25个关键字不能用作标识符，分为3类：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;包管理：
import  package

程序实体声明与定义：
chan const func interface map struct type var

程序流程控制：
break  case         continue  default  defer
else   fallthrough  for       go       goto
if     range        return    select   switch
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;包管理&#34;&gt;包管理&lt;/h1&gt;
&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;import&lt;/font&gt;&lt;br&gt;
用于导入包，这样就可以使用包中被导出的标识符。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
    _ &amp;#34;package path&amp;#34;
    . &amp;#34;package path&amp;#34;
    alias &amp;#34;package path&amp;#34;
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;包路径前面有三种修饰符：&lt;br&gt;
&lt;code&gt;_&lt;/code&gt; 下划线即空白标识符，表示不使用包中的标识符，计算包级变量的初始化表达式和执行导入包的init初始化函数。&lt;br&gt;
&lt;code&gt;.&lt;/code&gt; 点号代替包的别名，表示访问包中的导出标识符无需使用包名。&lt;br&gt;
&lt;code&gt;alias&lt;/code&gt; 表示包的别名。&lt;/p&gt;
&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;package&lt;/font&gt; &lt;br&gt;
package用于声明包的名称，需要放在go文件所有代码的最前面，一个包由一个或多个go源文件组成，需放在同一个目录下，且同一个目录下的这些go文件的package的名字只能有一个。&lt;/p&gt;
&lt;h1 id=&#34;程序实体声明与定义&#34;&gt;程序实体声明与定义&lt;/h1&gt;
&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;chan&lt;/font&gt;&lt;br&gt;
&lt;code&gt;chan&lt;/code&gt; 用于声明信道（channel）。&lt;br&gt;
信道提供一种机制使两个并发执行的函数实现同步，并通过传递具体元素类型的值来通信，未初始化的信道值为&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;声明格式：
&lt;code&gt;chan T&lt;/code&gt;   可以被用来发送和接收类型T的值。&lt;br&gt;
&lt;code&gt;chan&amp;lt;- T&lt;/code&gt; 只能被用来发送类型T的值。&lt;br&gt;
&lt;code&gt;&amp;lt;-chan T&lt;/code&gt; 只能被用来接收类型T的值。&lt;br&gt;
其中 &lt;code&gt;&amp;lt;-&lt;/code&gt; 操作符指定信道的方向，发送或接收，没有给定方向，则信道是双向的，信道可以通过类型转换或赋值被强制为只发送或只接收。&lt;br&gt;
信道的初始化可以通过 make 函数来实现，其结果值充当了对底层数据结构的引用。初始化时可以为信道设置缓冲区大小，默认值是零，表示不带缓冲的或同步的信道。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ci := make(chan int)&lt;/code&gt;           整数类型的无缓冲信道&lt;br&gt;
&lt;code&gt;cj := make(chan int, 0)&lt;/code&gt;        整数类型的无缓冲信道&lt;br&gt;
&lt;code&gt;cp := make(chan *os.file, 100)&lt;/code&gt; 指向文件指针的带缓冲信道&lt;/p&gt;
&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;const&lt;/font&gt;&lt;br&gt;
const 用于声明常量，需指明初始值，一旦创建不可修改。&lt;br&gt;
由于编译时的限制，定义它们的表达式必须也是可被编译器求值的常量表达式。例如 1&amp;laquo;3 就是一个常量表达式，而 math.Sin(math.Pi/4) 则不是，因为对 math.Sin 的函数调用在运行时才会发生。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;const name T = value                    // 指明类型
const name0, name1 T = value0, value1   // 指明类型，定义多个常量
const name = value                      // 无类型常量
const name0, name1 = value0, value1     // 无类型常量，可定义多个

// const name0 T, name1 T = value0, value1	// 错误，const 不能在同一行出现多个类型名（同一类型也不行）

// 将常量定义放在小括号中
const (
	name0 = value0
	name1 = value1
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在小括号中的常量声明列表，const 常与iota常量生成器联用，用来申明连续的 数值常量集。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 无类型数值常量集（可转为整型或浮点型）
const (
	Sunday = iota       // 0
	Monday	            // 1
	Tuesday	            // 2
	Wednesday           // 3
	Thursday            // 4
	Friday	            // 5
	Partyday            // 6
	numberOfDays        // 7，该常量未导出
)

// 无类型数值常量集（可转为浮点型）
const (
	Sunday = iota + 0.1   // 0.1
	Monday		      // 1.1
	Tuesday		      // 2.1
	Wednesday	      // 3.1
	Thursday	      // 4.1
	Friday		      // 5.1
	Partyday	      // 6.1
	numberOfDays 	      // 7.1，该常量未导出
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于go的常量还有：&lt;br&gt;
1）常量可以是类型化的或无类型化的。字面常量，true，false， iota 和某些只包含无类型化操作数的常量表达式是无类型化的；&lt;/p&gt;
&lt;p&gt;2）常量可由常量声明或类型转换显式地赋予其类型， 也可由变量声明或赋值以及作为表达式中的操作数隐式地赋予其类型。若常量的值不能由其类型表示就会产生一个错误。 例如，3.0 可赋予任何整数或浮点数类型的常量，而 2147483648.0 （等价于 1&amp;laquo;31）则只能赋予 float32, float64 或 uint32 类型的常量，而不能赋予 int32 或 string类型的常量；&lt;/p&gt;
&lt;p&gt;3）尽管数值常量在该语言中可拥有任意精度， 但编译器可能使用其有限精度的内部表示来实现它们。即，每个实现必须：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用至少256位表示整数常量；&lt;/li&gt;
&lt;li&gt;使用至少256位表示浮点常量，包括复数常量及尾数部分，和至少16位的有符号指数；&lt;/li&gt;
&lt;li&gt;若无法精确表示一个整数常量，则给出一个错误；&lt;/li&gt;
&lt;li&gt;若由于溢出而无法表示一个浮点或复数常量，则给出一个错误；&lt;/li&gt;
&lt;li&gt;若由于精度限制而无法表示一个浮点或复数常量，则舍入为最近似的可表示常量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些要求适用于 字面常量 和 常量表达式 的求值结果。&lt;/p&gt;
&lt;p&gt;golang中的const 不支持 C/C++ 中修饰函数的参数和返回值，如下语句是非法的：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func test(const name *string)
func test(name *string) const *string
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;func&lt;/font&gt;&lt;br&gt;
func 用于定义函数，go函数支持变参且返回值支持多个，但不支持默认参数，若函数存在多个返回值形参则需要使用小括号括起来，格式：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func funcName(){}			    //无参无返回值
func funcName(t T) T {}			    //有参有返回值
func funcName(t T, list ...T) (T1,T1) {}    //有变参有多个返回值
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;格式上要注意，函数体的第一个大括号必须函数名同行。&lt;/p&gt;
&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;interface&lt;/font&gt;&lt;br&gt;
interface 用于定义接口。一个接口是一个方法集，如果一个类型实现了一个接口中的所有方法集，那么说明该类型实现此接口。接口类型变量可以存储任何实现了该接口的类型的值。特别的，&lt;code&gt;interface{}&lt;/code&gt;表示空接口类型，默认地，所有类型均实现了空接口，所以&lt;code&gt;interface{}&lt;/code&gt;可以接收任意类型值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 空接口
interface{}

// 一个简单的 File 接口
type File interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;map&lt;/font&gt;&lt;br&gt;
map 用于声明映射变量。映射属容器类类型，是一个同种类型元素的无序组，通过唯一的键可以获取对应的值。可以使用 make 创建 map 变量，在定义 map 时可以省略容量，超出容量时会自动扩容，但尽量提供一个合理的初始值。未初始化的映射值为 nil。&lt;/p&gt;
&lt;p&gt;// 由于map底层是一个hash map，其并没有具体的容量，指定容量也是一个建议值，所以无法使用 &lt;code&gt;cap()&lt;/code&gt;函数来获取map的容量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 错误示例
func main() {
    m := make(map[string]int, 99)
    println(cap(m))     // error: invalid argument m1 (type map[string]int) for cap  
}    
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;创建map&#34;&gt;创建map&lt;/h6&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 创建 0 容量的 map
var myMap = make(map[T1]T2) 
var myMap = map[T1]T2{}

// 创建指定容量的 map
var myMap = make(map[T1]T2, hint) 

// 创建并初始化 map
var myMap = map[string]int {
	&amp;#34;dable&amp;#34; : 27,
	&amp;#34;cat&amp;#34; : 28,
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
	nameAge := make(map[string]int)
	nameAge[&amp;#34;bob&amp;#34;] = 18                     //增
	nameAge[&amp;#34;tom&amp;#34;] = 16                     //增
	delete(nameAge, &amp;#34;bob&amp;#34;)                  //删
	nameAge[&amp;#34;tom&amp;#34;] = 19                     //改
	v := nameAge[&amp;#34;tom&amp;#34;]                     //查
	fmt.Println(&amp;#34;v=&amp;#34;,v)
	v, ok := nameAge[&amp;#34;tom&amp;#34;]                 //查，推荐用法
	if ok { 
		fmt.Println(&amp;#34;v=&amp;#34;,v,&amp;#34;ok=&amp;#34;,ok)
	}   
	for k, v :=range nameAge {      		//遍历
		fmt.Println(k, v)
	}   
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;v= 19
v= 19 ok= true
tom 19
&lt;/code&gt;&lt;/pre&gt;&lt;h6 id=&#34;map-遍历&#34;&gt;map 遍历&lt;/h6&gt;
&lt;p&gt;遍历所有key&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 方式一
for k := range mapVar {
	...
}

// 方式二（不推荐）
for k, _ := range mapVar {
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;遍历所有value&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for _, v := range mapVar {
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;遍历所有key与value&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for k, v := range mapVar {
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;// map 在没有被修改的情况下，使用range多次遍历map时输出的key和value的顺序可能不同，这是go设计者有意为之，在每次range时的顺序被随机化，旨在提示开发者，go底层实现并不保证map遍历顺序稳定，请大家不要依赖range遍历结果顺序。&lt;a href=&#34;https://go.dev/blog/maps&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;Go maps in action&lt;/a&gt;
&lt;/p&gt;
&lt;h6 id=&#34;map增删改查&#34;&gt;map增删改查&lt;/h6&gt;
&lt;p&gt;向map写入元素时，键值对不存在会自动添加，键值存在时将被新值覆盖。使用 &lt;code&gt;delete()&lt;/code&gt; 删除某键值对，使用 &lt;code&gt;len()&lt;/code&gt; 获取元素个数。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 新增或修改
m[&amp;#34;name&amp;#34;] = &amp;#34;wade&amp;#34;
 
// 删除，key 不存在则啥也不干
delete(m, &amp;#34;name&amp;#34;)
 
// 三种查询方式 
// 查询，key 不存在返回 value 类型的零值
v := m[&amp;#34;name&amp;#34;]
v, ok := m[&amp;#34;name&amp;#34;]
_, ok := m[&amp;#34;name&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;p&gt;map使用需注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;map默认初始值为 &lt;code&gt;nil&lt;/code&gt;
map 声明时未初始化的情况下值为 nil。对 nil map 取值，返回对应类型的零值，不会引发 panic；但写入会引发 panic，所以推荐做法是向 map 写入时先判断 map 是否为 nil；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map range 的顺序是随机的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map 值传递表现出引用传递的效果
Go 没有引用传递，只有值传递与指针传递。所以 map 作为函数实参传递时本质上也是值传递，只不过因为 map 底层数据结构是通过指针指向实际的元素存储空间，在被调函数中修改 map，对调用者同样可见，所以 map 作为函数实参传递时表现出了引用传递的效果。因此，传递 map 时，函数形参无需使用指针；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map 的元素不可选址
map 中的元素并不是一个变量，而是一个值，对 map 元素取值将报运行时错误，因此当 map 的元素为结构体类型的值，那么无法直接修改结构体中的字段值。如果想修改，有两个解决办法，一是存储 struct 的指针类型，二是使用临时变量，每次取出来后再设置回去；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map 并发读写不安全
需要加锁，或只用 &lt;code&gt;sync.Map&lt;/code&gt; ，否则会引发panic。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例：&lt;a href=&#34;https://dablelv.blog.csdn.net/article/details/90729484&#34;target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;&gt;go map 三板斧&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;struct&lt;/font&gt;&lt;br&gt;
&lt;code&gt;struct&lt;/code&gt; 用于定义结构体，结构体属容器类型，是多个相同或不同类型值的集合。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

type Vertex struct {
	X, Y int
}

var (
	v1 = Vertex{1, 2}  // 类型为 Vertex
	v2 = Vertex{X: 1}  // Y:0 被省略
	v3 = Vertex{}      // X:0 和 Y:0
	p  = &amp;amp;Vertex{1, 2} // 类型为 *Vertex
)

func main() {
	fmt.Printf(&amp;#34;%#v %#v %#v %#v\n&amp;#34;, v1, v2, v3, p)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;type&lt;/font&gt;&lt;br&gt;
&lt;code&gt;type&lt;/code&gt; 用于定义类型，比如定义struct、interface、func与等价类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 定义struct
type Person struct { name string }

// 定义接口
type Person interface {
	speak(word string)
}

// 定义函数类型
type FuncType func(int, int) int

// 定义等价类型，rune等价于int32
type rune int32
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;var&lt;/font&gt;&lt;br&gt;
&lt;code&gt;var&lt;/code&gt; 用于声明函数级变量和包级变量。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var name T							// 指明类型，使用类型零值
var name T = value					// 指明类型，指明初始值
var name0, name1 T					// 指明类型，使用类型零值定义多个变量
var name0, name1 T = value0, value1	// 指明类型，指明初始值定义多个变量

var name = value					// 根据值推断变量类型
var name0, name1 = value0, value1	// 根据值推断变量类型，可定义多个不同类型变量

// var name0 T, name1 T				// 错误，var 不能在同一行出现多个类型名（同一类型也不行）

// 将变量定义放在括号中
var (
	name0 = value0
	name1 = value1
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义变量可以使用短变量声明方式（:=） 替代var，但短变量声明方式只能用于函数体内声明函数级变量，且需指明初始值，声明时不能指明变量类型，类型由初始化确定。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;name := value			// 申明一个变量
name0, name1 := value0, value1	// 申明多个变量，变量类型可以不同
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;声明多个变量时候，只要有一个是新的即可。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func main() {
	oldVar := 1
	oldVar, newVar := 2, 3
	fmt.Printf(&amp;#34;oldVar=%v newVar=%v\n&amp;#34;, oldVar, newVar) // oldVar=2 newVar=3
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;var&lt;/code&gt; 与 &lt;code&gt;:=&lt;/code&gt; 区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;var 既可以声明函数级变量，也可以声明包级变量，而短变量只能声明函数级变量&lt;/li&gt;
&lt;li&gt;var 可以不指定初始值，短变量声明方式必须指定初始值&lt;/li&gt;
&lt;li&gt;var 可以指定数据类型，短变量声明方式不能指定数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;程序流程控制&#34;&gt;程序流程控制&lt;/h1&gt;
&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;for range break continue&lt;/font&gt;&lt;br&gt;
for 是go 中唯一用于循环结构的关键词，有三种使用方式，分别是单个循环条件，经典的初始化/条件/后续形式，还有和 range 关键词结合使用来遍历容器类对象（数组、切片、映射、信道）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 单条件
i := 1
for i &amp;lt;= 3 {
	fmt.Println(i)
	i = i + 1
}

// 初始化/条件/后续形式
// 注意 Go 中没有前置自增与自减运算符，即++i是非法的
for i:=0; i &amp;lt; 3; i++ {
	fmt.Println(i)
}

// for range 遍历数组
array :=[...]int{0,1,2,3,4,5}
for i, v :=range array{
	fmt.Println(i,v)
}

// 只遍历下标
for i := range array {
	fmt.Println(i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;break&lt;/code&gt; 用于终止最内层的 &lt;code&gt;for&lt;/code&gt; &lt;code&gt;switch&lt;/code&gt; &lt;code&gt;select&lt;/code&gt; 语句的执行，break 可以携带标签，用于跳出多层，若存在标签，则标签必须放在&lt;code&gt;for&lt;/code&gt; &lt;code&gt;switch&lt;/code&gt; &lt;code&gt;select&lt;/code&gt; 语句的开始处。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 终止for
L:
for i &amp;lt; n {
	switch i {
	case 5:
		break L
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;continue&lt;/code&gt; 用于结束当前循环，提前进入下一轮循环。也可以像break一样携带标签，此时程序的执行流跳转到标签的指定位置，可用于跳出多层&lt;code&gt;for&lt;/code&gt; &lt;code&gt;switch&lt;/code&gt; &lt;code&gt;select&lt;/code&gt; ，提前进入下一轮执行。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 提前进入下一轮循环
for i:=0; i &amp;lt; 3; i++ { 
	if i == 1 {
		continue
	}
	fmt.Println(i)
}
// 输出结果
0
2

// 提前进入标签处for的下一轮循环
L:
for i:=0; i &amp;lt; 2; i++ { 
	for j:=0; j &amp;lt; 3; j++{
		if j == 1 {
			continue L
		}
		fmt.Println(i, j)
	}
}
//输出结果
0 0
1 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;goto&lt;/font&gt;&lt;br&gt;
&lt;code&gt;goto&lt;/code&gt; 用于将程序的执行转移到与其标签相应的语句。可以使用 goto 退出多层&lt;code&gt;for&lt;/code&gt; &lt;code&gt;switch&lt;/code&gt; &lt;code&gt;select&lt;/code&gt;，功能类似于break携带标签。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 终止for
L:
	for i &amp;lt; n {
		switch i {
		case 5:
			goto L
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行&lt;code&gt;goto&lt;/code&gt; 不能在跳转过程中跳过变量的定义，否则编译报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	goto L  //编译报错
	v := 3
L:
	fmt.Println(v)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;在块外的goto语句不能跳转至该块中的标签。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if n%2 == 1 {
	goto L1
}
for n &amp;gt; 0 {
	f()
	n--
L1:
	f()
	n--
}
//是错误的，因为标签L1在for语句中的块而goto则不在。
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;程序设计时，尽量避免使用goto语句，因为程序执行流的随意跳转会破坏结构化设计风格，导致代码可读性下降。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;switch case default fallthrough&lt;/font&gt;&lt;br&gt;
这四个关键词是结合使用的。switch 语句提供多路执行，表达式或类型说明符与 switch 中的 case 相比较从而决定执行哪一分支。如果存在一个且最多只能存在一个 default 默认分支，所有的 case 分支都不满足时将执行 default 分支，且 default 分支不一定要放在最后的位置。Go switch 语句在执行完某个 case 子句后，不会再顺序地执行后面的 case 子句，而是结束当前 switch 语句。使用 fallthrough 可以继续执行下一个 case 或 default 子句。case 表达式可以提供多个待匹配的值，使用逗号分隔。&lt;/p&gt;
&lt;p&gt;switch 有两种形式，表达式选择 和 类型选择 。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表达式选择
表达式选择可以没有表达式，缺省为 true，这种写法也习惯地取代 if-else-if-else 语句链。表达式可以不是常量。表达式前面可以有简单语句，比如短变量申明语句。可见 Go switch 相对于 C 有较大的区别且更加灵活。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch tag {
default: s3()		// default 子句可以出现在任意位置，不一定是最后一个
case 0, 1, 2, 3: s1()	// case 表达式可以提供多个待匹配的值，使用逗号分隔
case 4, 5, 6, 7: s2()
}

switch {		// 缺失的表达式为 true
case x &amp;lt; y: f1()
fallthrough		// 强制执行下一个 case 子句
case x &amp;lt; z: f2()
// 此处没有 fallthrough，switch 执行流在此终止	
case x == 4: f3()
}

switch x := f() {	// 缺省表达式试为 true 且前面存在一条短变量申明语句
case x &amp;lt; 0: return -x	// case 表达式无需为常量
default: return x
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;类型选择&lt;br&gt;
类型选择比较类型而不是值。它类似于表达式选择，由一个特殊的表达式表示类型，该表达式的形式是使用保留字 type 的类型断言而不是实际的类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch x.(type) {
// cases
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用实际类型 T 与表达式 x 的动态类型进行匹配。与类型断言一样，x 必须是接口类型，列出的每个非接口类型T必须实现 x 且不能相同。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;switch i := x.(type) {
case int:
	printInt(i)                            // i 类型为 int
case float64:
	printFloat64(i)                        // i 类型为 float64
case func(int) float64:
	printFunction(i)                       // i 类型为 func(int) float64
case bool, string:
	printString(&amp;#34;type is bool or string&amp;#34;)  // i 类型为 bool or string
default:
	printString(&amp;#34;don&amp;#39;t know the type&amp;#34;)     // i 类型未知
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;if else&lt;/font&gt;&lt;br&gt;
if 与else 实现条件控制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可省略条件表达式的括号&lt;/li&gt;
&lt;li&gt;支持初始化语句，可定义代码块局部变量&lt;/li&gt;
&lt;li&gt;if 与 else 块中只有一条语句也需要添加大括号&lt;/li&gt;
&lt;li&gt;起始大括号必须与 if 和 else 同行&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if err := file.Chmod(0664); err != nil {
	log.Print(err)
	return err
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;return&lt;/font&gt;&lt;br&gt;
return 用于函数执行的终止并可选地提供一个或多个返回值。 任何在函数 F 中被推迟的函数会在 F 返回给其调用者前执行。如果返回值在函数返回形参中指定了名字，那么 return 时可不带返回值列表。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 无返回值
func noResult() {
	return
}

// 单返回值
func simpleF() int {
	return 2
}

// 多返回值
func complexF2() (float64, float64) {
	re = 7.0
	im = 4.0
	return re, im
}

// 返回值已具名
unc complexF3() (re float64, im float64) {
	re = 7.0
	im = 4.0
	return
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;defer&lt;/font&gt;&lt;br&gt;
defer 用于预设一个函数调用，推迟函数的执行。 被推迟的函数会在执行 defer 的函数返回之前立即执行。 例如无论以何种路径返回，都必须释放资源的函数。 典型的例子就是解锁和关闭文件。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;//将文件的内容作为字符串返回。
func Contents(filename string) (string, error) {
	f, err := os.Open(filename)
	if err != nil {
		return &amp;#34;&amp;#34;, err
	}
	defer f.Close()  // f.Close 会在函数结束后运行

	var result []byte
	buf := make([]byte, 100)
	for {
		n, err := f.Read(buf[0:])
		result = append(result, buf[0:n]...)
		if err != nil {
			if err == io.EOF {
				break
			}
			return &amp;#34;&amp;#34;, err  // 我们在这里返回后，f 就会被关闭
		}
	}
	return string(result), nil // 我们在这里返回后，f 就会被关闭
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;推迟诸如 Close 之类的函数调用有两点好处：&lt;br&gt;
第一，它能确保你不会忘记关闭文件。如果你以后又为该函数添加了新的返回路径时，这种情况往往就会发生；&lt;br&gt;
第二，它意味着“关闭”离“打开”很近，这总比将它放在函数结尾处要清晰明了。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;defer&lt;/code&gt; 注意的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;defer 函数的入参在defer 时确定&lt;br&gt;
被推迟函数的实参（如果该函数为方法还包括接收者）在推迟执行时就会求值，而不是在调用执行时才求值。这样不仅无需担心变量在 defer 函数执行前被改变，还意味着可以给 defer 函数传递不同实参。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for i := 0; i &amp;lt; 5; i++ {
	defer fmt.Printf(&amp;#34;%d &amp;#34;, i)
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多个defer函数的执行顺序为后进先出&lt;br&gt;
被推迟的函数按照后进先出（Last In First Out，LIFO）的顺序执行，因此以上代码在函数返回时会打印 4 3 2 1 0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;defer 函数在 return 语句赋值返回值与ret之间执行&lt;br&gt;
return 语句不是原子操作，而是被拆成了两步&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rval = xxx
ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而defer函数就是在这两条语句之间执行&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;rval = xxx
defer_func
ret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以被defer 的函数可以读取和修改带名称的返回值&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 返回值为 2
func c() (i int) {
    defer func() { i++ }()
    return 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;go&lt;/font&gt;&lt;br&gt;
go 用于创建 Go 程（goroutine），实现并发编程。Go 程是与其它 Go 程并发运行在同一地址空间的函数，相比于线程与进程，它是轻量级的。Go 程在多线程操作系统上可实现多路复用，因此若一个线程阻塞，比如说等待 I/O，那么其它的线程就会运行。Go 程的设计隐藏了线程创建和管理的诸多复杂性。&lt;/p&gt;
&lt;p&gt;在函数或方法前添加 go 关键字能够在新的 Go 程中调用它。当调用完成后，该 Go 程也会安静地退出。效果有点像 Unix Shell 中的 &amp;amp; 符号，它能让命令在后台运行。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import (
	&amp;#34;fmt&amp;#34;   
	&amp;#34;time&amp;#34;  
)

func main() {
	go func(){ 
		fmt.Println(&amp;#34;in first goroutine&amp;#34;)
	}()     
	go func(){ 
		fmt.Println(&amp;#34;in second goroutine&amp;#34;)
	}()     

	fmt.Println(&amp;#34;main thread start sleep, and other goroutine start execute&amp;#34;)
	time.Sleep(10*time.Second)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;main thread start sleep, and other goroutine start execute
in second goroutine
in first goroutine
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出结果得知，go程 的执行顺序和创建的顺序是没有关系的，也就是说存在多个 go程 时，其执行顺序是随机的。&lt;/p&gt;
&lt;p&gt;&lt;font color=#0099ff size=2 face=&#34;黑体&#34;&gt;select&lt;/font&gt;&lt;br&gt;
select 语句用来选择一组中某个 case 中的发送或接收操作可以被立即执行。它类似于 switch 语句，但是它的 case 必须是一个通信操作。&lt;/p&gt;
&lt;p&gt;也就是说 select 是用来监听和 channel 有关的 IO 操作，它与 select，poll，epoll 相似，当 IO 操作发生时，触发相应的动作，实现 IO 多路复用。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
    ch1 := make(chan int, 1)
    ch2 := make(chan int, 1)

    ch1 &amp;lt;- 3
    ch2 &amp;lt;- 5

    select {
    case &amp;lt;- ch1:
        fmt.Println(&amp;#34;ch1 selected&amp;#34;)
    case &amp;lt;- ch2:
        fmt.Println(&amp;#34;ch2 selected&amp;#34;)
	default:
		// 如果ch1与ch2没有数据到来，则进入default处理流程。如果没有default子句，则select一直阻塞等待ch1与ch2的数据到来
		fmt.Println(&amp;#34;default&amp;#34;)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ch1 selected

// 或者
ch2 selected
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从输出结果得知，当存在多个case满足条件，即有多个 channel 存在数据时，会随机地选择一个执行。&lt;br&gt;
若想让某个 go程 永久阻塞，可以使用没有case和default语句的select：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;select{}

# 等效于
for{}
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
  </channel>
</rss>